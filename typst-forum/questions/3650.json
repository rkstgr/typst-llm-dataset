{
  "topic_metadata": {
    "id": 3650,
    "title": "How to allow reusing of labels in different sections?",
    "slug": "how-to-allow-reusing-of-labels-in-different-sections",
    "posts_count": 8,
    "created_at": "2025-04-14T15:32:38.998Z",
    "last_posted_at": "2025-04-22T19:50:48.222Z",
    "views": 90,
    "like_count": 5,
    "reply_count": 5,
    "has_accepted_answer": true,
    "accepted_answer_post_number": 2,
    "accepted_answer_username": "bluss",
    "tags": [
      "scripting",
      "referencing"
    ],
    "category_id": 5,
    "participant_count": 3,
    "word_count": 933
  },
  "posts": [
    {
      "id": 11069,
      "post_number": 1,
      "username": "Regodin",
      "name": "",
      "created_at": "2025-04-14T15:32:39.237Z",
      "updated_at": "2025-04-26T19:57:46.517Z",
      "cooked": "<p>I want to create a template that allows to reuse labels between sections, but having difficulty working with queries and not have them cause issues due to not being able to converge.</p>\n<p>The goal of my template is to have multiple sections with the same subsections, and be able to use label and references to jump between the subsections.</p>\n<p>For example:</p>\n<pre data-code-wrap=\"typst\"><code class=\"lang-typst\">= Section 1\n== Sub 1&lt;sub1&gt;\n== Sub 2&lt;sub2&gt;\nGo to @sub1\n\n= Section 2\n== Sub 1&lt;sub1&gt;\nGo to @sub2\n== Sub 2&lt;sub2&gt;\n</code></pre>\n<p>Is there a way to limit reference or query scopes to within a single section?</p>",
      "raw": "I want to create a template that allows to reuse labels between sections, but having difficulty working with queries and not have them cause issues due to not being able to converge.\n\nThe goal of my template is to have multiple sections with the same subsections, and be able to use label and references to jump between the subsections.\n\nFor example:\n```typst\n= Section 1\n== Sub 1<sub1>\n== Sub 2<sub2>\nGo to @sub1\n\n= Section 2\n== Sub 1<sub1>\nGo to @sub2\n== Sub 2<sub2>\n```\n\nIs there a way to limit reference or query scopes to within a single section?",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 31,
      "score": 71.2,
      "accepted_answer": false,
      "trust_level": 1,
      "user_id": 1161
    },
    {
      "id": 11070,
      "post_number": 2,
      "username": "bluss",
      "name": "Ulrik",
      "created_at": "2025-04-14T15:47:56.694Z",
      "updated_at": "2025-04-14T15:47:56.694Z",
      "cooked": "<p>You can do it like this. In this case - find the top level headings and decide a “bounding box” - only look locally inside the current top level heading. Then place a custom link to that (not using ref)</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let maybelast(x) = {\n  if x.len() &gt; 0 { return x.last() }\n}\n#let maybefirst(x) = {\n  if x.len() &gt; 0 { return x.first() }\n}\n\n#let localref(lab) = context {\n  let mysections = query(heading.where(level: 1).before(here()))\n  let nextsections = query(heading.where(level: 1).after(here()))\n  let mysection = maybelast(mysections)\n  let nextsection = maybefirst(nextsections)\n  let sel = selector(lab)\n  if mysection != none {\n    sel = sel.after(mysection.location())\n  }\n  if nextsection != none {\n    sel = sel.before(nextsection.location())\n  }\n  let locations = query(sel)\n  for loc in locations {\n    link(loc.location())[Section #loc.body]\n    break\n  }\n}\n\n= Section 1\n== Sub 1&lt;sub1&gt;\n== Sub 2&lt;sub2&gt;\nGo to #localref(&lt;sub1&gt;)\n\n= Section 2\n== Sub 1&lt;sub1&gt;\nGo to #localref(&lt;sub2&gt;)\n== Sub 2&lt;sub2&gt;\n</code></pre>\n<p>We can do this because labels don’t need to be unique. But labels used with <code>ref</code> seem to need to be unique, so then we can’t do this with ref.</p>",
      "raw": "You can do it like this. In this case - find the top level headings and decide a \"bounding box\" - only look locally inside the current top level heading. Then place a custom link to that (not using ref)\n\n\n```typ\n#let maybelast(x) = {\n  if x.len() > 0 { return x.last() }\n}\n#let maybefirst(x) = {\n  if x.len() > 0 { return x.first() }\n}\n\n#let localref(lab) = context {\n  let mysections = query(heading.where(level: 1).before(here()))\n  let nextsections = query(heading.where(level: 1).after(here()))\n  let mysection = maybelast(mysections)\n  let nextsection = maybefirst(nextsections)\n  let sel = selector(lab)\n  if mysection != none {\n    sel = sel.after(mysection.location())\n  }\n  if nextsection != none {\n    sel = sel.before(nextsection.location())\n  }\n  let locations = query(sel)\n  for loc in locations {\n    link(loc.location())[Section #loc.body]\n    break\n  }\n}\n\n= Section 1\n== Sub 1<sub1>\n== Sub 2<sub2>\nGo to #localref(<sub1>)\n\n= Section 2\n== Sub 1<sub1>\nGo to #localref(<sub2>)\n== Sub 2<sub2>\n```\n\nWe can do this because labels don't need to be unique. But labels used with `ref` seem to need to be unique, so then we can't do this with ref.",
      "reply_to_post_number": null,
      "reply_count": 3,
      "quote_count": 0,
      "like_count": 2,
      "reads": 30,
      "score": 51.0,
      "accepted_answer": true,
      "trust_level": 3,
      "user_id": 1272
    },
    {
      "id": 11073,
      "post_number": 3,
      "username": "Regodin",
      "name": "",
      "created_at": "2025-04-14T16:16:08.071Z",
      "updated_at": "2025-04-14T16:16:08.071Z",
      "cooked": "<p>Ahh I see! I was considering going this way at first, but, wanted to make sure there wasn’t an easier way to modify the <span class=\"mention\">@ref</span> behavior to do it. And your code looks a lot simpler and clean than what I would have done lol! I was trying to loop over queries and compare heading levels and stuff…</p>\n<p>Thanks for your help! I appreciate it <img src=\"https://forum.typst.app/images/emoji/apple/slight_smile.png?v=12\" title=\":slight_smile:\" class=\"emoji\" alt=\":slight_smile:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>",
      "raw": "Ahh I see! I was considering going this way at first, but, wanted to make sure there wasn't an easier way to modify the @ref behavior to do it. And your code looks a lot simpler and clean than what I would have done lol! I was trying to loop over queries and compare heading levels and stuff..\n\nThanks for your help! I appreciate it :slight_smile:",
      "reply_to_post_number": 2,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 26,
      "score": 5.2,
      "accepted_answer": false,
      "trust_level": 1,
      "user_id": 1161
    },
    {
      "id": 11181,
      "post_number": 4,
      "username": "Andrew",
      "name": "",
      "created_at": "2025-04-16T18:39:42.202Z",
      "updated_at": "2025-04-16T18:39:42.202Z",
      "cooked": "<p>I don’t understand why for loop is used if each subsection has a unique name, and you want to reference one at a time. There should be either <code>query(sel).first()</code> or an additional assertion before this.</p>",
      "raw": "I don't understand why for loop is used if each subsection has a unique name, and you want to reference one at a time. There should be either `query(sel).first()` or an additional assertion before this.",
      "reply_to_post_number": 2,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 21,
      "score": 4.2,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 51
    },
    {
      "id": 11442,
      "post_number": 5,
      "username": "Regodin",
      "name": "",
      "created_at": "2025-04-22T18:23:41.894Z",
      "updated_at": "2025-04-22T18:43:43.979Z",
      "cooked": "<p>Hey bluss,</p>\n<p>I just noticed that if used in a heading, it is blank when viewed in an outline. Is there a way to circumvent that issue? I’d be satisfied with just printing out the <code>lab</code> variable if the full name at location is not an option. Do you have any clue if this can be achieved?</p>\n<p>I’m having difficulty figuring out a solution; when I return the localref result directly, I get my full title wherever localref is called, but if I try to look at the fields, I get <code>(:)</code>.</p>",
      "raw": "Hey bluss,\n\nI just noticed that if used in a heading, it is blank when viewed in an outline. Is there a way to circumvent that issue? I'd be satisfied with just printing out the `lab` variable if the full name at location is not an option. Do you have any clue if this can be achieved?\n\nI'm having difficulty figuring out a solution; when I return the localref result directly, I get my full title wherever localref is called, but if I try to look at the fields, I get `(:)`.",
      "reply_to_post_number": 2,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 17,
      "score": 3.4,
      "accepted_answer": false,
      "trust_level": 1,
      "user_id": 1161
    },
    {
      "id": 11444,
      "post_number": 6,
      "username": "bluss",
      "name": "Ulrik",
      "created_at": "2025-04-22T18:46:32.997Z",
      "updated_at": "2025-04-22T19:02:19.852Z",
      "cooked": "<p>I think you mean this situation: you use the <code>localref</code> function inside a heading title? Two things you can detect - that the current section in localref resolution is Contents. Or that you can’t find any “local match” for the label. Both are true in that case.</p>\n<p>I don’t know if we can do correct resolution of the “local reference” in the outline, without redefining how the outline is drawn.</p>\n<details>\n<summary>code for handling missing reference</summary>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let maybelast(x) = {\n  if x.len() &gt; 0 { return x.last() }\n}\n#let maybefirst(x) = {\n  if x.len() &gt; 0 { return x.first() }\n}\n\n#let localref(lab) = context {\n  let mysection = maybelast(query(heading.where(level: 1).before(here())))\n  let nextsection = maybefirst(query(heading.where(level: 1).after(here())))\n  let sel = selector(lab)\n  if mysection != none {\n    sel = sel.after(mysection.location())\n  }\n  if nextsection != none {\n    sel = sel.before(nextsection.location())\n  }\n  let locations = query(sel)\n  if locations.len() &gt; 0 {\n    let loc = locations.at(0)\n    link(loc.location())[Section #loc.body]\n  } else {\n    ['#str(lab)' (My current section is called #mysection.body)]\n  }\n}\n\n#outline()\n\n= Section 1\n== Sub 1&lt;sub1&gt;\n== Sub 2&lt;sub2&gt;\nGo to #localref(&lt;sub1&gt;)\n\n= Section 2\n== Sub 1&lt;sub1&gt;\nGo to #localref(&lt;sub2&gt;)\n== Sub 2&lt;sub2&gt;\n== See also #localref(&lt;sub2&gt;)\n</code></pre>\n</details>",
      "raw": "I think you mean this situation: you use the `localref` function inside a heading title? Two things you can detect - that the current section in localref resolution is Contents. Or that you can't find any \"local match\" for the label. Both are true in that case.\n\nI don't know if we can do correct resolution of the \"local reference\" in the outline, without redefining how the outline is drawn. \n<details>\n<summary>code for handling missing reference</summary>\n\n```typ\n#let maybelast(x) = {\n  if x.len() > 0 { return x.last() }\n}\n#let maybefirst(x) = {\n  if x.len() > 0 { return x.first() }\n}\n\n#let localref(lab) = context {\n  let mysection = maybelast(query(heading.where(level: 1).before(here())))\n  let nextsection = maybefirst(query(heading.where(level: 1).after(here())))\n  let sel = selector(lab)\n  if mysection != none {\n    sel = sel.after(mysection.location())\n  }\n  if nextsection != none {\n    sel = sel.before(nextsection.location())\n  }\n  let locations = query(sel)\n  if locations.len() > 0 {\n    let loc = locations.at(0)\n    link(loc.location())[Section #loc.body]\n  } else {\n    ['#str(lab)' (My current section is called #mysection.body)]\n  }\n}\n\n#outline()\n\n= Section 1\n== Sub 1<sub1>\n== Sub 2<sub2>\nGo to #localref(<sub1>)\n\n= Section 2\n== Sub 1<sub1>\nGo to #localref(<sub2>)\n== Sub 2<sub2>\n== See also #localref(<sub2>)\n```\n\n</details>",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 1,
      "reads": 16,
      "score": 18.2,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 1272
    },
    {
      "id": 11447,
      "post_number": 7,
      "username": "bluss",
      "name": "Ulrik",
      "created_at": "2025-04-22T19:01:56.311Z",
      "updated_at": "2025-04-22T19:01:56.311Z",
      "cooked": "<p>This is how we can hack the outline so that we can resolve <code>localref</code> inside the outline. We (unfortunately) use show rules for outline entries so that we can track “where we are” in the outline hierarchy.</p>\n<details>\n<summary>the code</summary>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let maybelast(x) = {\n  if x.len() &gt; 0 { return x.last() }\n}\n#let maybefirst(x) = {\n  if x.len() &gt; 0 { return x.first() }\n}\n\n#let currently-outlining = state(\"currentoutline\", none)\n\n#show outline.entry.where(level: 1): it =&gt; {\n  currently-outlining.update(_ =&gt; it.element)\n  it\n}\n#show outline: it =&gt; {\n  it\n  currently-outlining.update(_ =&gt; none)\n}\n\n#let localref(lab) = context {\n  let co = currently-outlining.get()\n  let mysection\n  let here-i-am = here()\n  if co != none {\n    // we are drawing the outline right now\n    mysection = co\n    here-i-am = co.location()\n  } else {\n    mysection = maybelast(query(heading.where(level: 1).before(here-i-am)))\n  }\n  let nextsection = maybefirst(query(heading.where(level: 1).after(here-i-am, inclusive: false)))\n  let sel = selector(lab)\n  if mysection != none {\n    sel = sel.after(mysection.location())\n  }\n  if nextsection != none {\n    sel = sel.before(nextsection.location())\n  }\n  let locations = query(sel)\n  if locations.len() &gt; 0 {\n    let loc = locations.at(0)\n    link(loc.location())[Section #loc.body]\n  } else {\n    // Fallback case if the local reference is not found. Could also be panic()\n    ['#str(lab)']\n  }\n}\n\n#outline()\n\n= Section 1\n== Sub 1&lt;sub1&gt;\n== Sub 2&lt;sub2&gt;\nGo to #localref(&lt;sub1&gt;)\n\n= Section 2\n== Sub 1&lt;sub1&gt;\nGo to #localref(&lt;sub2&gt;)\n== Sub 2&lt;sub2&gt;\n== See also #localref(&lt;sub2&gt;)\n</code></pre>\n<p><img src=\"https://forum.typst.app/uploads/default/original/2X/b/b5e1fcc0c49d73b44240d637c72772ee2c12ff89.png\" alt=\"bild\" data-base62-sha1=\"pX0B3J3xR4Y7cynzVaQCVNZOcoF\" width=\"487\" height=\"418\"></p>\n</details>",
      "raw": "This is how we can hack the outline so that we can resolve `localref` inside the outline. We (unfortunately) use show rules for outline entries so that we can track \"where we are\" in the outline hierarchy.\n\n<details>\n<summary>the code</summary>\n\n```typ\n#let maybelast(x) = {\n  if x.len() > 0 { return x.last() }\n}\n#let maybefirst(x) = {\n  if x.len() > 0 { return x.first() }\n}\n\n#let currently-outlining = state(\"currentoutline\", none)\n\n#show outline.entry.where(level: 1): it => {\n  currently-outlining.update(_ => it.element)\n  it\n}\n#show outline: it => {\n  it\n  currently-outlining.update(_ => none)\n}\n\n#let localref(lab) = context {\n  let co = currently-outlining.get()\n  let mysection\n  let here-i-am = here()\n  if co != none {\n    // we are drawing the outline right now\n    mysection = co\n    here-i-am = co.location()\n  } else {\n    mysection = maybelast(query(heading.where(level: 1).before(here-i-am)))\n  }\n  let nextsection = maybefirst(query(heading.where(level: 1).after(here-i-am, inclusive: false)))\n  let sel = selector(lab)\n  if mysection != none {\n    sel = sel.after(mysection.location())\n  }\n  if nextsection != none {\n    sel = sel.before(nextsection.location())\n  }\n  let locations = query(sel)\n  if locations.len() > 0 {\n    let loc = locations.at(0)\n    link(loc.location())[Section #loc.body]\n  } else {\n    // Fallback case if the local reference is not found. Could also be panic()\n    ['#str(lab)']\n  }\n}\n\n#outline()\n\n= Section 1\n== Sub 1<sub1>\n== Sub 2<sub2>\nGo to #localref(<sub1>)\n\n= Section 2\n== Sub 1<sub1>\nGo to #localref(<sub2>)\n== Sub 2<sub2>\n== See also #localref(<sub2>)\n```\n\n![bild|487x418](upload://pX0B3J3xR4Y7cynzVaQCVNZOcoF.png)\n\n</details>",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 1,
      "reads": 16,
      "score": 28.2,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 1272
    },
    {
      "id": 11448,
      "post_number": 8,
      "username": "Regodin",
      "name": "",
      "created_at": "2025-04-22T19:50:48.222Z",
      "updated_at": "2025-04-22T19:50:48.222Z",
      "cooked": "<p>This solution worked great!</p>\n<p>Thanks for helping me out, I appreciate it!</p>",
      "raw": "This solution worked great! \n\nThanks for helping me out, I appreciate it!",
      "reply_to_post_number": 7,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 1,
      "reads": 17,
      "score": 28.4,
      "accepted_answer": false,
      "trust_level": 1,
      "user_id": 1161
    }
  ],
  "scraped_at": "2025-06-10T09:49:13.067021"
}