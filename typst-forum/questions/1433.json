{
  "topic_metadata": {
    "id": 1433,
    "title": "Is an assert supposed to be able to change behavior when it \"doesn't\" fail?",
    "slug": "is-an-assert-supposed-to-be-able-to-change-behavior-when-it-doesnt-fail",
    "posts_count": 4,
    "created_at": "2024-10-30T12:02:04.522Z",
    "last_posted_at": "2025-02-23T15:56:26.600Z",
    "views": 116,
    "like_count": 3,
    "reply_count": 2,
    "has_accepted_answer": true,
    "accepted_answer_post_number": 2,
    "accepted_answer_username": "laurmaedje",
    "tags": [
      "scripting"
    ],
    "category_id": 5,
    "participant_count": 2,
    "word_count": 694
  },
  "posts": [
    {
      "id": 4852,
      "post_number": 1,
      "username": "SillyFreak",
      "name": "SillyFreak",
      "created_at": "2024-10-30T12:02:04.687Z",
      "updated_at": "2024-10-31T08:41:32.553Z",
      "cooked": "<p>I was trying to minimize an issue in fletcher’s manual and reduced it down to the following (this still depends on CeTZ and fletcher so it’s not properly minimal, but hopefully small enough to discuss the issue):</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#import \"@preview/cetz:0.3.1\": draw, vector\n#import \"@preview/fletcher:0.5.2\" as fletcher: diagram, node\n\n// this is copy-pasted from fletcher\n#let pill(node, extrude) = {\n  let size = node.size.map(i =&gt; i + 2*extrude)\n  // assert(size.any(x =&gt; x &gt; 0pt))\n  draw.rect(\n    vector.scale(size, -0.5),\n    vector.scale(size, +0.5),\n    radius: calc.min(..size)/2,\n  )\n}\n\n#diagram(node((0,0), link(label(\"pill()\"), raw(\"pill\")), shape: pill,\n  fill: green.lighten(90%), stroke: green))\n\n= pill#label(\"pill()\")\n</code></pre>\n<p>This does not compile, with the following error:</p>\n<pre><code class=\"lang-auto\">error: array is empty\n   ┌─ @preview/cetz:0.3.1/src/drawable.typ:45:10\nhelp: error occurred in this call of function `path`\n     ┌─ @preview/cetz:0.3.1/src/draw/shapes.typ:1145:8\nhelp: error occurred in this function call\n   ┌─ @preview/cetz:0.3.1/src/process.typ:17:22\n...\n</code></pre>\n<p>After some bisecting (because <a href=\"https://github.com/typst/typst/issues/1747\">the stack trace is incomplete due to context being involved</a>) I figured out that a rectangle with zero size causes this error inside CeTZ, and that the function that drew the rectangle was the one reproduced above.</p>\n<p>I thought an <code>assert()</code> check could at least bring the mistake to light earlier, so I inserted <code>assert(size.any(x =&gt; x &gt; 0pt))</code> – and that made the document compile!</p>\n<p>I have a rough idea what’s happening here: the node’s label from which the node size is computed is <code>link(label(\"pill()\"), raw(\"pill\"))</code>. The link element probably gets its measurements late (probably because links in general also need to handle things such as inferring the text from the referenced label), thus an “early” <code>measure()</code> returns <code>(0pt, 0pt)</code>, making CeTZ fail. By the time the size would be known, the compilation has already failed.<br>\n<code>assert()</code> seems to be handled differently, just trying again and eventually resulting in the node size to be positive, and thus a successful compilation.</p>\n<p>My question now is: is this <em>supposed</em> to happen/expected or should Typst’s behavior not be influenced by a successful assert?</p>\n<p>I assume there’s something wrong in how fletcher measures and then stores the result for later use, but I’m also pretty sure that this assert is not the ideal fix for that. I’d also be interested in uncovering the specific anti-pattern that is at fault here – but that’s probably my responsibility, further minimizing the example I’ve come up with here.</p>",
      "raw": "I was trying to minimize an issue in fletcher's manual and reduced it down to the following (this still depends on CeTZ and fletcher so it's not properly minimal, but hopefully small enough to discuss the issue):\n```typ\n#import \"@preview/cetz:0.3.1\": draw, vector\n#import \"@preview/fletcher:0.5.2\" as fletcher: diagram, node\n\n// this is copy-pasted from fletcher\n#let pill(node, extrude) = {\n  let size = node.size.map(i => i + 2*extrude)\n  // assert(size.any(x => x > 0pt))\n  draw.rect(\n    vector.scale(size, -0.5),\n    vector.scale(size, +0.5),\n    radius: calc.min(..size)/2,\n  )\n}\n\n#diagram(node((0,0), link(label(\"pill()\"), raw(\"pill\")), shape: pill,\n  fill: green.lighten(90%), stroke: green))\n\n= pill#label(\"pill()\")\n```\n\nThis does not compile, with the following error:\n```\nerror: array is empty\n   ┌─ @preview/cetz:0.3.1/src/drawable.typ:45:10\nhelp: error occurred in this call of function `path`\n     ┌─ @preview/cetz:0.3.1/src/draw/shapes.typ:1145:8\nhelp: error occurred in this function call\n   ┌─ @preview/cetz:0.3.1/src/process.typ:17:22\n...\n```\nAfter some bisecting (because [the stack trace is incomplete due to context being involved](https://github.com/typst/typst/issues/1747)) I figured out that a rectangle with zero size causes this error inside CeTZ, and that the function that drew the rectangle was the one reproduced above.\n\nI thought an `assert()` check could at least bring the mistake to light earlier, so I inserted `assert(size.any(x => x > 0pt))` -- and that made the document compile!\n\nI have a rough idea what's happening here: the node's label from which the node size is computed is `link(label(\"pill()\"), raw(\"pill\"))`. The link element probably gets its measurements late (probably because links in general also need to handle things such as inferring the text from the referenced label), thus an \"early\" `measure()` returns `(0pt, 0pt)`, making CeTZ fail. By the time the size would be known, the compilation has already failed.\n`assert()` seems to be handled differently, just trying again and eventually resulting in the node size to be positive, and thus a successful compilation.\n\nMy question now is: is this _supposed_ to happen/expected or should Typst's behavior not be influenced by a successful assert?\n\nI assume there's something wrong in how fletcher measures and then stores the result for later use, but I'm also pretty sure that this assert is not the ideal fix for that. I'd also be interested in uncovering the specific anti-pattern that is at fault here -- but that's probably my responsibility, further minimizing the example I've come up with here.",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 1,
      "reads": 44,
      "score": 168.8,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 32
    },
    {
      "id": 4861,
      "post_number": 2,
      "username": "laurmaedje",
      "name": "Laurenz Mädje",
      "created_at": "2024-10-30T16:44:00.292Z",
      "updated_at": "2024-10-30T16:44:00.292Z",
      "cooked": "<p>This has come up before here: <a href=\"https://github.com/typst/typst/issues/5015\" class=\"inline-onebox\">Execution error in context can have an effect on layout · Issue #5015 · typst/typst · GitHub</a></p>\n<p>In general, Typst will catch any error in a show rule (or context, which is resolved by a show rule) and only print it if it remains by the last iteration. This frees the users from caring about things like <code>query(heading).first()</code> throwing in the first iteration (because nothing is known yet). But, on the downside, it can cause such strangeness. It’s a tradeoff.</p>",
      "raw": "This has come up before here: https://github.com/typst/typst/issues/5015\n\nIn general, Typst will catch any error in a show rule (or context, which is resolved by a show rule) and only print it if it remains by the last iteration. This frees the users from caring about things like `query(heading).first()` throwing in the first iteration (because nothing is known yet). But, on the downside, it can cause such strangeness. It's a tradeoff.",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 1,
      "reads": 34,
      "score": 46.8,
      "accepted_answer": true,
      "trust_level": 4,
      "user_id": 2
    },
    {
      "id": 4886,
      "post_number": 3,
      "username": "SillyFreak",
      "name": "SillyFreak",
      "created_at": "2024-10-31T08:30:45.818Z",
      "updated_at": "2024-10-31T08:30:45.818Z",
      "cooked": "<p>Thanks! One thing that is a bit different is that here, compilation <em>fails</em> with the <code>assert</code> not present. In other words, the intended behavior is to suppress compilation errors, but here one gets through.</p>\n<p>I now minified it completely:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">= foo &lt;x&gt;\n\n#let body = link(label(\"x\"), \"foo\")\n\n// #context [\n//   #let size = measure(body)\n//   #assert(size.values().any(x =&gt; x &gt; 0pt))\n\n  #layout(_ =&gt; {\n    let size = measure(body)\n    assert(size.values().any(x =&gt; x &gt; 0pt))\n    body\n  })\n// ]\n</code></pre>\n<p>I was able to narrow it down to only happening inside <code>layout</code>, not with context or any of the deprecated functions (<code>style</code>, <code>locate</code>) which I assume just work like context under the hood now.</p>\n<p>Is this a (separate) bug then, or is there some reason that makes it harder for errors in <code>layout</code> to get the suppression treatment that context does?</p>",
      "raw": "Thanks! One thing that is a bit different is that here, compilation _fails_ with the `assert` not present. In other words, the intended behavior is to suppress compilation errors, but here one gets through.\n\nI now minified it completely:\n```typ\n= foo <x>\n\n#let body = link(label(\"x\"), \"foo\")\n\n// #context [\n//   #let size = measure(body)\n//   #assert(size.values().any(x => x > 0pt))\n\n  #layout(_ => {\n    let size = measure(body)\n    assert(size.values().any(x => x > 0pt))\n    body\n  })\n// ]\n```\n I was able to narrow it down to only happening inside `layout`, not with context or any of the deprecated functions (`style`, `locate`) which I assume just work like context under the hood now.\n\nIs this a (separate) bug then, or is there some reason that makes it harder for errors in `layout` to get the suppression treatment that context does?",
      "reply_to_post_number": 2,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 0,
      "reads": 28,
      "score": 50.6,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 32
    },
    {
      "id": 8922,
      "post_number": 4,
      "username": "laurmaedje",
      "name": "Laurenz Mädje",
      "created_at": "2025-02-23T15:56:26.600Z",
      "updated_at": "2025-02-23T15:56:26.600Z",
      "cooked": "<p>It’s not intentional that layout does not have the suppression treatment. Right now, the supression is not in context, but more generally in show rule application. And layout doesn’t go through that code path.</p>",
      "raw": "It's not intentional that layout does not have the suppression treatment. Right now, the supression is not in context, but more generally in show rule application. And layout doesn't go through that code path.",
      "reply_to_post_number": 3,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 1,
      "reads": 14,
      "score": 47.8,
      "accepted_answer": false,
      "trust_level": 4,
      "user_id": 2
    }
  ],
  "scraped_at": "2025-06-10T09:55:45.504423"
}