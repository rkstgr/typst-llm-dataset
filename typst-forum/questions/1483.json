{
  "topic_metadata": {
    "id": 1483,
    "title": "Why is State Final not \"final\"?",
    "slug": "why-is-state-final-not-final",
    "posts_count": 6,
    "created_at": "2024-11-01T15:45:43.215Z",
    "last_posted_at": "2024-11-11T16:14:16.819Z",
    "views": 328,
    "like_count": 1,
    "reply_count": 3,
    "has_accepted_answer": true,
    "accepted_answer_post_number": 2,
    "accepted_answer_username": "SillyFreak",
    "tags": [
      "scripting",
      "state",
      "introspection"
    ],
    "category_id": 5,
    "participant_count": 2,
    "word_count": 1332
  },
  "posts": [
    {
      "id": 5000,
      "post_number": 1,
      "username": "Rogier",
      "name": "Rogier",
      "created_at": "2024-11-01T15:45:43.366Z",
      "updated_at": "2024-11-04T18:38:25.453Z",
      "cooked": "<p>Hi all,</p>\n<p>I’ve been trying to keep track of an array of objects within my document in a “state” variable. I use the end result of the state at the end of the document to create a table at the beginning of my document. (it’s for document referencing)</p>\n<p>I’m running into the odd problem that the “final” keyword does not seem to return the final version of the array. In fact, as far as I can tell it returns an array that should have never existed anywhere in the code.</p>\n<p>Minimum Viable Product code:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#context state(\"test_state\",0).update((\n    \"TEST_01\": (\"VAR_1\", \"VAR_02\", \"VAR_03\"),\n    \"TEST_02\": (\"VAR_4\", \"VAR_05\", \"VAR_06\"),\n    \"TEST_03\": (\"VAR_7\", \"VAR_08\", \"VAR_09\"),\n))\n\n#let change_state(ref, num) = {\n    context{\n        let ts = state(\"test_state\").get()\n        if(ts.at(ref).at(num) != \"CHANGED\"){\n            ts.at(ref).at(num) = \"CHANGED\"\n        }\n        state(\"test_state\").update(ts)\n        [#ts]\n    }\n}\n\nFINAL:\n#context state(\"test_state\").final()\n\nCHANGE 01 02\n#change_state(\"TEST_01\",2)\n\nCHANGE 02 01\n#change_state(\"TEST_02\",1)\n\nCHANGE 02 02 \n#change_state(\"TEST_02\",2)\n\nCHANGE 03 01\n#change_state(\"TEST_03\",0)\n</code></pre>\n<p>What I would expect is that the final print after “CHANGE 03 01” is the same as the “FINAL” print. Since the state of the test_state there is the final version of the state.</p>\n<p>However as you can see in the screenshot below, for some reason the .final() state is a permutation of the matrix that does not match. In fact, this permutation of the table has never existed anywhere in the document…</p>\n<p>Row 1 is modified in the first function call of change_state. So I don’t see how it’s possible that the “final” version has an unmodified row 1, whilst some of the other rows are modified… I’m not sure if this is a bug or me not understanding how state variables work.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://forum.typst.app/uploads/default/original/2X/8/8ec46afe36c2da6d540fb9767677546d6fd5c719.png\" data-download-href=\"https://forum.typst.app/uploads/default/8ec46afe36c2da6d540fb9767677546d6fd5c719\" title=\"image\"><img src=\"https://forum.typst.app/uploads/default/optimized/2X/8/8ec46afe36c2da6d540fb9767677546d6fd5c719_2_304x500.png\" alt=\"image\" data-base62-sha1=\"kmYCHON34gjcLzqpqnPqVs9RHAd\" width=\"304\" height=\"500\" srcset=\"https://forum.typst.app/uploads/default/optimized/2X/8/8ec46afe36c2da6d540fb9767677546d6fd5c719_2_304x500.png, https://forum.typst.app/uploads/default/original/2X/8/8ec46afe36c2da6d540fb9767677546d6fd5c719.png 1.5x, https://forum.typst.app/uploads/default/original/2X/8/8ec46afe36c2da6d540fb9767677546d6fd5c719.png 2x\" data-dominant-color=\"F2F6F1\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">image</span><span class=\"informations\">448×735 126 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>",
      "raw": "Hi all,\n\nI've been trying to keep track of an array of objects within my document in a \"state\" variable. I use the end result of the state at the end of the document to create a table at the beginning of my document. (it's for document referencing)\n\nI'm running into the odd problem that the \"final\" keyword does not seem to return the final version of the array. In fact, as far as I can tell it returns an array that should have never existed anywhere in the code. \n\nMinimum Viable Product code:\n\n```typ\n#context state(\"test_state\",0).update((\n    \"TEST_01\": (\"VAR_1\", \"VAR_02\", \"VAR_03\"),\n    \"TEST_02\": (\"VAR_4\", \"VAR_05\", \"VAR_06\"),\n    \"TEST_03\": (\"VAR_7\", \"VAR_08\", \"VAR_09\"),\n))\n\n#let change_state(ref, num) = {\n    context{\n        let ts = state(\"test_state\").get()\n        if(ts.at(ref).at(num) != \"CHANGED\"){\n            ts.at(ref).at(num) = \"CHANGED\"\n        }\n        state(\"test_state\").update(ts)\n        [#ts]\n    }\n}\n\nFINAL:\n#context state(\"test_state\").final()\n\nCHANGE 01 02\n#change_state(\"TEST_01\",2)\n\nCHANGE 02 01\n#change_state(\"TEST_02\",1)\n\nCHANGE 02 02 \n#change_state(\"TEST_02\",2)\n\nCHANGE 03 01\n#change_state(\"TEST_03\",0)\n```\n\nWhat I would expect is that the final print after \"CHANGE 03 01\" is the same as the \"FINAL\" print. Since the state of the test_state there is the final version of the state. \n\nHowever as you can see in the screenshot below, for some reason the .final() state is a permutation of the matrix that does not match. In fact, this permutation of the table has never existed anywhere in the document... \n\nRow 1 is modified in the first function call of change_state. So I don't see how it's possible that the \"final\" version has an unmodified row 1, whilst some of the other rows are modified... I'm not sure if this is a bug or me not understanding how state variables work.\n\n![image|304x500](upload://kmYCHON34gjcLzqpqnPqVs9RHAd.png)",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 67,
      "score": 388.4,
      "accepted_answer": false,
      "trust_level": 1,
      "user_id": 263
    },
    {
      "id": 5002,
      "post_number": 2,
      "username": "SillyFreak",
      "name": "SillyFreak",
      "created_at": "2024-11-01T16:21:46.442Z",
      "updated_at": "2024-11-01T16:26:52.711Z",
      "cooked": "<p>If you look closely, you’ll see that Typst is actually warning you about a problem with your document:</p>\n<blockquote>\n<p>Layout did not converge within 5 attempts</p>\n</blockquote>\n<p>This problem is hard to debug in general, but here the source of the problem is fairly easy to recognize and fix: your state updates are structured like</p>\n<pre data-code-wrap=\"typc\"><code class=\"lang-typc\">context {\n  x = foo.get()\n  ..\n  foo.update(x)\n}\n</code></pre>\n<p>instead of the proper form:</p>\n<pre data-code-wrap=\"typc\"><code class=\"lang-typc\">foo.update(x =&gt; {\n  ..\n  x\n})\n</code></pre>\n<p>This uses the form of <code>update()</code> where you give it a function that computes the new value from the old one.</p>\n<p>The <a href=\"https://typst.app/docs/reference/introspection/state/#state-in-typst\">docs</a> have the following example that matches your use case:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let compute(expr) = [\n  #s.update(x =&gt;\n    eval(expr.replace(\"x\", str(x)))\n  )\n  New value is #context s.get().\n]\n</code></pre>\n<p>here there is first an <code>update</code> that uses a function, followed by a <code>context get()</code> that displays the new value.</p>\n<p>Applied to your use case, the code would look like this:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let change_state(ref, num) = {\n  state(\"test_state\").update(ts =&gt; {\n    if ts.at(ref).at(2) != \"CHANGED\" {\n        ts.at(ref).at(num) = \"CHANGED\"\n    }\n    ts\n  })\n  context [#state(\"test_state\").get()]\n}\n</code></pre>\n<hr>\n<p>Why is the form you chose not working? Each time you <code>get()</code>, Typst has to access the state value, which depends on the current <code>context</code>. If you then use that value to <code>update()</code>, you’re actually invalidating <code>get()</code> calls that come later in the document. This leads to a cascade:</p>\n<ul>\n<li>Non-contextual parts of your document are evaluated: the state still has its initial values since all updates are contextual.</li>\n<li>All <code>get()</code>s in your document run and fetch the state value. Since the <code>update()</code>s are not applied yet all <code>get()</code> calls see the <em>initial</em> value.</li>\n<li>All <code>update()</code>s are inserted into the document, setting a value that is based on the <code>get()</code> result (the initial value).</li>\n<li>Typst sees that all <code>get()</code>s but the first used the wrong value (there’s a new update there) so the second and all following <code>context</code> blocks are reevaluated, using the value after the first update</li>\n<li>Typst sees that all <code>get()</code>s but the first and second used the wrong value so the third and all following <code>context</code> blocks are reevaluated, using the value after the second update.</li>\n<li>…</li>\n<li>After five updates, Typst gives up: the document did not “converge” in few enough attempts. The result of the <code>final()</code> call that you see is only based on the updates that were embedded into the document before then.</li>\n</ul>\n<p><code>update(x =&gt; ..)</code> circumvents the cascade and makes update values available immediately, which is why it makes the document converge!</p>",
      "raw": "If you look closely, you'll see that Typst is actually warning you about a problem with your document:\n\n> Layout did not converge within 5 attempts\n\nThis problem is hard to debug in general, but here the source of the problem is fairly easy to recognize and fix: your state updates are structured like\n```typc\ncontext {\n  x = foo.get()\n  ..\n  foo.update(x)\n}\n```\ninstead of the proper form:\n```typc\nfoo.update(x => {\n  ..\n  x\n})\n```\nThis uses the form of `update()` where you give it a function that computes the new value from the old one.\n\nThe [docs](https://typst.app/docs/reference/introspection/state/#state-in-typst) have the following example that matches your use case:\n```typ\n#let compute(expr) = [\n  #s.update(x =>\n    eval(expr.replace(\"x\", str(x)))\n  )\n  New value is #context s.get().\n]\n```\nhere there is first an `update` that uses a function, followed by a `context get()` that displays the new value.\n\nApplied to your use case, the code would look like this:\n```typ\n#let change_state(ref, num) = {\n  state(\"test_state\").update(ts => {\n    if ts.at(ref).at(2) != \"CHANGED\" {\n        ts.at(ref).at(num) = \"CHANGED\"\n    }\n    ts\n  })\n  context [#state(\"test_state\").get()]\n}\n```\n\n---\n\nWhy is the form you chose not working? Each time you `get()`, Typst has to access the state value, which depends on the current `context`. If you then use that value to `update()`, you're actually invalidating `get()` calls that come later in the document. This leads to a cascade:\n- Non-contextual parts of your document are evaluated: the state still has its initial values since all updates are contextual.\n- All `get()`s in your document run and fetch the state value. Since the `update()`s are not applied yet all `get()` calls see the _initial_ value.\n- All `update()`s are inserted into the document, setting a value that is based on the `get()` result (the initial value).\n- Typst sees that all `get()`s but the first used the wrong value (there's a new update there) so the second and all following `context` blocks are reevaluated, using the value after the first update\n- Typst sees that all `get()`s but the first and second used the wrong value so the third and all following `context` blocks are reevaluated, using the value after the second update.\n- ...\n- After five updates, Typst gives up: the document did not \"converge\" in few enough attempts. The result of the `final()` call that you see is only based on the updates that were embedded into the document before then.\n\n`update(x => ..)` circumvents the cascade and makes update values available immediately, which is why it makes the document converge!",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 1,
      "reads": 60,
      "score": 642.0,
      "accepted_answer": true,
      "trust_level": 3,
      "user_id": 32
    },
    {
      "id": 5019,
      "post_number": 3,
      "username": "Rogier",
      "name": "Rogier",
      "created_at": "2024-11-01T19:26:56.030Z",
      "updated_at": "2024-11-02T01:50:48.468Z",
      "cooked": "<p>Thanks, I think I understand what you’re doing and that does fix it. However now I have another problem that is probably adjacent.</p>\n<p>As I mentioned before I’m trying to build a reference doc generator. What I want to happen is that:</p>\n<ol>\n<li>A doc ref function is called.</li>\n<li>It evaluates the current Array of documents and sees if the document referred to already has a label attached (“DOC-NUMBER”)</li>\n<li>If not, increment the “document counter”. (which is a separate state) Set the label of this document to DOC-COUNTER</li>\n<li>In-text produce the document label. If it already existed in step 2, just give that one.</li>\n</ol>\n<p>For this I need to update a state “within” the state update. (Because the condition whether I need to update the counter is dependent on whether the label has already been changed.) So let’s say like this:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let change_state(ref, num) = {\n  state(\"test_state\").update(ts =&gt; {\n    if ts.at(ref).at(2) != \"CHANGED\" {\n        state(\"counter\").update(cnt =&gt; {cnt+1})\n        ts.at(ref).at(num) = \"CHANGED\"\n    }\n    ts\n  })\n  context [#state(\"test_state\").get()]\n}\n</code></pre>\n<p>But for some reason when I add the counter update line typst produces the error:</p>\n<p>“cannot join content with dictionary” on the “ts” return line. I personally don’t see how they’re related.</p>",
      "raw": "Thanks, I think I understand what you're doing and that does fix it. However now I have another problem that is probably adjacent.\n\nAs I mentioned before I'm trying to build a reference doc generator. What I want to happen is that:\n\n1. A doc ref function is called.\n2. It evaluates the current Array of documents and sees if the document referred to already has a label attached (\"DOC-NUMBER\")\n3. If not, increment the \"document counter\". (which is a separate state) Set the label of this document to DOC-COUNTER\n4. In-text produce the document label. If it already existed in step 2, just give that one.\n\nFor this I need to update a state \"within\" the state update. (Because the condition whether I need to update the counter is dependent on whether the label has already been changed.) So let's say like this:\n\n```typ\n#let change_state(ref, num) = {\n  state(\"test_state\").update(ts => {\n    if ts.at(ref).at(2) != \"CHANGED\" {\n        state(\"counter\").update(cnt => {cnt+1})\n        ts.at(ref).at(num) = \"CHANGED\"\n    }\n    ts\n  })\n  context [#state(\"test_state\").get()]\n}\n```\n\nBut for some reason when I add the counter update line typst produces the error:\n\n\"cannot join content with dictionary\" on the \"ts\" return line. I personally don't see how they're related.",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 0,
      "reads": 50,
      "score": 25.0,
      "accepted_answer": false,
      "trust_level": 1,
      "user_id": 263
    },
    {
      "id": 5135,
      "post_number": 4,
      "username": "SillyFreak",
      "name": "SillyFreak",
      "created_at": "2024-11-04T18:48:13.595Z",
      "updated_at": "2024-11-04T18:48:13.595Z",
      "cooked": "<aside class=\"quote no-group\" data-username=\"Rogier\" data-post=\"3\" data-topic=\"1483\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/letter_avatar_proxy/v4/letter/r/220F66/48.png\" class=\"avatar\"> Rogier:</div>\n<blockquote>\n<p>“cannot join content with dictionary”</p>\n</blockquote>\n</aside>\n<p>There’s some related discussion here:</p>\n<aside class=\"quote quote-modified\" data-post=\"3\" data-topic=\"778\">\n  <div class=\"title\">\n    <div class=\"quote-controls\"></div>\n    <img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/user_avatar/forum.typst.app/gabe/48/620_2.png\" class=\"avatar\">\n    <a href=\"https://forum.typst.app/t/can-i-attach-and-update-state-in-metadata/778/3\">Can I attach and update state in metadata?</a> <a class=\"badge-category__wrapper \" href=\"/c/questions/5\"><span data-category-id=\"5\" style=\"--category-badge-color: #F7C000; --category-badge-text-color: #fdfdfd;\" data-drop-close=\"true\" class=\"badge-category \" title=\"Your questions about using Typst and the web app go in this category.\"><span class=\"badge-category__name\">Questions</span></span></a>\n  </div>\n  <blockquote>\n    Thanks for taking the time to explain all the little details. \n#state(\"test\", 0).update(cs =&gt; cs += 1)\n// Wouldn't even make sense, because if we don't use a function we would do, for example:\n#state(\"test\", 0).update(1)\n\nIs the following description of states accurate? States themselves never change, but instead we put down markers (which live in the content) that are used to compute what the value of state at a given position should be. The markers that we put down only have the name of the st…\n  </blockquote>\n</aside>\n\n<p>The problem is that <code>update()</code> is a kind of content: it doesn’t modify the state directly, but inserts a command to do it into the document. I alluded to this by saying that “<code>update()</code>s are inserted into the document”.</p>\n<p>So since your outer update wants to return a <code>dict</code>, it struggles with combining that with the inner update (and even if it could, the inner update command would not be <em>part of the document</em> but somehow embedded in a state, which would mean it can’t act).</p>\n<p>A workaround – that probably brings you back to your old problem – would be to move the inner update out, where you’d have to use <code>context get()</code> to access the current state.</p>\n<p>The <em>proper</em> workaround would be to combine the two states. Instead of <code>test_state</code> having a dict and <code>counter</code> having a number, combine them into one state, e.g. <code>combined_state</code> with an initial value like <code>(test_state: (..), counter: 0)</code>. Then you can still access <code>context get().test_state</code> and don’t need an inner update to modify the counter.</p>",
      "raw": "[quote=\"Rogier, post:3, topic:1483\"]\n“cannot join content with dictionary”\n[/quote]\n\nThere's some related discussion here:\n\nhttps://forum.typst.app/t/can-i-attach-and-update-state-in-metadata/778/3?u=sillyfreak\n\nThe problem is that `update()` is a kind of content: it doesn't modify the state directly, but inserts a command to do it into the document. I alluded to this by saying that \"`update()`s are inserted into the document\".\n\nSo since your outer update wants to return a `dict`, it struggles with combining that with the inner update (and even if it could, the inner update command would not be _part of the document_ but somehow embedded in a state, which would mean it can't act).\n\nA workaround -- that probably brings you back to your old problem -- would be to move the inner update out, where you'd have to use `context get()` to access the current state.\n\nThe _proper_ workaround would be to combine the two states. Instead of `test_state` having a dict and `counter` having a number, combine them into one state, e.g. `combined_state` with an initial value like `(test_state: (..), counter: 0)`. Then you can still access `context get().test_state` and don't need an inner update to modify the counter.",
      "reply_to_post_number": 3,
      "reply_count": 1,
      "quote_count": 1,
      "like_count": 0,
      "reads": 37,
      "score": 22.4,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 32
    },
    {
      "id": 5488,
      "post_number": 5,
      "username": "Rogier",
      "name": "Rogier",
      "created_at": "2024-11-11T14:02:22.455Z",
      "updated_at": "2024-11-11T14:02:22.455Z",
      "cooked": "<p>Thanks, your suggestion is indeed what I ended up doing. I just added “counter” as a variable to my dict. I have run into this process a couple of times now, it is one of the parts of typst I like the least, but can’t quite put my finger on what would solve it. It’s just very unintuitive and I mostly end up trying a bunch of stuff until it looks like it’s working.</p>",
      "raw": "Thanks, your suggestion is indeed what I ended up doing. I just added \"counter\" as a variable to my dict. I have run into this process a couple of times now, it is one of the parts of typst I like the least, but can't quite put my finger on what would solve it. It's just very unintuitive and I mostly end up trying a bunch of stuff until it looks like it's working.",
      "reply_to_post_number": 4,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 0,
      "reads": 30,
      "score": 11.0,
      "accepted_answer": false,
      "trust_level": 1,
      "user_id": 263
    },
    {
      "id": 5495,
      "post_number": 6,
      "username": "SillyFreak",
      "name": "SillyFreak",
      "created_at": "2024-11-11T16:14:16.819Z",
      "updated_at": "2024-11-11T16:14:16.819Z",
      "cooked": "<p>If it’s any consolation (probably not <img src=\"https://forum.typst.app/images/emoji/apple/stuck_out_tongue.png?v=12\" title=\":stuck_out_tongue:\" class=\"emoji\" alt=\":stuck_out_tongue:\" loading=\"lazy\" width=\"20\" height=\"20\">), let me tell you that this kind of state management is kinda similar to many web frontend frameworks, like React, and many programmers struggle with it or find it ultimately unsatisfying. I guess that means Typst has some prior art it can look at to improve (although overall I think it actually works relatively nicely in Typst), but the prior art is also not perfect… it’s a hard topic, and finding it unintuitive is definitely not on you <img src=\"https://forum.typst.app/images/emoji/apple/slight_smile.png?v=12\" title=\":slight_smile:\" class=\"emoji\" alt=\":slight_smile:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>",
      "raw": "If it's any consolation (probably not :stuck_out_tongue:), let me tell you that this kind of state management is kinda similar to many web frontend frameworks, like React, and many programmers struggle with it or find it ultimately unsatisfying. I guess that means Typst has some prior art it can look at to improve (although overall I think it actually works relatively nicely in Typst), but the prior art is also not perfect... it's a hard topic, and finding it unintuitive is definitely not on you :slight_smile:",
      "reply_to_post_number": 5,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 28,
      "score": 5.6,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 32
    }
  ],
  "scraped_at": "2025-06-10T09:55:38.982402"
}