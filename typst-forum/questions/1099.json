{
  "topic_metadata": {
    "id": 1099,
    "title": "How can I manipulate content values?",
    "slug": "how-can-i-manipulate-content-values",
    "posts_count": 4,
    "created_at": "2024-10-14T13:53:51.624Z",
    "last_posted_at": "2025-03-13T12:40:30.934Z",
    "views": 682,
    "like_count": 2,
    "reply_count": 3,
    "has_accepted_answer": true,
    "accepted_answer_post_number": 2,
    "accepted_answer_username": "SillyFreak",
    "tags": [
      "scripting"
    ],
    "category_id": 5,
    "participant_count": 3,
    "word_count": 784
  },
  "posts": [
    {
      "id": 3894,
      "post_number": 1,
      "username": "SolidTux",
      "name": "Daniel Hauck",
      "created_at": "2024-10-14T13:53:51.721Z",
      "updated_at": "2024-10-14T15:05:34.852Z",
      "cooked": "<p>Currently, manipulating content is very involved. This is mainly caused by the content functions</p>\n<ul>\n<li>taking different amount of positional arguments</li>\n<li><code>fields()</code> not distinguishing between positional and keyword arguments</li>\n<li>not all content functions being accessible (e.g. <code>sequence</code> can as far as I know only obtained by hacks like <code>[].func()</code>)</li>\n</ul>\n<p>For example, I’d like to recursively update all strings in a content, which currently requires a lot of special casing and hard to know if you caught all edge cases. This leads to code like this</p>\n<pre data-code-wrap=\"typst\"><code class=\"lang-typst\">#let titlecase(data) = {\n  let update-dict(dict) = {\n    let new-dict = (:)\n    for (k, v) in dict.pairs() {\n      new-dict.insert(k, titlecase(v))\n    }\n    return new-dict\n  }\n\n  if type(data) == content {\n    if data.has(\"children\") {\n      let new-fields = data.fields()\n      new-fields.remove(\"children\")\n      let new-children = data.children.map(titlecase)\n      return data.func()(new-children, ..update-dict(new-fields))\n    }\n    if data.has(\"body\") {\n      let new-body = titlecase(data.body)\n      let new-fields = data.fields()\n      new-fields.remove(\"body\")\n      return data.func()(new-body, ..update-dict(new-fields))\n    }\n    if data.has(\"text\") {\n      let new-text = titlecase(data.text)\n      let new-fields = data.fields()\n      new-fields.remove(\"text\")\n      return data.func()(new-text, ..update-dict(new-fields))\n    }\n    if data.has(\"base\") {\n      let new-base = titlecase(data.base)\n      let new-fields = data.fields()\n      new-fields.remove(\"base\")\n      return data.func()(new-base, ..update-dict(new-fields))\n    }\n    // styled\n    if data.has(\"child\") {\n      let new-child = titlecase(data.child)\n      let new-fields = data.fields()\n      new-fields.remove(\"child\")\n      let _ = new-fields.remove(\"styles\")\n      return data.func()(new-child, data.styles, ..update-dict(new-fields))\n    }\n    let new-fields = data.fields()\n    return data.func()(..update-dict(new-fields))\n    return data\n  }\n  if type(data) == str {\n    str(_plugin.titlecase(bytes(data)))\n  } else {\n    data\n  }\n}\n</code></pre>\n<p>Am I overlooking something that would make this easier? Otherwise, it would be already much more straightforward if <code>content</code> had an <code>arguments()</code> function, that returns an <code>arguments</code> object. That would at least allow an easier reconstruction of the content.</p>",
      "raw": "Currently, manipulating content is very involved. This is mainly caused by the content functions\n\n* taking different amount of positional arguments\n* `fields()` not distinguishing between positional and keyword arguments\n* not all content functions being accessible (e.g. `sequence` can as far as I know only obtained by hacks like `[].func()`)\n\nFor example, I'd like to recursively update all strings in a content, which currently requires a lot of special casing and hard to know if you caught all edge cases. This leads to code like this\n\n```typst\n#let titlecase(data) = {\n  let update-dict(dict) = {\n    let new-dict = (:)\n    for (k, v) in dict.pairs() {\n      new-dict.insert(k, titlecase(v))\n    }\n    return new-dict\n  }\n\n  if type(data) == content {\n    if data.has(\"children\") {\n      let new-fields = data.fields()\n      new-fields.remove(\"children\")\n      let new-children = data.children.map(titlecase)\n      return data.func()(new-children, ..update-dict(new-fields))\n    }\n    if data.has(\"body\") {\n      let new-body = titlecase(data.body)\n      let new-fields = data.fields()\n      new-fields.remove(\"body\")\n      return data.func()(new-body, ..update-dict(new-fields))\n    }\n    if data.has(\"text\") {\n      let new-text = titlecase(data.text)\n      let new-fields = data.fields()\n      new-fields.remove(\"text\")\n      return data.func()(new-text, ..update-dict(new-fields))\n    }\n    if data.has(\"base\") {\n      let new-base = titlecase(data.base)\n      let new-fields = data.fields()\n      new-fields.remove(\"base\")\n      return data.func()(new-base, ..update-dict(new-fields))\n    }\n    // styled\n    if data.has(\"child\") {\n      let new-child = titlecase(data.child)\n      let new-fields = data.fields()\n      new-fields.remove(\"child\")\n      let _ = new-fields.remove(\"styles\")\n      return data.func()(new-child, data.styles, ..update-dict(new-fields))\n    }\n    let new-fields = data.fields()\n    return data.func()(..update-dict(new-fields))\n    return data\n  }\n  if type(data) == str {\n    str(_plugin.titlecase(bytes(data)))\n  } else {\n    data\n  }\n}\n```\n\nAm I overlooking something that would make this easier? Otherwise, it would be already much more straightforward if `content` had an `arguments()` function, that returns an `arguments` object. That would at least allow an easier reconstruction of the content.",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 70,
      "score": 2834.0,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 572
    },
    {
      "id": 3900,
      "post_number": 2,
      "username": "SillyFreak",
      "name": "SillyFreak",
      "created_at": "2024-10-14T14:57:00.158Z",
      "updated_at": "2024-10-14T15:08:23.103Z",
      "cooked": "<p>Content is not really meant to be manipulated, usually the better way is to only create content from data that has already been processed in any way necessary. This is often the right advice for e.g. <a href=\"https://forum.typst.app/t/how-to-sum-column-values-in-a-table/937/2\">tables</a> – however, it is not really applicable to your use case because the data you have is fundamentally already formatted text.</p>\n<p>The next best way, though, is not manipulating the full hierarchy of the content value you’re dealing with, but applying a rule. Your specific case can be handled by this code:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#show regex(\"\\b\\w+\\b\"): word =&gt; {\n  let (first, ..rest) = word.text.clusters()\n  first = upper(first)\n  (first, ..rest).join()\n  // or instead:\n  // str(_plugin.titlecase(bytes(word.text)))\n}\n\nsome *important* text\n</code></pre>\n<p>The general principle here is: access deeply nested data using Typst’s tools (show and set rules), not by inspecting values.</p>\n<p>In cases where even that doesn’t work, the approach you have is the one you need to go with. If that wasn’t already where you got your inspiration, there’s <a href=\"https://sitandr.github.io/typst-examples-book/book/typstonomicon/extract_plain_text.html\">this example</a> in the Typst examples book. You can still make your life a bit easier compared to the code you wrote, here’s an excerpt:</p>\n<pre data-code-wrap=\"typc\"><code class=\"lang-typc\">let update-dict(dict) = {\n  for (k, v) in dict { ((k): titlecase(v)) }\n  // or this:\n  // dict.pairs().map(((k, v)) =&gt; ((k): titlecase(v))).join()\n}\n\n// ...\n\n  if data.has(\"children\") {\n    let (children, ..fields) = data.fields()\n    children = children.map(titlecase)\n    fields = update-dict(fields)\n    return data.func()(children, ..fields)\n  }\n  if data.has(\"body\") {\n    let (body, ..fields) = data.fields()\n    body = titlecase(body)\n    fields = update-dict(fields)\n    return data.func()(body, ..fields)\n  }\n</code></pre>\n<p>One part that you probably missed is how to use variables as dictionary keys; see <a href=\"https://forum.typst.app/t/how-can-i-instantiate-a-dictionary-with-a-variable-key-name/652\" class=\"inline-onebox\">How can I instantiate a dictionary with a variable key name?</a></p>",
      "raw": "Content is not really meant to be manipulated, usually the better way is to only create content from data that has already been processed in any way necessary. This is often the right advice for e.g. [tables](https://forum.typst.app/t/how-to-sum-column-values-in-a-table/937/2) -- however, it is not really applicable to your use case because the data you have is fundamentally already formatted text.\n\nThe next best way, though, is not manipulating the full hierarchy of the content value you're dealing with, but applying a rule. Your specific case can be handled by this code:\n```typ\n#show regex(\"\\b\\w+\\b\"): word => {\n  let (first, ..rest) = word.text.clusters()\n  first = upper(first)\n  (first, ..rest).join()\n  // or instead:\n  // str(_plugin.titlecase(bytes(word.text)))\n}\n\nsome *important* text\n```\nThe general principle here is: access deeply nested data using Typst's tools (show and set rules), not by inspecting values.\n\nIn cases where even that doesn't work, the approach you have is the one you need to go with. If that wasn't already where you got your inspiration, there's [this example](https://sitandr.github.io/typst-examples-book/book/typstonomicon/extract_plain_text.html) in the Typst examples book. You can still make your life a bit easier compared to the code you wrote, here's an excerpt:\n```typc\nlet update-dict(dict) = {\n  for (k, v) in dict { ((k): titlecase(v)) }\n  // or this:\n  // dict.pairs().map(((k, v)) => ((k): titlecase(v))).join()\n}\n\n// ...\n\n  if data.has(\"children\") {\n    let (children, ..fields) = data.fields()\n    children = children.map(titlecase)\n    fields = update-dict(fields)\n    return data.func()(children, ..fields)\n  }\n  if data.has(\"body\") {\n    let (body, ..fields) = data.fields()\n    body = titlecase(body)\n    fields = update-dict(fields)\n    return data.func()(body, ..fields)\n  }\n```\nOne part that you probably missed is how to use variables as dictionary keys; see https://forum.typst.app/t/how-can-i-instantiate-a-dictionary-with-a-variable-key-name/652",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 1,
      "reads": 64,
      "score": 197.8,
      "accepted_answer": true,
      "trust_level": 3,
      "user_id": 32
    },
    {
      "id": 3904,
      "post_number": 4,
      "username": "SolidTux",
      "name": "Daniel Hauck",
      "created_at": "2024-10-14T15:03:44.002Z",
      "updated_at": "2024-10-14T15:03:44.002Z",
      "cooked": "<p>That helps a bit, especially the regex part, thank you! Also, the pattern deconstruction of dictionaries seems useful as well.</p>\n<p>I still think that an <code>arguments()</code> function would be more logical than <code>fields()</code> for some use cases.</p>",
      "raw": "That helps a bit, especially the regex part, thank you! Also, the pattern deconstruction of dictionaries seems useful as well.\n\nI still think that an `arguments()` function would be more logical than `fields()` for some use cases.",
      "reply_to_post_number": 2,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 1,
      "reads": 60,
      "score": 72.0,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 572
    },
    {
      "id": 9755,
      "post_number": 7,
      "username": "alerque",
      "name": "Caleb Maclennan",
      "created_at": "2025-03-13T12:40:30.934Z",
      "updated_at": "2025-03-13T12:40:30.934Z",
      "cooked": "<p>If all you are trying to do is transform some content to title case, you might have an easier time using my <a href=\"https://typst.app/universe/package/decasify\">decasify</a> package.</p>\n<p>It does handle nested content (e.g. with styled segments) but there is currently a <a href=\"https://github.com/alerque/decasify/issues/38\" rel=\"noopener nofollow ugc\">known limitation</a> where all language rules are applied <em>per segment</em>. I’d like to get that fixed too if anybody knows how. but for most use cases (e.g. changing the case of titles or ether fields) it works pretty well.</p>",
      "raw": "If all you are trying to do is transform some content to title case, you might have an easier time using my [decasify](https://typst.app/universe/package/decasify) package.\n\nIt does handle nested content (e.g. with styled segments) but there is currently a [known limitation](https://github.com/alerque/decasify/issues/38) where all language rules are applied *per segment*. I'd like to get that fixed too if anybody knows how. but for most use cases (e.g. changing the case of titles or ether fields) it works pretty well.",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 32,
      "score": 21.4,
      "accepted_answer": false,
      "trust_level": 0,
      "user_id": 219
    }
  ],
  "scraped_at": "2025-06-10T09:56:53.563735"
}