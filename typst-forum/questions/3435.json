{
  "topic_metadata": {
    "id": 3435,
    "title": "How to format linguistic example lists?",
    "slug": "how-to-format-linguistic-example-lists",
    "posts_count": 8,
    "created_at": "2025-03-28T07:21:37.483Z",
    "last_posted_at": "2025-04-23T21:58:01.745Z",
    "views": 164,
    "like_count": 3,
    "reply_count": 3,
    "has_accepted_answer": true,
    "accepted_answer_post_number": 2,
    "accepted_answer_username": "quachpas",
    "tags": [
      "scripting"
    ],
    "category_id": 5,
    "participant_count": 7,
    "word_count": 1649
  },
  "posts": [
    {
      "id": 10348,
      "post_number": 1,
      "username": "dj1121",
      "name": "",
      "created_at": "2025-03-28T07:21:37.637Z",
      "updated_at": "2025-04-18T12:52:23.441Z",
      "cooked": "<p>Hi all,</p>\n<p>I am a linguist, and I would like to use Typst to make linguistic example lists. An example is just a 3-tuple with sentence, gloss, and translation values. Often, it can also just be a single “sentence” value if it’s English. Printing this via a grid is simple enough:</p>\n<p><img src=\"https://forum.typst.app/uploads/default/original/2X/8/8c7cedcafad4b424d9028df2e43f28ba6b80daa4.png\" alt=\"2025-03-28_16-00\" data-base62-sha1=\"k2Ovigc3L3fGAhHqhUYSi66SSXi\" width=\"373\" height=\"68\"></p>\n<p>In linguistics papers, these sorts of examples can be arbitrarily nested. For example, we could refer to examples below as 1a), 2b.i), 3), etc.</p>\n<pre data-code-wrap=\"txt\"><code class=\"lang-txt\">1) a.  [SENTENCE]\n       [GLOSS]\n       [TRANSLATION]\n   b. ...\n   c. ...\n\n2) a. ...\n   b.\n       i. [SENTENCE]\n          [GLOSS]\n          [TRANSLATION]\n       ii. ... \n       iii. ...\n\n3) [SENTENCE]\n   [GLOSS]\n   [TRANSLATION]\n</code></pre>\n<p><strong>As you might expect, I don’t want to type these out manually every time I write an example. I want to make a function that can print the formatting from an arbitrarily nested list of examples, like the list below:</strong></p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let xlist = (\n// Top-level \"1)\" \n (\n     // 1a\n      (sentence: [this is sentence],\n      gloss: [This is the gloss],\n      tran: [this is tran]\n      )\n\n   // 1b\n      (sentence: [this is sentence],\n      gloss: [This is the gloss],\n      tran: [this is tran]\n     )\n\n),\n// Top-level \"2)\"\n( \n  // 2a\n  (sentence: [this is sentence],\n   gloss: [this is gloss],\n   tran: [this is tran],\n   )\n)\n</code></pre>\n<p>I figured this could be accomplished with grid(), but I am lost on how to dynamically allocate grids. I thought about looping over the examples, nesting grid() calls, but I quickly became stuck. I know that each level of the list should have 2 columns (one for label, one for content). Then, the number of rows should depend on how what’s inside the current level of the list.</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">// Pass in list of examples\n#let ex(examples) = {\n  \n  grid(\n      columns: 2, // two top main cols\n      rows: examples.len(), // number of top-levels (i.e., 1, 2, 3)\n      column-gutter: 1em,\n      row-gutter: 1em,\n\n      for example in examples {\n\n            // ??\n         \n        }        \n  )\n</code></pre>\n<p>I’m having the feeling it might be good to use a recursive solution, but I am new to Typst, and thought I should ask for some guidance before I go too far in that direction. Does anyone have guidance as to how to make such a function, or if another solution would be better? Any help would be much appreciated! Thank you.</p>",
      "raw": "Hi all,\n\nI am a linguist, and I would like to use Typst to make linguistic example lists. An example is just a 3-tuple with sentence, gloss, and translation values. Often, it can also just be a single \"sentence\" value if it's English. Printing this via a grid is simple enough:\n\n![2025-03-28_16-00|498x91, 75%](upload://k2Ovigc3L3fGAhHqhUYSi66SSXi.png)\n\nIn linguistics papers, these sorts of examples can be arbitrarily nested. For example, we could refer to examples below as 1a), 2b.i), 3), etc.\n\n```txt\n1) a.  [SENTENCE]\n       [GLOSS]\n       [TRANSLATION]\n   b. ...\n   c. ...\n\n2) a. ...\n   b.\n       i. [SENTENCE]\n          [GLOSS]\n          [TRANSLATION]\n       ii. ... \n       iii. ...\n\n3) [SENTENCE]\n   [GLOSS]\n   [TRANSLATION]\n```\n**As you might expect, I don't want to type these out manually every time I write an example. I want to make a function that can print the formatting from an arbitrarily nested list of examples, like the list below:**\n\n```typ\n#let xlist = (\n// Top-level \"1)\" \n (\n     // 1a\n      (sentence: [this is sentence],\n      gloss: [This is the gloss],\n      tran: [this is tran]\n      )\n\n   // 1b\n      (sentence: [this is sentence],\n      gloss: [This is the gloss],\n      tran: [this is tran]\n     )\n\n),\n// Top-level \"2)\"\n( \n  // 2a\n  (sentence: [this is sentence],\n   gloss: [this is gloss],\n   tran: [this is tran],\n   )\n)\n```\n\nI figured this could be accomplished with grid(), but I am lost on how to dynamically allocate grids. I thought about looping over the examples, nesting grid() calls, but I quickly became stuck. I know that each level of the list should have 2 columns (one for label, one for content). Then, the number of rows should depend on how what's inside the current level of the list.\n\n```typ\n// Pass in list of examples\n#let ex(examples) = {\n  \n  grid(\n      columns: 2, // two top main cols\n      rows: examples.len(), // number of top-levels (i.e., 1, 2, 3)\n      column-gutter: 1em,\n      row-gutter: 1em,\n\n      for example in examples {\n\n            // ??\n         \n        }        \n  )\n```\n\nI'm having the feeling it might be good to use a recursive solution, but I am new to Typst, and thought I should ask for some guidance before I go too far in that direction. Does anyone have guidance as to how to make such a function, or if another solution would be better? Any help would be much appreciated! Thank you.",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 0,
      "reads": 45,
      "score": 134.0,
      "accepted_answer": false,
      "trust_level": 1,
      "user_id": 1397
    },
    {
      "id": 10350,
      "post_number": 2,
      "username": "quachpas",
      "name": "Pascal Quach",
      "created_at": "2025-03-28T08:23:26.837Z",
      "updated_at": "2025-03-28T08:27:09.742Z",
      "cooked": "<p>Something like this maybe? Credits goes to <a class=\"mention\" href=\"/u/eric\">@Eric</a> for <code>to-enum</code>.</p>\n<p><code>enum</code> and <code>list</code> need to be built recursively with the previous input, hence we use <a href=\"https://typst.app/docs/reference/foundations/array/#definitions-fold\"><code>array.fold</code></a>, otherwise numbers won’t follow.</p>\n<p>I have split the formatting and display into separate functions, but it’s honestly possible to just merge both.</p>\n<p>The numbering is set to using a <code>set rule</code>: <code>set enum(numbering: \"1.a.i)\")</code>.</p>\n<aside class=\"quote no-group\" data-username=\"dj1121\" data-post=\"1\" data-topic=\"3435\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/letter_avatar_proxy/v4/letter/d/145B49/48.png\" class=\"avatar\"> dj1121:</div>\n<blockquote>\n<p>For example, we could refer to examples below as 1a), 2b.i), 3), etc.</p>\n</blockquote>\n</aside>\n<p>As for referencing an <code>enum.item</code>, that’s still <a href=\"https://github.com/typst/typst/issues/779\">work in progress</a>. Maybe, that’s better answered in another topic. It is absolutely doable, with a mix of <code>metadata</code> and a custom ref system.</p>\n<details>\n<summary>\nSummary</summary>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let xlist = (\n  (\n    // 1a\n    (\n      sentence: [this is sentence 1 (1a)],\n      gloss: [This is the gloss],\n      tran: [this is tran],\n    ),\n    // 1b\n    (\n      sentence: [this is sentence 2 (1b)],\n      gloss: [This is the gloss],\n      tran: [this is tran],\n    ),\n  ),\n  (\n    // 2a\n    (\n      sentence: [this is sentence 3 (2a)],\n      gloss: [this is gloss],\n      tran: [this is tran],\n    )\n  ),\n  (\n    (\n      (\n        // 3a i\n        sentence: [this is sentence (3a i)],\n        gloss: [this is gloss],\n        tran: [this is tran],\n      ),\n      (\n        // 3a ii\n        sentence: [this is sentence (3a ii)],\n        gloss: [this is gloss],\n        tran: [this is tran],\n      ),\n    ),\n  ),\n)\n#let format(xlist, level: 0) = {\n  // set enum(numbering: \"1.a.i)\")\n  if type(xlist) == dictionary {\n    xlist.values().map(smallcaps).join(\"\\n\")\n  } else if type(xlist) == array {\n    for example in xlist {\n      let body = format(example, level: level + 1)\n      (body,)\n    }\n  }\n}\n#let to-enum(arr) = {\n  set enum(numbering: \"1.a.i)\")\n  arr\n    .fold(\n      (),\n      (items, curr) =&gt; {\n        // If the current entry is an array, append a new subenum to\n        // the last item. Otherwise, create a new enum item.\n        if type(curr) == array { items += (to-enum(curr),) } else {\n          items.push(curr)\n        }\n        items\n      },\n    )\n    .map(enum.item)\n    .join()\n}\n\n#to-enum(format(xlist))\n</code></pre>\n</details>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://forum.typst.app/uploads/default/original/2X/9/9fe76365456363eaad327dc5acab6f99f6e0b22b.png\" data-download-href=\"https://forum.typst.app/uploads/default/9fe76365456363eaad327dc5acab6f99f6e0b22b\" title=\"image\"><img src=\"https://forum.typst.app/uploads/default/optimized/2X/9/9fe76365456363eaad327dc5acab6f99f6e0b22b_2_345x500.png\" alt=\"image\" data-base62-sha1=\"mOzFdLiZu2q4XJRWN1eOTwcA7Qn\" width=\"345\" height=\"500\" srcset=\"https://forum.typst.app/uploads/default/optimized/2X/9/9fe76365456363eaad327dc5acab6f99f6e0b22b_2_345x500.png, https://forum.typst.app/uploads/default/original/2X/9/9fe76365456363eaad327dc5acab6f99f6e0b22b.png 1.5x, https://forum.typst.app/uploads/default/original/2X/9/9fe76365456363eaad327dc5acab6f99f6e0b22b.png 2x\" data-dominant-color=\"F0F0F0\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">image</span><span class=\"informations\">397×575 46.4 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>",
      "raw": "Something like this maybe? Credits goes to @Eric for `to-enum`.\n\n`enum` and `list` need to be built recursively with the previous input, hence we use [`array.fold`](https://typst.app/docs/reference/foundations/array/#definitions-fold), otherwise numbers won't follow.\n\nI have split the formatting and display into separate functions, but it's honestly possible to just merge both.\n\nThe numbering is set to using a `set rule`: `set enum(numbering: \"1.a.i)\")`.\n\n[quote=\"dj1121, post:1, topic:3435\"]\nFor example, we could refer to examples below as 1a), 2b.i), 3), etc.\n[/quote]\n\nAs for referencing an `enum.item`, that's still [work in progress](https://github.com/typst/typst/issues/779). Maybe, that's better answered in another topic. It is absolutely doable, with a mix of `metadata` and a custom ref system.\n\n[details=\"Summary\"]\n```typ\n#let xlist = (\n  (\n    // 1a\n    (\n      sentence: [this is sentence 1 (1a)],\n      gloss: [This is the gloss],\n      tran: [this is tran],\n    ),\n    // 1b\n    (\n      sentence: [this is sentence 2 (1b)],\n      gloss: [This is the gloss],\n      tran: [this is tran],\n    ),\n  ),\n  (\n    // 2a\n    (\n      sentence: [this is sentence 3 (2a)],\n      gloss: [this is gloss],\n      tran: [this is tran],\n    )\n  ),\n  (\n    (\n      (\n        // 3a i\n        sentence: [this is sentence (3a i)],\n        gloss: [this is gloss],\n        tran: [this is tran],\n      ),\n      (\n        // 3a ii\n        sentence: [this is sentence (3a ii)],\n        gloss: [this is gloss],\n        tran: [this is tran],\n      ),\n    ),\n  ),\n)\n#let format(xlist, level: 0) = {\n  // set enum(numbering: \"1.a.i)\")\n  if type(xlist) == dictionary {\n    xlist.values().map(smallcaps).join(\"\\n\")\n  } else if type(xlist) == array {\n    for example in xlist {\n      let body = format(example, level: level + 1)\n      (body,)\n    }\n  }\n}\n#let to-enum(arr) = {\n  set enum(numbering: \"1.a.i)\")\n  arr\n    .fold(\n      (),\n      (items, curr) => {\n        // If the current entry is an array, append a new subenum to\n        // the last item. Otherwise, create a new enum item.\n        if type(curr) == array { items += (to-enum(curr),) } else {\n          items.push(curr)\n        }\n        items\n      },\n    )\n    .map(enum.item)\n    .join()\n}\n\n#to-enum(format(xlist))\n```\n[/details]\n\n![image|345x500](upload://mOzFdLiZu2q4XJRWN1eOTwcA7Qn.png)",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 1,
      "like_count": 2,
      "reads": 41,
      "score": 43.2,
      "accepted_answer": true,
      "trust_level": 3,
      "user_id": 258
    },
    {
      "id": 10357,
      "post_number": 3,
      "username": "Andrew",
      "name": "",
      "created_at": "2025-03-28T11:56:43.031Z",
      "updated_at": "2025-03-31T19:38:29.385Z",
      "cooked": "<p>Here you go (-12 lines):</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let format(xlist, level: 0) = {\n  if type(xlist) == dictionary {\n    xlist.values().map(smallcaps).join(\"\\n\")\n  } else if type(xlist) == array {\n    xlist.map(example =&gt; (format(example, level: level + 1),)).join()\n  }\n}\n\n#let to-enum(arr) = {\n  set enum(numbering: \"1.a.i)\")\n  let fold-func = (items, curr) =&gt; {\n    // If the current entry is an array, append a new subenum to\n    // the last item. Otherwise, create a new enum item.\n    items + (if type(curr) == array { to-enum(curr) } else { curr },)\n  }\n  arr.fold((), fold-func).map(enum.item).join()\n}\n</code></pre>\n<br>\n<details><summary>Full example</summary>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let format(xlist, level: 0) = {\n  if type(xlist) == dictionary {\n    xlist.values().map(smallcaps).join(\"\\n\")\n  } else if type(xlist) == array {\n    xlist.map(example =&gt; (format(example, level: level + 1),)).join()\n  }\n}\n\n#let to-enum(arr) = {\n  set enum(numbering: \"1.a.i)\")\n  let fold-func = (items, curr) =&gt; {\n    // If the current entry is an array, append a new subenum to\n    // the last item. Otherwise, create a new enum item.\n    items + (if type(curr) == array { to-enum(curr) } else { curr },)\n  }\n  arr.fold((), fold-func).map(enum.item).join()\n}\n\n#let xlist = (\n  (\n    // Top-level \"1)\"\n    (\n      // 1a\n      sentence: [Der Hund bellt.],\n      gloss: [DEF.MASC.SG.NOM Hund bell-3SG.PRES],\n      tran: [The dog barks.],\n    ),\n    (\n      // 1b\n      sentence: [Die Katze schläft.],\n      gloss: [DEF.FEM.SG.NOM Katze schlaf-3SG.PRES],\n      tran: [The cat sleeps.],\n    ),\n  ),\n  (\n    // Top-level \"2)\"\n    (\n      // 2a\n      sentence: [Wir gehen ins Kino.],\n      gloss: [1PL.NOM geh-1PL.PRES in+das.ACC Kino],\n      tran: [We are going to the cinema.],\n    )\n  ),\n  (\n    // Top-level \"3)\"\n    (\n      // 3a\n      (\n        // 3a i\n        sentence: [Ich habe ein Buch gelesen.],\n        gloss: [1SG.NOM hab-1SG.PRES ein.ACC Buch les-PART.PST],\n        tran: [I have read a book.],\n      ),\n      (\n        // 3a ii\n        sentence: [Sie wird morgen ankommen.],\n        gloss: [3SG.FEM.NOM werd-3SG.PRES morgen an-komm-INF],\n        tran: [She will arrive tomorrow.],\n      ),\n    ),\n  ),\n)\n\n#to-enum(format(xlist))\n</code></pre>\n<p><img src=\"https://forum.typst.app/uploads/default/original/2X/0/04825dafe8807395561ef6b50db2a38cd4dd1dc5.png\" alt=\"image\" data-base62-sha1=\"DTduJVBObjQ3wAgZIYSoHIfBCl\" width=\"507\" height=\"386\"></p>\n</details>\n<hr>\n<p>For numbering patterns with different ending markers for different levels, see <a href=\"https://github.com/typst/typst/issues/6088\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Numbering patterns for nested lists is used incorrectly by the compiler · Issue #6088 · typst/typst · GitHub</a></p>\n<aside class=\"onebox githubissue\" data-onebox-src=\"https://github.com/typst/typst/issues/905\">\n  <header class=\"source\">\n\n      <a href=\"https://github.com/typst/typst/issues/905\" target=\"_blank\" rel=\"noopener nofollow ugc\">github.com/typst/typst</a>\n  </header>\n\n  <article class=\"onebox-body\">\n    <div class=\"github-row\">\n  <div class=\"github-icon-container\" title=\"Issue\" data-github-private-repo=\"false\">\n\t  <svg width=\"60\" height=\"60\" class=\"github-icon\" viewBox=\"0 0 14 16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z\"></path></svg>\n  </div>\n\n  <div class=\"github-info-container\">\n    <h4>\n      <a href=\"https://github.com/typst/typst/issues/905\" target=\"_blank\" rel=\"noopener nofollow ugc\">More flexible separators in numbering patterns</a>\n    </h4>\n\n    <div class=\"github-info\">\n      <div class=\"date\">\n        opened <span class=\"discourse-local-date\" data-format=\"ll\" data-date=\"2023-04-21\" data-time=\"01:07:09\" data-timezone=\"UTC\">01:07AM - 21 Apr 23 UTC</span>\n      </div>\n\n\n      <div class=\"user\">\n        <a href=\"https://github.com/ParadaCarleton\" target=\"_blank\" rel=\"noopener nofollow ugc\">\n          <img alt=\"ParadaCarleton\" src=\"https://forum.typst.app/uploads/default/original/2X/8/8ce7103d4d76700bfdd2e2c2aa685aa6d61ff14f.png\" class=\"onebox-avatar-inline\" width=\"20\" height=\"20\" data-dominant-color=\"DEC7E3\">\n          ParadaCarleton\n        </a>\n      </div>\n    </div>\n\n    <div class=\"labels\">\n        <span style=\"display:inline-block;margin-top:2px;background-color: #B8B8B8;padding: 2px;border-radius: 4px;color: #fff;margin-left: 3px;\">\n          feature request\n        </span>\n        <span style=\"display:inline-block;margin-top:2px;background-color: #B8B8B8;padding: 2px;border-radius: 4px;color: #fff;margin-left: 3px;\">\n          scripting\n        </span>\n    </div>\n  </div>\n</div>\n\n  <div class=\"github-row\">\n    <p class=\"github-body-container\">I can't get the numbering to look how I want:\n```\n#set enum(numbering: \"1.a)\")<span class=\"show-more-container\"><a href=\"\" rel=\"noopener\" class=\"show-more\">…</a></span><span class=\"excerpt hidden\">\n```\n![image](https://user-images.githubusercontent.com/71727937/233517079-dd932872-e331-41ad-b2a1-e524fe2d1ea2.png)\nI expected this to give \"1.\" and \"a)\".</span></p>\n  </div>\n\n  </article>\n\n  <div class=\"onebox-metadata\">\n    \n    \n  </div>\n\n  <div style=\"clear: both\"></div>\n</aside>\n",
      "raw": "Here you go (-12 lines):\n\n```typ\n#let format(xlist, level: 0) = {\n  if type(xlist) == dictionary {\n    xlist.values().map(smallcaps).join(\"\\n\")\n  } else if type(xlist) == array {\n    xlist.map(example => (format(example, level: level + 1),)).join()\n  }\n}\n\n#let to-enum(arr) = {\n  set enum(numbering: \"1.a.i)\")\n  let fold-func = (items, curr) => {\n    // If the current entry is an array, append a new subenum to\n    // the last item. Otherwise, create a new enum item.\n    items + (if type(curr) == array { to-enum(curr) } else { curr },)\n  }\n  arr.fold((), fold-func).map(enum.item).join()\n}\n```\n\n<br>\n\n<details><summary>Full example</summary>\n\n```typ\n#let format(xlist, level: 0) = {\n  if type(xlist) == dictionary {\n    xlist.values().map(smallcaps).join(\"\\n\")\n  } else if type(xlist) == array {\n    xlist.map(example => (format(example, level: level + 1),)).join()\n  }\n}\n\n#let to-enum(arr) = {\n  set enum(numbering: \"1.a.i)\")\n  let fold-func = (items, curr) => {\n    // If the current entry is an array, append a new subenum to\n    // the last item. Otherwise, create a new enum item.\n    items + (if type(curr) == array { to-enum(curr) } else { curr },)\n  }\n  arr.fold((), fold-func).map(enum.item).join()\n}\n\n#let xlist = (\n  (\n    // Top-level \"1)\"\n    (\n      // 1a\n      sentence: [Der Hund bellt.],\n      gloss: [DEF.MASC.SG.NOM Hund bell-3SG.PRES],\n      tran: [The dog barks.],\n    ),\n    (\n      // 1b\n      sentence: [Die Katze schläft.],\n      gloss: [DEF.FEM.SG.NOM Katze schlaf-3SG.PRES],\n      tran: [The cat sleeps.],\n    ),\n  ),\n  (\n    // Top-level \"2)\"\n    (\n      // 2a\n      sentence: [Wir gehen ins Kino.],\n      gloss: [1PL.NOM geh-1PL.PRES in+das.ACC Kino],\n      tran: [We are going to the cinema.],\n    )\n  ),\n  (\n    // Top-level \"3)\"\n    (\n      // 3a\n      (\n        // 3a i\n        sentence: [Ich habe ein Buch gelesen.],\n        gloss: [1SG.NOM hab-1SG.PRES ein.ACC Buch les-PART.PST],\n        tran: [I have read a book.],\n      ),\n      (\n        // 3a ii\n        sentence: [Sie wird morgen ankommen.],\n        gloss: [3SG.FEM.NOM werd-3SG.PRES morgen an-komm-INF],\n        tran: [She will arrive tomorrow.],\n      ),\n    ),\n  ),\n)\n\n#to-enum(format(xlist))\n```\n\n![image|507x386](upload://DTduJVBObjQ3wAgZIYSoHIfBCl.png)\n\n</details>\n\n---\n\nFor numbering patterns with different ending markers for different levels, see https://github.com/typst/typst/issues/6088\n\nhttps://github.com/typst/typst/issues/905",
      "reply_to_post_number": 2,
      "reply_count": 2,
      "quote_count": 0,
      "like_count": 1,
      "reads": 36,
      "score": 32.2,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 51
    },
    {
      "id": 10465,
      "post_number": 4,
      "username": "Mark_Hilton",
      "name": "Mark Hilton",
      "created_at": "2025-03-31T15:25:18.220Z",
      "updated_at": "2025-04-18T12:52:45.089Z",
      "cooked": "<aside class=\"quote no-group quote-modified\" data-username=\"Andrew\" data-post=\"3\" data-topic=\"3435\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/user_avatar/forum.typst.app/andrew/48/62_2.png\" class=\"avatar\"> Andrew:</div>\n<blockquote>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let format(xlist, level: 0) = {\n  // set enum(numbering: \"1.a.i)\")\n  if type(xlist) == dictionary {\n    xlist.values().map(smallcaps).join(\"\\n\")\n  } else if type(xlist) == array {\n    xlist.map(example =&gt; (format(example, level: level + 1),)).join()\n  }\n}\n</code></pre>\n</blockquote>\n</aside>\n<p>As a linguist beggining to use Typst, I am interested in this thread on formatting linguistic example lists and think I can follow how your code fits in with that by <a class=\"mention\" href=\"/u/quachpas\">@quachpas</a>.</p>\n<p>I’m planning to try it, but in the code above, I understand the <code>.map(smallcaps)</code> putting the examples into smallcaps, but I would want my examples to to be in a monospaced font instead. How would I modify the code to achieve that?</p>",
      "raw": "[quote=\"Andrew, post:3, topic:3435\"]\n```typ\n#let format(xlist, level: 0) = {\n  // set enum(numbering: \"1.a.i)\")\n  if type(xlist) == dictionary {\n    xlist.values().map(smallcaps).join(\"\\n\")\n  } else if type(xlist) == array {\n    xlist.map(example => (format(example, level: level + 1),)).join()\n  }\n}\n```\n[/quote]\nAs a linguist beggining to use Typst, I am interested in this thread on formatting linguistic example lists and think I can follow how your code fits in with that by @quachpas.\n\nI'm planning to try it, but in the code above, I understand the `.map(smallcaps)` putting the examples into smallcaps, but I would want my examples to to be in a monospaced font instead. How would I modify the code to achieve that?",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 1,
      "like_count": 0,
      "reads": 25,
      "score": 10.0,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 1276
    },
    {
      "id": 10468,
      "post_number": 5,
      "username": "bluss",
      "name": "Ulrik",
      "created_at": "2025-03-31T18:14:15.472Z",
      "updated_at": "2025-04-18T12:53:07.518Z",
      "cooked": "<p><code>map</code> takes any function, the function receives a value and should return content here. We can generalize format so it can change formatting of the word:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let format(xlist, level: 0, wordformat: smallcaps) = {\n  // set enum(numbering: \"1.a.i)\")\n  if type(xlist) == dictionary {\n    xlist.values().map(wordformat).join(\"\\n\")\n  } else if type(xlist) == array {\n    xlist.map(example =&gt; (format(example, level: level + 1, wordformat: wordformat),)).join()\n  }\n}\n</code></pre>\n<p>Then you can pass <code>wordformat: raw</code> to the function. Or equivalently <code>it =&gt; raw(it)</code> (an anonymous function). Or use a different function than <code>raw</code> if there’s a better way to format the text, maybe using <code>it =&gt; text(it)</code> with more options added in.</p>\n<p><img src=\"https://forum.typst.app/uploads/default/original/2X/9/96442e6ba3dfab4b19c3e8b3a2479267f5e7f6da.png\" alt=\"bild\" data-base62-sha1=\"lrjHiCCWOW0nQNEijHZlghx6fKW\" width=\"273\" height=\"239\"></p>\n<details>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let format(xlist, level: 0, wordformat: smallcaps) = {\n  // set enum(numbering: \"1.a.i)\")\n  if type(xlist) == dictionary {\n    xlist.values().map(wordformat).join(\"\\n\")\n  } else if type(xlist) == array {\n    xlist.map(example =&gt; (format(example, level: level + 1, wordformat: wordformat),)).join()\n  }\n}\n\n#let to-enum(arr) = {\n  set enum(numbering: \"1.a.i)\")\n  arr\n    .fold(\n      (),\n      (items, curr) =&gt; {\n        // If the current entry is an array, append a new subenum to\n        // the last item. Otherwise, create a new enum item.\n        if type(curr) == array { items += (to-enum(curr),) } else {\n          items.push(curr)\n        }\n        items\n      },\n    )\n    .map(enum.item)\n    .join()\n}\n\n#to-enum(format(\n  (\n    (\n      sentence: \"A sentence\",\n      gloss: \"Gloss\",\n      tran: \"Tran\"\n    ),\n    (\n      sentence: \"A sentence\",\n      gloss: \"Gloss\",\n      tran: \"Tran\"\n    ),\n  )\n, wordformat: raw))\n\n</code></pre>\n</details>",
      "raw": "`map` takes any function, the function receives a value and should return content here. We can generalize format so it can change formatting of the word:\n\n```typ\n#let format(xlist, level: 0, wordformat: smallcaps) = {\n  // set enum(numbering: \"1.a.i)\")\n  if type(xlist) == dictionary {\n    xlist.values().map(wordformat).join(\"\\n\")\n  } else if type(xlist) == array {\n    xlist.map(example => (format(example, level: level + 1, wordformat: wordformat),)).join()\n  }\n}\n```\n\nThen you can pass `wordformat: raw` to the function. Or equivalently `it => raw(it)` (an anonymous function). Or use a different function than `raw` if there's a better way to format the text, maybe using `it => text(it)` with more options added in.\n\n![bild|273x239](upload://lrjHiCCWOW0nQNEijHZlghx6fKW.png)\n\n\n<details>\n\n```typ\n#let format(xlist, level: 0, wordformat: smallcaps) = {\n  // set enum(numbering: \"1.a.i)\")\n  if type(xlist) == dictionary {\n    xlist.values().map(wordformat).join(\"\\n\")\n  } else if type(xlist) == array {\n    xlist.map(example => (format(example, level: level + 1, wordformat: wordformat),)).join()\n  }\n}\n\n#let to-enum(arr) = {\n  set enum(numbering: \"1.a.i)\")\n  arr\n    .fold(\n      (),\n      (items, curr) => {\n        // If the current entry is an array, append a new subenum to\n        // the last item. Otherwise, create a new enum item.\n        if type(curr) == array { items += (to-enum(curr),) } else {\n          items.push(curr)\n        }\n        items\n      },\n    )\n    .map(enum.item)\n    .join()\n}\n\n#to-enum(format(\n  (\n    (\n      sentence: \"A sentence\",\n      gloss: \"Gloss\",\n      tran: \"Tran\"\n    ),\n    (\n      sentence: \"A sentence\",\n      gloss: \"Gloss\",\n      tran: \"Tran\"\n    ),\n  )\n, wordformat: raw))\n\n```\n</details>",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 22,
      "score": 4.4,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 1272
    },
    {
      "id": 10470,
      "post_number": 6,
      "username": "Andrew",
      "name": "",
      "created_at": "2025-03-31T19:31:31.861Z",
      "updated_at": "2025-03-31T19:31:31.861Z",
      "cooked": "<p>There are 2 options: <code>raw</code> and <code>text.with(font: \"monospacedfont\")</code>. First one only works on <code>str</code>ings, second works on <code>str</code>ings and <code>content</code> types. Usually you would use <code>raw</code> one way or another, but here a conversion from <code>content</code> to <code>str</code> should be added that is relatively robust and easy:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#import \"@preview/t4t:0.4.2\": get\n\n#let format(xlist, level: 0) = {\n  if type(xlist) == dictionary {\n    xlist.values().map(get.text).map(raw).join(\"\\n\")\n  } else if type(xlist) == array {\n    xlist.map(example =&gt; (format(example, level: level + 1),)).join()\n  }\n}\n</code></pre>\n<p>But if you will only ever use strings, then you don’t need that package function.</p>\n<p>The less idiomatic way:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let format(xlist, level: 0) = {\n  if type(xlist) == dictionary {\n    xlist.values().map(text.with(font: \"Liberation Mono\")).join(\"\\n\")\n  } else if type(xlist) == array {\n    xlist.map(example =&gt; (format(example, level: level + 1),)).join()\n  }\n}\n</code></pre>\n<p>Of course, if you need to, you can move out the formatting function into an input parameter like <a class=\"mention\" href=\"/u/bluss\">@bluss</a> showed above.</p>",
      "raw": "There are 2 options: `raw` and `text.with(font: \"monospacedfont\")`. First one only works on `str`ings, second works on `str`ings and `content` types. Usually you would use `raw` one way or another, but here a conversion from `content` to `str` should be added that is relatively robust and easy:\n\n```typ\n#import \"@preview/t4t:0.4.2\": get\n\n#let format(xlist, level: 0) = {\n  if type(xlist) == dictionary {\n    xlist.values().map(get.text).map(raw).join(\"\\n\")\n  } else if type(xlist) == array {\n    xlist.map(example => (format(example, level: level + 1),)).join()\n  }\n}\n```\n\nBut if you will only ever use strings, then you don't need that package function.\n\nThe less idiomatic way:\n\n```typ\n#let format(xlist, level: 0) = {\n  if type(xlist) == dictionary {\n    xlist.values().map(text.with(font: \"Liberation Mono\")).join(\"\\n\")\n  } else if type(xlist) == array {\n    xlist.map(example => (format(example, level: level + 1),)).join()\n  }\n}\n```\n\nOf course, if you need to, you can move out the formatting function into an input parameter like @bluss showed above.",
      "reply_to_post_number": 4,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 22,
      "score": 4.4,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 51
    },
    {
      "id": 11277,
      "post_number": 7,
      "username": "SillyFreak",
      "name": "SillyFreak",
      "created_at": "2025-04-18T13:05:50.731Z",
      "updated_at": "2025-04-18T13:05:50.731Z",
      "cooked": "<aside class=\"quote no-group\" data-username=\"Andrew\" data-post=\"3\" data-topic=\"3435\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/user_avatar/forum.typst.app/andrew/48/62_2.png\" class=\"avatar\"> Andrew:</div>\n<blockquote>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let to-enum(arr) = {\n  set enum(numbering: \"1.a.i)\")\n  let fold-func = (items, curr) =&gt; {\n    // If the current entry is an array, append a new subenum to\n    // the last item. Otherwise, create a new enum item.\n    items + (if type(curr) == array { to-enum(curr) } else { curr },)\n  }\n  arr.fold((), fold-func).map(enum.item).join()\n}\n</code></pre>\n</blockquote>\n</aside>\n<p>not shorter but imo clearer than the <code>fold</code>:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let to-enum(elem) = {\n  if type(elem) != array {\n    return elem\n  }\n\n  set enum(numbering: \"1.a.i)\")\n  for e in elem [+ #to-enum(e)]\n}\n</code></pre>",
      "raw": "[quote=\"Andrew, post:3, topic:3435\"]\n```typ\n#let to-enum(arr) = {\n  set enum(numbering: \"1.a.i)\")\n  let fold-func = (items, curr) => {\n    // If the current entry is an array, append a new subenum to\n    // the last item. Otherwise, create a new enum item.\n    items + (if type(curr) == array { to-enum(curr) } else { curr },)\n  }\n  arr.fold((), fold-func).map(enum.item).join()\n}\n```\n[/quote]\n\nnot shorter but imo clearer than the `fold`:\n```typ\n#let to-enum(elem) = {\n  if type(elem) != array {\n    return elem\n  }\n\n  set enum(numbering: \"1.a.i)\")\n  for e in elem [+ #to-enum(e)]\n}\n```",
      "reply_to_post_number": 3,
      "reply_count": 0,
      "quote_count": 1,
      "like_count": 0,
      "reads": 18,
      "score": 8.6,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 32
    },
    {
      "id": 11540,
      "post_number": 8,
      "username": "afiaith",
      "name": "Maja Abramski-Kronenberg",
      "created_at": "2025-04-23T21:58:01.745Z",
      "updated_at": "2025-04-23T21:58:01.745Z",
      "cooked": "<p>tl;dr…</p>\n<p>Is what you need covered by <a href=\"https://typst.app/universe/package/leipzig-glossing\">leipzig-glossing</a>?</p>",
      "raw": "tl;dr…\n\nIs what you need covered by [leipzig-glossing](https://typst.app/universe/package/leipzig-glossing)?",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 18,
      "score": 3.6,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 91
    }
  ],
  "scraped_at": "2025-06-10T09:49:54.267316"
}