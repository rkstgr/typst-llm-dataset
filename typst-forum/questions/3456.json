{
  "topic_metadata": {
    "id": 3456,
    "title": "How to get the number of the first and last paragraph on a page and show the result in the header?",
    "slug": "how-to-get-the-number-of-the-first-and-last-paragraph-on-a-page-and-show-the-result-in-the-header",
    "posts_count": 15,
    "created_at": "2025-03-30T08:52:39.384Z",
    "last_posted_at": "2025-04-06T10:43:57.782Z",
    "views": 202,
    "like_count": 8,
    "reply_count": 10,
    "has_accepted_answer": true,
    "accepted_answer_post_number": 8,
    "accepted_answer_username": "sijo",
    "tags": [
      "scripting",
      "header-footer",
      "state",
      "query"
    ],
    "category_id": 5,
    "participant_count": 4,
    "word_count": 5241
  },
  "posts": [
    {
      "id": 10408,
      "post_number": 1,
      "username": "a_w",
      "name": "Alex",
      "created_at": "2025-03-30T08:52:39.650Z",
      "updated_at": "2025-03-30T10:07:36.764Z",
      "cooked": "<p>I’m trying to layout pages that contain numbered paragraphs and want to give the reader a better overview where they are (e.g. site contains paragraphs 1–7). Something like this:</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://forum.typst.app/uploads/default/original/2X/b/b71b8c1773360ae0890c7c9c4490b124d5de166c.jpeg\" data-download-href=\"https://forum.typst.app/uploads/default/b71b8c1773360ae0890c7c9c4490b124d5de166c\" title=\"layout-example\"><img src=\"https://forum.typst.app/uploads/default/optimized/2X/b/b71b8c1773360ae0890c7c9c4490b124d5de166c_2_690x489.jpeg\" alt=\"layout-example\" data-base62-sha1=\"q7QoBaw6waHnBQCegdgpu6Jw3uc\" width=\"690\" height=\"489\" srcset=\"https://forum.typst.app/uploads/default/optimized/2X/b/b71b8c1773360ae0890c7c9c4490b124d5de166c_2_690x489.jpeg, https://forum.typst.app/uploads/default/optimized/2X/b/b71b8c1773360ae0890c7c9c4490b124d5de166c_2_1035x733.jpeg 1.5x, https://forum.typst.app/uploads/default/optimized/2X/b/b71b8c1773360ae0890c7c9c4490b124d5de166c_2_1380x978.jpeg 2x\" data-dominant-color=\"ECECEC\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">layout-example</span><span class=\"informations\">1650×1170 151 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>What I’m struggling with: Paragraphs that span multiple pages and finding the best possible solution overall. Paragraphs can contain linebreaks and formatting and being able to link to them would be cool in the future.</p>\n<p>My first approach of counting the elements was mistaken thinking, as the content itself is already numbered (differences in numbering/doubled numbers). I’ve also realized that wrapping the elements like <code>#par[id: \"1\", lorem(50)]</code> doesn’t bring obvious benefits in comparison to <code>#par(1)[1.]~#lorem(50)</code> (par numbers attached to the following content) in terms of querying.</p>\n<p>My current quite sorry working example is:</p>\n<details>\n<summary>\nCode</summary>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#set page(width: 100mm, height: 100mm)\n\n#let par(id: none, body) = {\n  show heading.where(level: 4): it =&gt; {\n    set text(weight: \"regular\")\n    [#strong(id + \". \")] + it.body\n  }\n  heading(level: 4, supplement: id)[#body]\n}\n\n#show heading.where(level: 1): it =&gt; {\n  pagebreak(weak: true)\n  it\n}\n\n#set page(\n  header: {\n    context {\n      // Getting current Chapter title (supplement)\n      let headings = query(selector(heading.where(level: 1)))\n      let h = headings.filter(h =&gt; h.location().page() &lt;= here().page()).last()\n      if h != none {\n        h.supplement\n      }\n\n      // Get paragraphs on current page\n      let paragraphs = query(selector(heading.where(level: 4))).filter(h4 =&gt; here().page() == h4.location().page())\n      \n      if paragraphs.len() == 0 { } else if paragraphs.last() == paragraphs.first() {\n        [ ] + paragraphs.first().supplement\n      } else {\n        [ ] + paragraphs.first().supplement + \"-\" + paragraphs.last().supplement\n      }\n  }},\n)\n\n#heading(level: 1, supplement: \"A-Chapter\")[This is Chapter A]\n#par(id: \"1\", lorem(50))\n#par(id: \"2\", lorem(20))\n#par(id: \"3\", lorem(150))\n\n#heading(level: 1, supplement: \"B-Chapter\")[This is Chapter B]\n#par(id: \"11\", lorem(50))\n#par(id: \"12\", lorem(20))\n\n#heading(level: 1, supplement: \"C-Chapter\")[This is Chapter C]\n#par(id: \"21a\", lorem(50))\n</code></pre>\n</details>\n<p>This leads to:</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://forum.typst.app/uploads/default/original/2X/4/407405a38151ae8944b9e14fd9419ea5776cfd10.jpeg\" data-download-href=\"https://forum.typst.app/uploads/default/407405a38151ae8944b9e14fd9419ea5776cfd10\" title=\"query-example\"><img src=\"https://forum.typst.app/uploads/default/optimized/2X/4/407405a38151ae8944b9e14fd9419ea5776cfd10_2_259x500.jpeg\" alt=\"query-example\" data-base62-sha1=\"9cb8jGuBO9mhTn7x5tcTRR9znpe\" width=\"259\" height=\"500\" srcset=\"https://forum.typst.app/uploads/default/optimized/2X/4/407405a38151ae8944b9e14fd9419ea5776cfd10_2_259x500.jpeg, https://forum.typst.app/uploads/default/optimized/2X/4/407405a38151ae8944b9e14fd9419ea5776cfd10_2_388x750.jpeg 1.5x, https://forum.typst.app/uploads/default/optimized/2X/4/407405a38151ae8944b9e14fd9419ea5776cfd10_2_518x1000.jpeg 2x\" data-dominant-color=\"EBEBEB\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">query-example</span><span class=\"informations\">876×1686 242 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>What I actually like about the approach: <code>#par(id: \"1\", lorem(50))</code> the <code>id</code> as a string gives total control over the ID it can also be <code>I.</code> or <code>22a</code> whenever needed. Even though I have to “abuse” supplement to access it. Using the headline also makes the paragraphs potentially linkable.</p>\n<p>What my questions are:</p>\n<ul>\n<li>\n<p>How can I use state (or something else?) to carry the last paragraph number to the following page(s) theoretically a paragraph could span multiple pages?</p>\n</li>\n<li>\n<p>I don’t feel this is the best solution to achieve what I want. I’m fluctuating between “this is overengineered” (maybe I could just get the highest ID without querying) and this is stupid (setting ID as string, than using supplement). Is there overall a better approach?</p>\n</li>\n</ul>\n<p>Help and guidance greatly appreciated I just couldn’t figure it out :x</p>",
      "raw": "I'm trying to layout pages that contain numbered paragraphs and want to give the reader a better overview where they are (e.g. site contains paragraphs 1–7). Something like this:\n\n![layout-example|690x489](upload://q7QoBaw6waHnBQCegdgpu6Jw3uc.jpeg)\n\nWhat I'm struggling with: Paragraphs that span multiple pages and finding the best possible solution overall. Paragraphs can contain linebreaks and formatting and being able to link to them would be cool in the future.\n\nMy first approach of counting the elements was mistaken thinking, as the content itself is already numbered (differences in numbering/doubled numbers). I've also realized that wrapping the elements like `#par[id: \"1\", lorem(50)]` doesn't bring obvious benefits in comparison to `#par(1)[1.]~#lorem(50)` (par numbers attached to the following content) in terms of querying.\n\nMy current quite sorry working example is:\n[details=\"Code\"]\n```typ\n#set page(width: 100mm, height: 100mm)\n\n#let par(id: none, body) = {\n  show heading.where(level: 4): it => {\n    set text(weight: \"regular\")\n    [#strong(id + \". \")] + it.body\n  }\n  heading(level: 4, supplement: id)[#body]\n}\n\n#show heading.where(level: 1): it => {\n  pagebreak(weak: true)\n  it\n}\n\n#set page(\n  header: {\n    context {\n      // Getting current Chapter title (supplement)\n      let headings = query(selector(heading.where(level: 1)))\n      let h = headings.filter(h => h.location().page() <= here().page()).last()\n      if h != none {\n        h.supplement\n      }\n\n      // Get paragraphs on current page\n      let paragraphs = query(selector(heading.where(level: 4))).filter(h4 => here().page() == h4.location().page())\n      \n      if paragraphs.len() == 0 { } else if paragraphs.last() == paragraphs.first() {\n        [ ] + paragraphs.first().supplement\n      } else {\n        [ ] + paragraphs.first().supplement + \"-\" + paragraphs.last().supplement\n      }\n  }},\n)\n\n#heading(level: 1, supplement: \"A-Chapter\")[This is Chapter A]\n#par(id: \"1\", lorem(50))\n#par(id: \"2\", lorem(20))\n#par(id: \"3\", lorem(150))\n\n#heading(level: 1, supplement: \"B-Chapter\")[This is Chapter B]\n#par(id: \"11\", lorem(50))\n#par(id: \"12\", lorem(20))\n\n#heading(level: 1, supplement: \"C-Chapter\")[This is Chapter C]\n#par(id: \"21a\", lorem(50))\n```\n[/details]\n\nThis leads to:\n\n![query-example|259x500](upload://9cb8jGuBO9mhTn7x5tcTRR9znpe.jpeg)\n\nWhat I actually like about the approach: `#par(id: \"1\", lorem(50))` the `id` as a string gives total control over the ID it can also be `I.` or `22a` whenever needed. Even though I have to \"abuse\" supplement to access it. Using the headline also makes the paragraphs potentially linkable.\n\nWhat my questions are:\n\n- How can I use state (or something else?) to carry the last paragraph number to the following page(s) theoretically a paragraph could span multiple pages?\n\n- I don't feel this is the best solution to achieve what I want. I'm fluctuating between \"this is overengineered\" (maybe I could just get the highest ID without querying) and this is stupid (setting ID as string, than using supplement). Is there overall a better approach?\n\nHelp and guidance greatly appreciated I just couldn't figure it out :x",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 43,
      "score": 128.6,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 566
    },
    {
      "id": 10409,
      "post_number": 2,
      "username": "bluss",
      "name": "Ulrik",
      "created_at": "2025-03-30T10:21:26.570Z",
      "updated_at": "2025-03-30T10:25:04.648Z",
      "cooked": "<p>No idea about the bigger picture, but for the particular problem, maybe this works.</p>\n<p>Tag some id information at the start of every paragraph</p>\n<pre data-code-wrap=\"typc\"><code class=\"lang-typc\">[#metadata((id: id))&lt;par&gt;]\n</code></pre>\n<p>In the header, if there’s nothing else, remember the last seen start of paragraph</p>\n<pre data-code-wrap=\"typc\"><code class=\"lang-typc\">let previous_paragraphs = query(selector(&lt;par&gt;).before(here()))\nif paragraphs.len() == 0 and previous_paragraphs.len() &gt; 0 {\n  [ (#previous_paragraphs.last().value.id;)]\n}\n</code></pre>\n<p><img src=\"https://forum.typst.app/uploads/default/original/2X/f/f8426564783e5bec1eb567655f4897168d77534d.png\" alt=\"bild\" data-base62-sha1=\"zqcFgv4RTOfNs5K2suDdyVpSfX7\" width=\"373\" height=\"140\"></p>\n<p>Note that there is already a built-in element called par, so your function should probably have a different name.</p>\n<p>Now that I think of it, your existing approach also gives you another way to solve it - filter on page but use <code>&lt;=</code> instead of <code>==</code> for page, and take the last. Should have the same effect without needing to add metadata elements.</p>",
      "raw": "No idea about the bigger picture, but for the particular problem, maybe this works.\n\nTag some id information at the start of every paragraph\n\n```typc\n[#metadata((id: id))<par>]\n```\n\nIn the header, if there's nothing else, remember the last seen start of paragraph\n\n```typc\nlet previous_paragraphs = query(selector(<par>).before(here()))\nif paragraphs.len() == 0 and previous_paragraphs.len() > 0 {\n  [ (#previous_paragraphs.last().value.id;)]\n}\n```\n\n![bild|373x140](upload://zqcFgv4RTOfNs5K2suDdyVpSfX7.png)\n\n\nNote that there is already a built-in element called par, so your function should probably have a different name.\n\nNow that I think of it, your existing approach also gives you another way to solve it - filter on page but use `<=` instead of `==` for page, and take the last. Should have the same effect without needing to add metadata elements.",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 1,
      "reads": 40,
      "score": 38.0,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 1272
    },
    {
      "id": 10410,
      "post_number": 3,
      "username": "sijo",
      "name": "",
      "created_at": "2025-03-30T10:48:23.652Z",
      "updated_at": "2025-03-30T10:51:27.646Z",
      "cooked": "<p>That works if you know there cannot be a page without paragraph… If this case must also be handled you probably need the metadata, for example:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#set page(\n  width: 100mm,\n  height: 100mm,\n  header: context {\n    let id(x) = if x.func() == heading { x.body } else { x.value }\n    let pars = query(heading.where(level: 4).or(&lt;h4-end&gt;))\n      .filter(x =&gt; x.location().page() == here().page())\n      .map(id)\n      .dedup()\n    if pars.len() == 0 {\n      // No paragraph starting or ending on this page\n      // -&gt; check if a paragraph starts before and ends after this page\n      let prev = query(heading.where(level: 4).before(here()))\n      let next = query(selector(&lt;h4-end&gt;).after(here()))\n      if prev.len() == 0 or next.len() == 0 {\n        return none\n      }\n      if prev.last().body != next.first().value {\n        return none\n      }\n      return prev.last().body\n    }\n    if pars.len() == 1 {\n      return pars.first()\n    }\n    return [#pars.first() -- #pars.last()]\n  },\n)\n\n#show heading.where(level: 4): it =&gt; it.body + h(1em)\n\n#let my-par(id: none, body) = {\n  parbreak()\n  if id != none {\n    heading(level: 4, id)\n  }\n  body\n  box[#metadata([#id])&lt;h4-end&gt;]\n}\n\n#heading(level: 1, supplement: \"A-Chapter\")[This is Chapter A]\n#my-par(id: \"1\", lorem(50))\n#my-par(id: \"2\", lorem(20))\n#my-par(id: \"3\", lorem(150))\n\n#heading(level: 1, supplement: \"B-Chapter\")[This is Chapter B]\n#my-par(id: \"11\", lorem(50))\n#my-par(id: \"12\", lorem(180))\n\n#heading(level: 1, supplement: \"B-Chapter\")[This is Chapter C]\n#my-par(id: \"21a\", lorem(50))\n</code></pre>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://forum.typst.app/uploads/default/original/2X/6/667c806df71f29ee53f4bb5898aeef8b464877e8.png\" data-download-href=\"https://forum.typst.app/uploads/default/667c806df71f29ee53f4bb5898aeef8b464877e8\" title=\"image\"><img src=\"https://forum.typst.app/uploads/default/optimized/2X/6/667c806df71f29ee53f4bb5898aeef8b464877e8_2_690x458.png\" alt=\"image\" data-base62-sha1=\"eCDrCT5PYq3iNCf85fc55uQxHx6\" width=\"690\" height=\"458\" srcset=\"https://forum.typst.app/uploads/default/optimized/2X/6/667c806df71f29ee53f4bb5898aeef8b464877e8_2_690x458.png, https://forum.typst.app/uploads/default/optimized/2X/6/667c806df71f29ee53f4bb5898aeef8b464877e8_2_1035x687.png 1.5x, https://forum.typst.app/uploads/default/original/2X/6/667c806df71f29ee53f4bb5898aeef8b464877e8.png 2x\" data-dominant-color=\"EEEEEE\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">image</span><span class=\"informations\">1368×910 341 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>Compared to the original solution, this uses the level-4 heading just for the paragraph number rather than the whole paragraph. I think that’s much cleaner, and then you can use the usual styling system to change the appearance of the paragraph number.</p>\n<p>It could be technically feasible to add the numbering with a <code>par</code> show rule, so that actual paragraphs are automatically numbered as you want (instead of calling a custom-defined <code>par</code> function). But it’s tricky to work with <code>par</code> show rules, and it becomes a pain when your document has paragraphs that should not be numbered (for example in a table or long caption). So the explicit call for each paragraph is probably better.</p>",
      "raw": "That works if you know there cannot be a page without paragraph... If this case must also be handled you probably need the metadata, for example:\n\n```typ\n#set page(\n  width: 100mm,\n  height: 100mm,\n  header: context {\n    let id(x) = if x.func() == heading { x.body } else { x.value }\n    let pars = query(heading.where(level: 4).or(<h4-end>))\n      .filter(x => x.location().page() == here().page())\n      .map(id)\n      .dedup()\n    if pars.len() == 0 {\n      // No paragraph starting or ending on this page\n      // -> check if a paragraph starts before and ends after this page\n      let prev = query(heading.where(level: 4).before(here()))\n      let next = query(selector(<h4-end>).after(here()))\n      if prev.len() == 0 or next.len() == 0 {\n        return none\n      }\n      if prev.last().body != next.first().value {\n        return none\n      }\n      return prev.last().body\n    }\n    if pars.len() == 1 {\n      return pars.first()\n    }\n    return [#pars.first() -- #pars.last()]\n  },\n)\n\n#show heading.where(level: 4): it => it.body + h(1em)\n\n#let my-par(id: none, body) = {\n  parbreak()\n  if id != none {\n    heading(level: 4, id)\n  }\n  body\n  box[#metadata([#id])<h4-end>]\n}\n\n#heading(level: 1, supplement: \"A-Chapter\")[This is Chapter A]\n#my-par(id: \"1\", lorem(50))\n#my-par(id: \"2\", lorem(20))\n#my-par(id: \"3\", lorem(150))\n\n#heading(level: 1, supplement: \"B-Chapter\")[This is Chapter B]\n#my-par(id: \"11\", lorem(50))\n#my-par(id: \"12\", lorem(180))\n\n#heading(level: 1, supplement: \"B-Chapter\")[This is Chapter C]\n#my-par(id: \"21a\", lorem(50))\n```\n\n![image|690x458](upload://eCDrCT5PYq3iNCf85fc55uQxHx6.png)\n\n\nCompared to the original solution, this uses the level-4 heading just for the paragraph number rather than the whole paragraph. I think that's much cleaner, and then you can use the usual styling system to change the appearance of the paragraph number.\n\nIt could be technically feasible to add the numbering with a `par` show rule, so that actual paragraphs are automatically numbered as you want (instead of calling a custom-defined `par` function). But it's tricky to work with `par` show rules, and it becomes a pain when your document has paragraphs that should not be numbered (for example in a table or long caption). So the explicit call for each paragraph is probably better.",
      "reply_to_post_number": 2,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 2,
      "reads": 36,
      "score": 37.2,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 332
    },
    {
      "id": 10413,
      "post_number": 4,
      "username": "a_w",
      "name": "Alex",
      "created_at": "2025-03-30T11:32:19.172Z",
      "updated_at": "2025-03-30T11:32:19.172Z",
      "cooked": "<p><a class=\"mention\" href=\"/u/bluss\">@bluss</a> this is certainly an interesting idea and an alternative to <code>state()</code>, which I thought would be probably necessary. And you are of course right that my <code>#par</code> needs to be renamed. Thanks.</p>\n<p><a class=\"mention\" href=\"/u/sijo\">@sijo</a> Omg, nice… thanks! This is already quite close to what I wanted to achieve. Querying between the headlines instead of the pages has the added benefit that I don’t have to force pagebreak the chapters to get it right. I wish I was as capable with using query <img src=\"https://forum.typst.app/images/emoji/apple/face_holding_back_tears.png?v=12\" title=\":face_holding_back_tears:\" class=\"emoji\" alt=\":face_holding_back_tears:\" loading=\"lazy\" width=\"20\" height=\"20\"> and I wholeheartedly agree using the heading only for the number is indeed much cleaner and probably avoids downstream problems.</p>\n<p>May I ask a follow-up: How would you handle the 3 – 11 case or 12 – 21a case where the paragraph numbers cross chapters?</p>\n<p>What do you think of the supplement workaround for the short chapter titles?</p>",
      "raw": "@bluss this is certainly an interesting idea and an alternative to `state()`, which I thought would be probably necessary. And you are of course right that my `#par` needs to be renamed. Thanks.\n\n@sijo Omg, nice… thanks! This is already quite close to what I wanted to achieve. Querying between the headlines instead of the pages has the added benefit that I don't have to force pagebreak the chapters to get it right. I wish I was as capable with using query 🥹 and I wholeheartedly agree using the heading only for the number is indeed much cleaner and probably avoids downstream problems.\n\nMay I ask a follow-up: How would you handle the 3 – 11 case or 12 – 21a case where the paragraph numbers cross chapters?\n\nWhat do you think of the supplement workaround for the short chapter titles?",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 0,
      "reads": 34,
      "score": 11.8,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 566
    },
    {
      "id": 10421,
      "post_number": 5,
      "username": "Andrew",
      "name": "",
      "created_at": "2025-03-30T12:13:58.734Z",
      "updated_at": "2025-03-31T11:20:38.238Z",
      "cooked": "<p>I’m not sure if you want more like in the sample page or more like in your example, so I copied the sample page:</p>\n<details><summary>code</summary>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let header = context {\n  let page = here().page()\n  place(right + bottom)[#page]\n  let headings = {\n    query(heading.where(level: 4)).filter(x =&gt; x.location().page() == page)\n  }\n  let current-headings = headings.map(x =&gt; int(x.body.text))\n  if current-headings.len() == 0 {\n    let pars = query(&lt;par&gt;).filter(x =&gt; x.location().page() == page)\n    if pars.len() == 0 { return }\n    let last-headings = query(heading.where(level: 4).before(here()))\n    if last-headings.len() == 0 { return }\n    current-headings = (last-headings.last().body.text,)\n  }\n  if current-headings.len() == 1 { current-headings = current-headings * 2 }\n  let (a, b) = (current-headings.first(), current-headings.last())\n  place(center + bottom)[Nr. #(a)---#b.]\n}\n\n#let decorative-lines = context {\n  let line(start, len, ..args) = std.line(start: start, length: len, ..args)\n  let top = page.margin.top\n  let left = page.margin.left\n  // Vertical line\n  let length = page.height - page.margin.top - page.margin.bottom\n  place(center, line((0%, top + 1mm), length - 1mm, angle: 90deg))\n  // Horizontal line\n  let length = page.width - page.margin.left - page.margin.right\n  place(line((left, top - 3mm), length, stroke: 3pt))\n}\n\n#set page(\n  width: 270mm,\n  height: 250mm,\n  margin: (top: 2cm, rest: 1cm),\n  columns: 2,\n  background: decorative-lines,\n  header: header,\n)\n#set columns(gutter: 3mm * 2)\n#set par(justify: true, first-line-indent: (amount: 1em, all: true))\n// #show par: it =&gt; [#it&lt;par&gt;] // Doesn't work.\n#show par: it =&gt; [#metadata(none)&lt;par&gt;#it&lt;par&gt;#metadata(none)&lt;par&gt;]\n\n#show heading.where(level: 4): set align(center)\n#show heading.where(level: 4): set text(1.5em)\n#show heading.where(level: 4): it =&gt; block(box(it) + \".\")\n\n#(pagebreak() * 118)\n\n==== 210\n#lorem(50)\n\n#lorem(20)\n\n#lorem(40)\n\n#lorem(30)\n\n==== 211\n#lorem(50)\n\n#lorem(50)\n\n==== 212\n#lorem(50)\n\n#lorem(50)\n\n#lorem(60)\n\n#lorem(40)\n\n#lorem(90)\n\n==== 213\n#lorem(70)\n\n==== 214\n#lorem(90)\n\n#lorem(90)\n</code></pre>\n</details>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://forum.typst.app/uploads/default/original/2X/7/7c49c80c995caaaaa28515a9eed8e820235d89af.png\" data-download-href=\"https://forum.typst.app/uploads/default/7c49c80c995caaaaa28515a9eed8e820235d89af\" title=\"image\"><img src=\"https://forum.typst.app/uploads/default/optimized/2X/7/7c49c80c995caaaaa28515a9eed8e820235d89af_2_542x500.png\" alt=\"image\" data-base62-sha1=\"hJvhvl74xmNVIiK8Cmi1gaqPuov\" width=\"542\" height=\"500\" srcset=\"https://forum.typst.app/uploads/default/optimized/2X/7/7c49c80c995caaaaa28515a9eed8e820235d89af_2_542x500.png, https://forum.typst.app/uploads/default/optimized/2X/7/7c49c80c995caaaaa28515a9eed8e820235d89af_2_813x750.png 1.5x, https://forum.typst.app/uploads/default/original/2X/7/7c49c80c995caaaaa28515a9eed8e820235d89af.png 2x\" data-dominant-color=\"232323\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">image</span><span class=\"informations\">959×884 280 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div><br>\n<div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://forum.typst.app/uploads/default/original/2X/f/f87efd462491815cea24d57906a4711b3e9e957e.png\" data-download-href=\"https://forum.typst.app/uploads/default/f87efd462491815cea24d57906a4711b3e9e957e\" title=\"image\"><img src=\"https://forum.typst.app/uploads/default/optimized/2X/f/f87efd462491815cea24d57906a4711b3e9e957e_2_550x499.png\" alt=\"image\" data-base62-sha1=\"zsiu8zMkQjl42BPvlGKCheXXA2q\" width=\"550\" height=\"499\" srcset=\"https://forum.typst.app/uploads/default/optimized/2X/f/f87efd462491815cea24d57906a4711b3e9e957e_2_550x499.png, https://forum.typst.app/uploads/default/optimized/2X/f/f87efd462491815cea24d57906a4711b3e9e957e_2_825x748.png 1.5x, https://forum.typst.app/uploads/default/original/2X/f/f87efd462491815cea24d57906a4711b3e9e957e.png 2x\" data-dominant-color=\"101010\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">image</span><span class=\"informations\">957×870 39.4 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>This is a code with manual numbering sections, which makes sense, but it’s very easy to miscount.</p>\n<p>You can add this assertion to keep yourself in check:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let header = context {\n  let page = here().page()\n  place(right + bottom)[#page]\n  let all-headings = query(heading.where(level: 4))\n  if all-headings.len() == 0 { return }\n  assert(int(all-headings.last().body.text) == all-headings.len())\n  let headings = {\n</code></pre>\n<p>I can change <code>==== 69</code> to <code>#section-break</code>, but I don’t know enough details of the ideal output.</p>",
      "raw": "I'm not sure if you want more like in the sample page or more like in your example, so I copied the sample page:\n\n<details><summary>code</summary>\n\n```typ\n#let header = context {\n  let page = here().page()\n  place(right + bottom)[#page]\n  let headings = {\n    query(heading.where(level: 4)).filter(x => x.location().page() == page)\n  }\n  let current-headings = headings.map(x => int(x.body.text))\n  if current-headings.len() == 0 {\n    let pars = query(<par>).filter(x => x.location().page() == page)\n    if pars.len() == 0 { return }\n    let last-headings = query(heading.where(level: 4).before(here()))\n    if last-headings.len() == 0 { return }\n    current-headings = (last-headings.last().body.text,)\n  }\n  if current-headings.len() == 1 { current-headings = current-headings * 2 }\n  let (a, b) = (current-headings.first(), current-headings.last())\n  place(center + bottom)[Nr. #(a)---#b.]\n}\n\n#let decorative-lines = context {\n  let line(start, len, ..args) = std.line(start: start, length: len, ..args)\n  let top = page.margin.top\n  let left = page.margin.left\n  // Vertical line\n  let length = page.height - page.margin.top - page.margin.bottom\n  place(center, line((0%, top + 1mm), length - 1mm, angle: 90deg))\n  // Horizontal line\n  let length = page.width - page.margin.left - page.margin.right\n  place(line((left, top - 3mm), length, stroke: 3pt))\n}\n\n#set page(\n  width: 270mm,\n  height: 250mm,\n  margin: (top: 2cm, rest: 1cm),\n  columns: 2,\n  background: decorative-lines,\n  header: header,\n)\n#set columns(gutter: 3mm * 2)\n#set par(justify: true, first-line-indent: (amount: 1em, all: true))\n// #show par: it => [#it<par>] // Doesn't work.\n#show par: it => [#metadata(none)<par>#it<par>#metadata(none)<par>]\n\n#show heading.where(level: 4): set align(center)\n#show heading.where(level: 4): set text(1.5em)\n#show heading.where(level: 4): it => block(box(it) + \".\")\n\n#(pagebreak() * 118)\n\n==== 210\n#lorem(50)\n\n#lorem(20)\n\n#lorem(40)\n\n#lorem(30)\n\n==== 211\n#lorem(50)\n\n#lorem(50)\n\n==== 212\n#lorem(50)\n\n#lorem(50)\n\n#lorem(60)\n\n#lorem(40)\n\n#lorem(90)\n\n==== 213\n#lorem(70)\n\n==== 214\n#lorem(90)\n\n#lorem(90)\n```\n\n</details>\n\n\n![image|542x500](upload://hJvhvl74xmNVIiK8Cmi1gaqPuov.png)\n![image|550x499](upload://zsiu8zMkQjl42BPvlGKCheXXA2q.png)\n\nThis is a code with manual numbering sections, which makes sense, but it's very easy to miscount.\n\nYou can add this assertion to keep yourself in check:\n\n```typ\n#let header = context {\n  let page = here().page()\n  place(right + bottom)[#page]\n  let all-headings = query(heading.where(level: 4))\n  if all-headings.len() == 0 { return }\n  assert(int(all-headings.last().body.text) == all-headings.len())\n  let headings = {\n```\n\nI can change `==== 69` to `#section-break`, but I don't know enough details of the ideal output.",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 1,
      "reads": 34,
      "score": 21.8,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 51
    },
    {
      "id": 10431,
      "post_number": 6,
      "username": "sijo",
      "name": "",
      "created_at": "2025-03-30T13:21:10.765Z",
      "updated_at": "2025-03-30T13:22:00.804Z",
      "cooked": "<p>The supplement thing is rather hacky, it could cause problems with outlines or references. So I’d rather use a custom heading command that adds “short title” metadata that can be retrieved in the header:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#set page(\n  width: 100mm,\n  height: 100mm,\n  header: context {\n    let id(x) = if x.func() == heading { x.body } else { x.value }\n    // Returns content showing short chapter title and paragraph number\n    let chap-id(x) = {\n      let shorts = query(selector(&lt;h1-short&gt;).before(x.location()))\n      if shorts.len() == 0 {\n        id(x)\n      } else [\n        #shorts.last().value: #id(x)\n      ]\n    }\n    let pars = query(heading.where(level: 4).or(&lt;h4-end&gt;))\n      .filter(x =&gt; x.location().page() == here().page())\n      .dedup(key: x =&gt; id(x))\n    if pars.len() == 0 {\n      // No paragraph starting or ending on this page\n      // -&gt; check if a paragraph starts before and ends after this page\n      let prev = query(heading.where(level: 4).before(here()))\n      let next = query(selector(&lt;h4-end&gt;).after(here()))\n      if prev.len() == 0 or next.len() == 0 {\n        return none\n      }\n      if prev.last().body != next.first().value {\n        return none\n      }\n      return chap-id(prev.last())\n    }\n    if pars.len() == 1 {\n      return chap-id(pars.first())\n    }\n    return [#chap-id(pars.first()) -- #chap-id(pars.last())]\n  },\n)\n\n#show heading.where(level: 4): it =&gt; it.body + h(1em)\n\n#let my-par(id: none, body) = {\n  parbreak()\n  if id != none {\n    heading(level: 4, id)\n  }\n  body\n  box[#metadata([#id])&lt;h4-end&gt;]\n}\n\n#let my-h1(short: none, ..args) = {\n  heading(level: 1, ..args)\n  [#metadata(short)&lt;h1-short&gt;]\n}\n\n#my-h1(short: \"A-Chapter\")[This is Chapter A]\n#my-par(id: \"1\", lorem(50))\n#my-par(id: \"2\", lorem(20))\n#my-par(id: \"3\", lorem(150))\n\n#my-h1(short: \"B-Chapter\")[This is Chapter B]\n#my-par(id: \"11\", lorem(50))\n#my-par(id: \"12\", lorem(20))\n\n#my-h1(short: \"C-Chapter\")[This is Chapter C]\n#my-par(id: \"21a\", lorem(150))\n</code></pre>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://forum.typst.app/uploads/default/original/2X/a/a433acff88df3cd0e913697117ff7f65f4b47238.png\" data-download-href=\"https://forum.typst.app/uploads/default/a433acff88df3cd0e913697117ff7f65f4b47238\" title=\"image\"><img src=\"https://forum.typst.app/uploads/default/optimized/2X/a/a433acff88df3cd0e913697117ff7f65f4b47238_2_690x459.png\" alt=\"image\" data-base62-sha1=\"nqB1ePYnbxwZTlyk6XqAtPbcuPS\" width=\"690\" height=\"459\" srcset=\"https://forum.typst.app/uploads/default/optimized/2X/a/a433acff88df3cd0e913697117ff7f65f4b47238_2_690x459.png, https://forum.typst.app/uploads/default/optimized/2X/a/a433acff88df3cd0e913697117ff7f65f4b47238_2_1035x688.png 1.5x, https://forum.typst.app/uploads/default/optimized/2X/a/a433acff88df3cd0e913697117ff7f65f4b47238_2_1380x918.png 2x\" data-dominant-color=\"F0F0F0\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">image</span><span class=\"informations\">1818×1210 418 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>You might want to do something smarter when the first and last paragraph on a page are in the same chapter, rather than showing the same short title twice…</p>",
      "raw": "The supplement thing is rather hacky, it could cause problems with outlines or references. So I'd rather use a custom heading command that adds \"short title\" metadata that can be retrieved in the header:\n\n```typ\n#set page(\n  width: 100mm,\n  height: 100mm,\n  header: context {\n    let id(x) = if x.func() == heading { x.body } else { x.value }\n    // Returns content showing short chapter title and paragraph number\n    let chap-id(x) = {\n      let shorts = query(selector(<h1-short>).before(x.location()))\n      if shorts.len() == 0 {\n        id(x)\n      } else [\n        #shorts.last().value: #id(x)\n      ]\n    }\n    let pars = query(heading.where(level: 4).or(<h4-end>))\n      .filter(x => x.location().page() == here().page())\n      .dedup(key: x => id(x))\n    if pars.len() == 0 {\n      // No paragraph starting or ending on this page\n      // -> check if a paragraph starts before and ends after this page\n      let prev = query(heading.where(level: 4).before(here()))\n      let next = query(selector(<h4-end>).after(here()))\n      if prev.len() == 0 or next.len() == 0 {\n        return none\n      }\n      if prev.last().body != next.first().value {\n        return none\n      }\n      return chap-id(prev.last())\n    }\n    if pars.len() == 1 {\n      return chap-id(pars.first())\n    }\n    return [#chap-id(pars.first()) -- #chap-id(pars.last())]\n  },\n)\n\n#show heading.where(level: 4): it => it.body + h(1em)\n\n#let my-par(id: none, body) = {\n  parbreak()\n  if id != none {\n    heading(level: 4, id)\n  }\n  body\n  box[#metadata([#id])<h4-end>]\n}\n\n#let my-h1(short: none, ..args) = {\n  heading(level: 1, ..args)\n  [#metadata(short)<h1-short>]\n}\n\n#my-h1(short: \"A-Chapter\")[This is Chapter A]\n#my-par(id: \"1\", lorem(50))\n#my-par(id: \"2\", lorem(20))\n#my-par(id: \"3\", lorem(150))\n\n#my-h1(short: \"B-Chapter\")[This is Chapter B]\n#my-par(id: \"11\", lorem(50))\n#my-par(id: \"12\", lorem(20))\n\n#my-h1(short: \"C-Chapter\")[This is Chapter C]\n#my-par(id: \"21a\", lorem(150))\n```\n\n![image|690x459](upload://nqB1ePYnbxwZTlyk6XqAtPbcuPS.png)\n\n\nYou might want to do something smarter when the first and last paragraph on a page are in the same chapter, rather than showing the same short title twice...",
      "reply_to_post_number": 4,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 0,
      "reads": 33,
      "score": 26.6,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 332
    },
    {
      "id": 10453,
      "post_number": 7,
      "username": "a_w",
      "name": "Alex",
      "created_at": "2025-03-31T09:49:20.608Z",
      "updated_at": "2025-03-31T09:52:36.742Z",
      "cooked": "<p><a class=\"mention\" href=\"/u/sijo\">@sijo</a> this is so helpful, thank you very much! I just tried actually implementing it and I think I ran into one edge case: When two chapters end up on the same page, it looks like this:</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://forum.typst.app/uploads/default/original/2X/5/51545477553683f6a981f1e767865cdad0f3652d.jpeg\" data-download-href=\"https://forum.typst.app/uploads/default/51545477553683f6a981f1e767865cdad0f3652d\" title=\"two-chaps\"><img src=\"https://forum.typst.app/uploads/default/optimized/2X/5/51545477553683f6a981f1e767865cdad0f3652d_2_342x499.jpeg\" alt=\"two-chaps\" data-base62-sha1=\"bBtlLWxjFTspW2ZWoePT0snopl3\" width=\"342\" height=\"499\" srcset=\"https://forum.typst.app/uploads/default/optimized/2X/5/51545477553683f6a981f1e767865cdad0f3652d_2_342x499.jpeg, https://forum.typst.app/uploads/default/optimized/2X/5/51545477553683f6a981f1e767865cdad0f3652d_2_513x748.jpeg 1.5x, https://forum.typst.app/uploads/default/optimized/2X/5/51545477553683f6a981f1e767865cdad0f3652d_2_684x998.jpeg 2x\" data-dominant-color=\"ECECED\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">two-chaps</span><span class=\"informations\">832×1216 170 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div><br>\nInstead of <code>A-Chapter 1 – B-Chapter 1</code></p>\n<p>Even if <code>#shorts.last()</code> should still resolve to <code>B-Chapter</code>? I tried but I couldn’t figure out if it is the query or the access to <code>chap-id</code> that causes this case to fail.</p>\n<p><a class=\"mention\" href=\"/u/andrew\">@Andrew</a> thanks so much for this additional approach, I will play around with the example too because <code>#metadata(none)&lt;par&gt;#it&lt;par&gt;#metadata(none)&lt;par&gt;</code> is a very interesting approach as well… this forum is so great and so humbling – I could never have come up with the idea of a label-wrapper (actually: I could never have come up with ANY of this, but the idea is especially “oh, wow, this is possible?”).</p>",
      "raw": "@sijo this is so helpful, thank you very much! I just tried actually implementing it and I think I ran into one edge case: When two chapters end up on the same page, it looks like this:\n\n![two-chaps|342x499](upload://bBtlLWxjFTspW2ZWoePT0snopl3.jpeg)\nInstead of `A-Chapter 1 – B-Chapter 1`\n\nEven if `#shorts.last()` should still resolve to `B-Chapter`? I tried but I couldn't figure out if it is the query or the access to `chap-id` that causes this case to fail.\n\n@Andrew thanks so much for this additional approach, I will play around with the example too because `#metadata(none)<par>#it<par>#metadata(none)<par>` is a very interesting approach as well… this forum is so great and so humbling – I could never have come up with the idea of a label-wrapper (actually: I could never have come up with ANY of this, but the idea is especially \"oh, wow, this is possible?\").",
      "reply_to_post_number": 6,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 1,
      "reads": 30,
      "score": 26.0,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 566
    },
    {
      "id": 10456,
      "post_number": 8,
      "username": "sijo",
      "name": "",
      "created_at": "2025-03-31T11:11:40.541Z",
      "updated_at": "2025-03-31T11:11:40.541Z",
      "cooked": "<p>Ah that’s because of the <code>dedup</code> call which only checks the id. I’ve refactored the code a bit to avoid that, also using two metadata values per paragraph to simplify the logic:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let get-chap-short(x) = {\n  let shorts = query(selector(&lt;h1-short&gt;).before(x.location()))\n  return shorts.at(-1, default: none)\n}\n\n#let short-and-id(x) = {\n  let short = get-chap-short(x)\n  return (short: short.value, id: x.value)\n}\n\n#let format-header(a, b) = {\n  if b == none or b == a {\n    return [#a.short: #a.id]\n  }\n  if a.short == b.short {\n    return [#a.short: #a.id -- #b.id]\n  }\n  return [#a.short: #a.id -- #b.short: #b.id]\n}\n\n#set page(\n  width: 100mm,\n  height: 100mm,\n  header: context {\n    let pars = query(selector.or(&lt;h4-start&gt;, &lt;h4-end&gt;))\n      .filter(x =&gt; x.location().page() == here().page())\n      .map(short-and-id)\n      .dedup()\n    if pars.len() == 0 {\n      // No paragraph starting or ending on this page\n      // -&gt; check if a paragraph starts before and ends after this page\n      let prevs = query(selector(&lt;h4-start&gt;).before(here()))\n      let nexts = query(selector(&lt;h4-end&gt;).after(here()))\n      if prevs.len() == 0 or nexts.len() == 0 {\n        return none\n      }\n      let prev = short-and-id(prevs.last())\n      let next = short-and-id(nexts.first())\n      if prev != next { // should not happen\n        return none\n      }\n      return format-header(prev, next)\n    }\n    return format-header(pars.first(), pars.at(-1, default: none))\n  },\n)\n\n#show heading.where(level: 4): it =&gt; it.body + h(1em)\n\n#let my-par(id: none, body) = par({\n  [#metadata([#id])&lt;h4-start&gt;]\n  if id != none {\n    heading(level: 4, id)\n  }\n  body\n  [#metadata([#id])&lt;h4-end&gt;]\n})\n\n#let my-h1(short: none, ..args) = {\n  heading(level: 1, ..args)\n  [#metadata(short)&lt;h1-short&gt;]\n}\n\n#my-h1(short: \"A-Chapter\")[This is Chapter A]\n#my-par(id: \"1\", lorem(20))\n#my-par(id: \"2\", lorem(20))\n#my-h1(short: \"B-Chapter\")[This is Chapter B]\n#my-par(id: \"1\", lorem(50))\n#my-par(id: \"2\", lorem(20))\n\n#pagebreak()\n\n#my-h1(short: \"C-Chapter\")[This is Chapter C]\n#my-par(id: \"1\", lorem(20))\n#my-par(id: \"2\", lorem(20))\n#my-par(id: \"3\", lorem(150))\n\n#my-h1(short: \"D-Chapter\")[This is Chapter D]\n#my-par(id: \"11\", lorem(50))\n#my-par(id: \"11a\", lorem(20))\n</code></pre>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://forum.typst.app/uploads/default/original/2X/d/d7cf7537a2a4187eb3cf7b252e7fdb60e2554bdc.png\" data-download-href=\"https://forum.typst.app/uploads/default/d7cf7537a2a4187eb3cf7b252e7fdb60e2554bdc\" title=\"image\"><img src=\"https://forum.typst.app/uploads/default/optimized/2X/d/d7cf7537a2a4187eb3cf7b252e7fdb60e2554bdc_2_690x459.png\" alt=\"image\" data-base62-sha1=\"uN98dJsTY90nJrOOr0V0kPcQKXq\" width=\"690\" height=\"459\" srcset=\"https://forum.typst.app/uploads/default/optimized/2X/d/d7cf7537a2a4187eb3cf7b252e7fdb60e2554bdc_2_690x459.png, https://forum.typst.app/uploads/default/optimized/2X/d/d7cf7537a2a4187eb3cf7b252e7fdb60e2554bdc_2_1035x688.png 1.5x, https://forum.typst.app/uploads/default/optimized/2X/d/d7cf7537a2a4187eb3cf7b252e7fdb60e2554bdc_2_1380x918.png 2x\" data-dominant-color=\"F2F2F2\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">image</span><span class=\"informations\">1430×952 265 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>",
      "raw": "Ah that's because of the `dedup` call which only checks the id. I've refactored the code a bit to avoid that, also using two metadata values per paragraph to simplify the logic:\n\n```typ\n#let get-chap-short(x) = {\n  let shorts = query(selector(<h1-short>).before(x.location()))\n  return shorts.at(-1, default: none)\n}\n\n#let short-and-id(x) = {\n  let short = get-chap-short(x)\n  return (short: short.value, id: x.value)\n}\n\n#let format-header(a, b) = {\n  if b == none or b == a {\n    return [#a.short: #a.id]\n  }\n  if a.short == b.short {\n    return [#a.short: #a.id -- #b.id]\n  }\n  return [#a.short: #a.id -- #b.short: #b.id]\n}\n\n#set page(\n  width: 100mm,\n  height: 100mm,\n  header: context {\n    let pars = query(selector.or(<h4-start>, <h4-end>))\n      .filter(x => x.location().page() == here().page())\n      .map(short-and-id)\n      .dedup()\n    if pars.len() == 0 {\n      // No paragraph starting or ending on this page\n      // -> check if a paragraph starts before and ends after this page\n      let prevs = query(selector(<h4-start>).before(here()))\n      let nexts = query(selector(<h4-end>).after(here()))\n      if prevs.len() == 0 or nexts.len() == 0 {\n        return none\n      }\n      let prev = short-and-id(prevs.last())\n      let next = short-and-id(nexts.first())\n      if prev != next { // should not happen\n        return none\n      }\n      return format-header(prev, next)\n    }\n    return format-header(pars.first(), pars.at(-1, default: none))\n  },\n)\n\n#show heading.where(level: 4): it => it.body + h(1em)\n\n#let my-par(id: none, body) = par({\n  [#metadata([#id])<h4-start>]\n  if id != none {\n    heading(level: 4, id)\n  }\n  body\n  [#metadata([#id])<h4-end>]\n})\n\n#let my-h1(short: none, ..args) = {\n  heading(level: 1, ..args)\n  [#metadata(short)<h1-short>]\n}\n\n#my-h1(short: \"A-Chapter\")[This is Chapter A]\n#my-par(id: \"1\", lorem(20))\n#my-par(id: \"2\", lorem(20))\n#my-h1(short: \"B-Chapter\")[This is Chapter B]\n#my-par(id: \"1\", lorem(50))\n#my-par(id: \"2\", lorem(20))\n\n#pagebreak()\n\n#my-h1(short: \"C-Chapter\")[This is Chapter C]\n#my-par(id: \"1\", lorem(20))\n#my-par(id: \"2\", lorem(20))\n#my-par(id: \"3\", lorem(150))\n\n#my-h1(short: \"D-Chapter\")[This is Chapter D]\n#my-par(id: \"11\", lorem(50))\n#my-par(id: \"11a\", lorem(20))\n```\n\n![image|690x459](upload://uN98dJsTY90nJrOOr0V0kPcQKXq.png)",
      "reply_to_post_number": 7,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 1,
      "reads": 30,
      "score": 116.0,
      "accepted_answer": true,
      "trust_level": 3,
      "user_id": 332
    },
    {
      "id": 10459,
      "post_number": 9,
      "username": "a_w",
      "name": "Alex",
      "created_at": "2025-03-31T13:44:10.527Z",
      "updated_at": "2025-03-31T13:51:40.710Z",
      "cooked": "<p>Again thank you very much for your effort <a class=\"mention\" href=\"/u/sijo\">@sijo</a>, works like a charm <img src=\"https://forum.typst.app/images/emoji/apple/face_holding_back_tears.png?v=12\" title=\":face_holding_back_tears:\" class=\"emoji\" alt=\":face_holding_back_tears:\" loading=\"lazy\" width=\"20\" height=\"20\"><img src=\"https://forum.typst.app/images/emoji/apple/pray.png?v=12\" title=\":pray:\" class=\"emoji\" alt=\":pray:\" loading=\"lazy\" width=\"20\" height=\"20\"> while implementing I noticed that I oversimplied my example by a factor that now plays a role, since the solution is now way different than I anticipated. I actually have <code>Chapter › Subchapter › Paragraph</code> or in other words <code>Section › Chapter › Paragraph</code> I could more or less solve it by going back to the page-based query for the section (“less” because it only works for chapters on new pages, which is ok in my case).</p>\n<p>So basically:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let get-section-short() = {\n  let sections = query(selector(&lt;h1-short&gt;))\n  let s = sections.filter(h =&gt; h.location().page() &lt;= here().page()).last()\n  if s != none {\n    s.value\n  }\n}\n\n#let format-header(a, b) = {\n  if b == none or b == a {\n    return [#get-section-short() --- #a.short: #a.id]\n  }\n  if a.short == b.short {\n    return [#get-section-short() ---  #a.short: #a.id -- #b.id]\n  }\n  return [#get-section-short() --- #a.short: #a.id -- #b.short: #b.id]\n}\n\n// h1 for section, h2 for chapter\n#let my-h1(short: none, ..args) = {\n  heading(level: 1, ..args)\n  [#metadata(short)&lt;h1-short&gt;]\n}\n#let my-h2(short: none, ..args) = {\n  heading(level: 2, ..args)\n  [#metadata(short)&lt;h2-short&gt;]\n}\n</code></pre>\n<details>\n<summary>\nFull Code</summary>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let get-section-short() = {\n  let sections = query(selector(&lt;h1-short&gt;))\n  let s = sections.filter(h =&gt; h.location().page() &lt;= here().page()).last()\n  if s != none {\n    s.value\n  }\n}\n\n#let get-chap-short(x) = {\n  let shorts = query(selector(&lt;h2-short&gt;).before(x.location()))\n  return shorts.at(-1, default: none)\n}\n\n#let short-and-id(x) = {\n  let short = get-chap-short(x)\n  return (short: short.value, id: x.value)\n}\n\n#let format-header(a, b) = {\n  if b == none or b == a {\n    return [#get-section-short() --- #a.short: #a.id]\n  }\n  if a.short == b.short {\n    return [#get-section-short() ---  #a.short: #a.id -- #b.id]\n  }\n  return [#get-section-short() --- #a.short: #a.id -- #b.short: #b.id]\n}\n\n#set page(\n  width: 100mm,\n  height: 100mm,\n  header: context {\n    let pars = query(selector.or(&lt;h4-start&gt;, &lt;h4-end&gt;))\n      .filter(x =&gt; x.location().page() == here().page())\n      .map(short-and-id)\n      .dedup()\n    if pars.len() == 0 {\n      // No paragraph starting or ending on this page\n      // -&gt; check if a paragraph starts before and ends after this page\n      let prevs = query(selector(&lt;h4-start&gt;).before(here()))\n      let nexts = query(selector(&lt;h4-end&gt;).after(here()))\n      if prevs.len() == 0 or nexts.len() == 0 {\n        return none\n      }\n      let prev = short-and-id(prevs.last())\n      let next = short-and-id(nexts.first())\n      if prev != next { // should not happen\n        return none\n      }\n      return format-header(prev, next)\n    }\n    return format-header(pars.first(), pars.at(-1, default: none))\n  },\n)\n\n#show heading.where(level: 4): it =&gt; it.body + h(1em)\n\n#let my-par(id: none, body) = par({\n  [#metadata([#id])&lt;h4-start&gt;]\n  if id != none {\n    heading(level: 4, id)\n  }\n  body\n  [#metadata([#id])&lt;h4-end&gt;]\n})\n\n#let my-h1(short: none, ..args) = {\n  heading(level: 1, ..args)\n  [#metadata(short)&lt;h1-short&gt;]\n}\n#let my-h2(short: none, ..args) = {\n  heading(level: 2, ..args)\n  [#metadata(short)&lt;h2-short&gt;]\n}\n\n#my-h1(short: \"I. Section\")[This is I. Section]\n#my-h2(short: \"A-Chapter\")[This is Chapter A]\n#my-par(id: \"1\", lorem(20))\n#my-par(id: \"2\", lorem(20))\n#my-h2(short: \"B-Chapter\")[This is Chapter B]\n#my-par(id: \"1\", lorem(50))\n#my-par(id: \"2\", lorem(20))\n\n#pagebreak()\n\n#my-h1(short: \"II. Section\")[This is II. Section]\n#my-h2(short: \"C-Chapter\")[This is Chapter C]\n#my-par(id: \"1\", lorem(20))\n#my-par(id: \"2\", lorem(20))\n#my-par(id: \"3\", lorem(150))\n\n#my-h2(short: \"D-Chapter\")[This is Chapter D]\n#my-par(id: \"11\", lorem(50))\n#my-par(id: \"11a\", lorem(20))\n\n#my-h1(short: \"III. Section\")[This is III. Section]\n#my-h2(short: \"E-Chapter\")[This is Chapter E]\n#my-par(id: \"11\", lorem(50))\n#my-par(id: \"11a\", lorem(20))\n</code></pre>\n</details>\n<p>This works ok and fails only in cases where the section doesn’t start on a new page, like so:<br>\n<div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://forum.typst.app/uploads/default/original/2X/3/3f2a2b02efaa8672251986ba394976fa13781948.jpeg\" data-download-href=\"https://forum.typst.app/uploads/default/3f2a2b02efaa8672251986ba394976fa13781948\" title=\"section-chapter\"><img src=\"https://forum.typst.app/uploads/default/optimized/2X/3/3f2a2b02efaa8672251986ba394976fa13781948_2_690x460.jpeg\" alt=\"section-chapter\" data-base62-sha1=\"90MqmqQ5QNzYD7UCobiFoEaDuEU\" width=\"690\" height=\"460\" srcset=\"https://forum.typst.app/uploads/default/optimized/2X/3/3f2a2b02efaa8672251986ba394976fa13781948_2_690x460.jpeg, https://forum.typst.app/uploads/default/optimized/2X/3/3f2a2b02efaa8672251986ba394976fa13781948_2_1035x690.jpeg 1.5x, https://forum.typst.app/uploads/default/optimized/2X/3/3f2a2b02efaa8672251986ba394976fa13781948_2_1380x920.jpeg 2x\" data-dominant-color=\"EDEDED\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">section-chapter</span><span class=\"informations\">1920×1282 234 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>If this requires significant restructuring, I’ll just use the solution as is. But if it’s doable with a reasonable addition to <code>short-and-id()</code> would you mind showing me for peace of mind, please? (Disclaimer: My problems is when I see the double-x-variable-filter.map.depup combination my brain goes into <em>Homer’s brain monkey with cymbals</em> mode.)</p>",
      "raw": "Again thank you very much for your effort @sijo, works like a charm 🥹🙏 while implementing I noticed that I oversimplied my example by a factor that now plays a role, since the solution is now way different than I anticipated. I actually have `Chapter › Subchapter › Paragraph` or in other words `Section › Chapter › Paragraph` I could more or less solve it by going back to the page-based query for the section (\"less\" because it only works for chapters on new pages, which is ok in my case).\n\nSo basically:\n```typ\n#let get-section-short() = {\n  let sections = query(selector(<h1-short>))\n  let s = sections.filter(h => h.location().page() <= here().page()).last()\n  if s != none {\n    s.value\n  }\n}\n\n#let format-header(a, b) = {\n  if b == none or b == a {\n    return [#get-section-short() --- #a.short: #a.id]\n  }\n  if a.short == b.short {\n    return [#get-section-short() ---  #a.short: #a.id -- #b.id]\n  }\n  return [#get-section-short() --- #a.short: #a.id -- #b.short: #b.id]\n}\n\n// h1 for section, h2 for chapter\n#let my-h1(short: none, ..args) = {\n  heading(level: 1, ..args)\n  [#metadata(short)<h1-short>]\n}\n#let my-h2(short: none, ..args) = {\n  heading(level: 2, ..args)\n  [#metadata(short)<h2-short>]\n}\n```\n\n[details=\"Full Code\"]\n```typ\n#let get-section-short() = {\n  let sections = query(selector(<h1-short>))\n  let s = sections.filter(h => h.location().page() <= here().page()).last()\n  if s != none {\n    s.value\n  }\n}\n\n#let get-chap-short(x) = {\n  let shorts = query(selector(<h2-short>).before(x.location()))\n  return shorts.at(-1, default: none)\n}\n\n#let short-and-id(x) = {\n  let short = get-chap-short(x)\n  return (short: short.value, id: x.value)\n}\n\n#let format-header(a, b) = {\n  if b == none or b == a {\n    return [#get-section-short() --- #a.short: #a.id]\n  }\n  if a.short == b.short {\n    return [#get-section-short() ---  #a.short: #a.id -- #b.id]\n  }\n  return [#get-section-short() --- #a.short: #a.id -- #b.short: #b.id]\n}\n\n#set page(\n  width: 100mm,\n  height: 100mm,\n  header: context {\n    let pars = query(selector.or(<h4-start>, <h4-end>))\n      .filter(x => x.location().page() == here().page())\n      .map(short-and-id)\n      .dedup()\n    if pars.len() == 0 {\n      // No paragraph starting or ending on this page\n      // -> check if a paragraph starts before and ends after this page\n      let prevs = query(selector(<h4-start>).before(here()))\n      let nexts = query(selector(<h4-end>).after(here()))\n      if prevs.len() == 0 or nexts.len() == 0 {\n        return none\n      }\n      let prev = short-and-id(prevs.last())\n      let next = short-and-id(nexts.first())\n      if prev != next { // should not happen\n        return none\n      }\n      return format-header(prev, next)\n    }\n    return format-header(pars.first(), pars.at(-1, default: none))\n  },\n)\n\n#show heading.where(level: 4): it => it.body + h(1em)\n\n#let my-par(id: none, body) = par({\n  [#metadata([#id])<h4-start>]\n  if id != none {\n    heading(level: 4, id)\n  }\n  body\n  [#metadata([#id])<h4-end>]\n})\n\n#let my-h1(short: none, ..args) = {\n  heading(level: 1, ..args)\n  [#metadata(short)<h1-short>]\n}\n#let my-h2(short: none, ..args) = {\n  heading(level: 2, ..args)\n  [#metadata(short)<h2-short>]\n}\n\n#my-h1(short: \"I. Section\")[This is I. Section]\n#my-h2(short: \"A-Chapter\")[This is Chapter A]\n#my-par(id: \"1\", lorem(20))\n#my-par(id: \"2\", lorem(20))\n#my-h2(short: \"B-Chapter\")[This is Chapter B]\n#my-par(id: \"1\", lorem(50))\n#my-par(id: \"2\", lorem(20))\n\n#pagebreak()\n\n#my-h1(short: \"II. Section\")[This is II. Section]\n#my-h2(short: \"C-Chapter\")[This is Chapter C]\n#my-par(id: \"1\", lorem(20))\n#my-par(id: \"2\", lorem(20))\n#my-par(id: \"3\", lorem(150))\n\n#my-h2(short: \"D-Chapter\")[This is Chapter D]\n#my-par(id: \"11\", lorem(50))\n#my-par(id: \"11a\", lorem(20))\n\n#my-h1(short: \"III. Section\")[This is III. Section]\n#my-h2(short: \"E-Chapter\")[This is Chapter E]\n#my-par(id: \"11\", lorem(50))\n#my-par(id: \"11a\", lorem(20))\n```\n[/details]\n\nThis works ok and fails only in cases where the section doesn't start on a new page, like so:\n![section-chapter|690x460](upload://90MqmqQ5QNzYD7UCobiFoEaDuEU.jpeg)\n\nIf this requires significant restructuring, I'll just use the solution as is. But if it's doable with a reasonable addition to `short-and-id()` would you mind showing me for peace of mind, please? (Disclaimer: My problems is when I see the double-x-variable-filter.map.depup combination my brain goes into *Homer's brain monkey with cymbals* mode.)",
      "reply_to_post_number": 8,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 0,
      "reads": 28,
      "score": 10.6,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 566
    },
    {
      "id": 10462,
      "post_number": 10,
      "username": "sijo",
      "name": "",
      "created_at": "2025-03-31T14:21:20.759Z",
      "updated_at": "2025-03-31T14:21:20.759Z",
      "cooked": "<p>I think the proper fix is to change <code>short-and-id</code> to include the section short:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let get-short(label, x) = {\n  let shorts = query(selector(label).before(x.location()))\n  return shorts.at(-1, default: none)\n}\n\n#let shorts-and-id(x) = {\n  let h1 = get-short(&lt;h1-short&gt;, x)\n  let h2 = get-short(&lt;h2-short&gt;, x)\n  return (h1: h1.value, h2: h2.value, id: x.value)\n}\n\n#let header-content(a, b) = {\n  if b == none or b == a {\n    return [#a.h1: #a.h2: #a.id]\n  }\n  if a.h1 == b.h1 {\n    if a.h2 == b.h2 {\n      return [#a.h1: #a.h2: #a.id -- #b.id]\n    }\n    return [#a.h1: #a.h2: #a.id -- #b.h2: #b.id]\n  }\n  return [#a.h1: #a.h2: #a.id -- #b.h1: #b.h2: #b.id]\n}\n\n#let format-header(a, b) = {\n  set text(0.8em)\n  header-content(a, b)\n}\n\n#set page(\n  width: 100mm,\n  height: 100mm,\n  header: context {\n    let pars = query(selector.or(&lt;h4-start&gt;, &lt;h4-end&gt;))\n      .filter(x =&gt; x.location().page() == here().page())\n      .map(shorts-and-id)\n    if pars.len() == 0 {\n      // No paragraph starting or ending on this page\n      // -&gt; check if a paragraph starts before and ends after this page\n      let prevs = query(selector(&lt;h4-start&gt;).before(here()))\n      let nexts = query(selector(&lt;h4-end&gt;).after(here()))\n      if prevs.len() == 0 or nexts.len() == 0 {\n        return none\n      }\n      let prev = shorts-and-id(prevs.last())\n      let next = shorts-and-id(nexts.first())\n      if prev != next { // should not happen\n        return none\n      }\n      return format-header(prev, next)\n    }\n    return format-header(pars.first(), pars.at(-1, default: none))\n  },\n)\n\n#show heading.where(level: 4): it =&gt; it.body + h(1em)\n\n#let my-par(id: none, body) = par({\n  [#metadata([#id])&lt;h4-start&gt;]\n  if id != none {\n    heading(level: 4, id)\n  }\n  body\n  [#metadata([#id])&lt;h4-end&gt;]\n})\n\n#let my-h1(short: none, ..args) = {\n  heading(level: 1, ..args)\n  [#metadata(short)&lt;h1-short&gt;]\n}\n#let my-h2(short: none, ..args) = {\n  heading(level: 2, ..args)\n  [#metadata(short)&lt;h2-short&gt;]\n}\n\n#my-h1(short: \"I. Section\")[This is I. Section]\n#my-h2(short: \"A-Chapter\")[This is Chapter A]\n#my-par(id: \"1\", lorem(20))\n#my-par(id: \"2\", lorem(20))\n#my-h2(short: \"B-Chapter\")[This is Chapter B]\n#my-par(id: \"1\", lorem(50))\n#my-par(id: \"2\", lorem(20))\n\n#pagebreak()\n\n#my-h1(short: \"II. Section\")[This is II. Section]\n#my-h2(short: \"C-Chapter\")[This is Chapter C]\n#my-par(id: \"1\", lorem(20))\n#my-par(id: \"2\", lorem(20))\n#my-par(id: \"3\", lorem(150))\n\n#my-h2(short: \"D-Chapter\")[This is Chapter D]\n#my-par(id: \"11\", lorem(50))\n#my-par(id: \"11a\", lorem(20))\n\n#my-h1(short: \"III. Section\")[This is III. Section]\n#my-h2(short: \"E-Chapter\")[This is Chapter E]\n#my-par(id: \"11\", lorem(20))\n</code></pre>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://forum.typst.app/uploads/default/original/2X/6/6a40de2b200c6dd876a8d172e51c14c3817a8ccd.png\" data-download-href=\"https://forum.typst.app/uploads/default/6a40de2b200c6dd876a8d172e51c14c3817a8ccd\" title=\"image\"><img src=\"https://forum.typst.app/uploads/default/optimized/2X/6/6a40de2b200c6dd876a8d172e51c14c3817a8ccd_2_690x459.png\" alt=\"image\" data-base62-sha1=\"f9XACd6LRFYHiyqHgoGUpNlAgWN\" width=\"690\" height=\"459\" srcset=\"https://forum.typst.app/uploads/default/optimized/2X/6/6a40de2b200c6dd876a8d172e51c14c3817a8ccd_2_690x459.png, https://forum.typst.app/uploads/default/optimized/2X/6/6a40de2b200c6dd876a8d172e51c14c3817a8ccd_2_1035x688.png 1.5x, https://forum.typst.app/uploads/default/optimized/2X/6/6a40de2b200c6dd876a8d172e51c14c3817a8ccd_2_1380x918.png 2x\" data-dominant-color=\"F1F1F1\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">image</span><span class=\"informations\">1432×954 286 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>",
      "raw": "I think the proper fix is to change `short-and-id` to include the section short:\n\n```typ\n#let get-short(label, x) = {\n  let shorts = query(selector(label).before(x.location()))\n  return shorts.at(-1, default: none)\n}\n\n#let shorts-and-id(x) = {\n  let h1 = get-short(<h1-short>, x)\n  let h2 = get-short(<h2-short>, x)\n  return (h1: h1.value, h2: h2.value, id: x.value)\n}\n\n#let header-content(a, b) = {\n  if b == none or b == a {\n    return [#a.h1: #a.h2: #a.id]\n  }\n  if a.h1 == b.h1 {\n    if a.h2 == b.h2 {\n      return [#a.h1: #a.h2: #a.id -- #b.id]\n    }\n    return [#a.h1: #a.h2: #a.id -- #b.h2: #b.id]\n  }\n  return [#a.h1: #a.h2: #a.id -- #b.h1: #b.h2: #b.id]\n}\n\n#let format-header(a, b) = {\n  set text(0.8em)\n  header-content(a, b)\n}\n\n#set page(\n  width: 100mm,\n  height: 100mm,\n  header: context {\n    let pars = query(selector.or(<h4-start>, <h4-end>))\n      .filter(x => x.location().page() == here().page())\n      .map(shorts-and-id)\n    if pars.len() == 0 {\n      // No paragraph starting or ending on this page\n      // -> check if a paragraph starts before and ends after this page\n      let prevs = query(selector(<h4-start>).before(here()))\n      let nexts = query(selector(<h4-end>).after(here()))\n      if prevs.len() == 0 or nexts.len() == 0 {\n        return none\n      }\n      let prev = shorts-and-id(prevs.last())\n      let next = shorts-and-id(nexts.first())\n      if prev != next { // should not happen\n        return none\n      }\n      return format-header(prev, next)\n    }\n    return format-header(pars.first(), pars.at(-1, default: none))\n  },\n)\n\n#show heading.where(level: 4): it => it.body + h(1em)\n\n#let my-par(id: none, body) = par({\n  [#metadata([#id])<h4-start>]\n  if id != none {\n    heading(level: 4, id)\n  }\n  body\n  [#metadata([#id])<h4-end>]\n})\n\n#let my-h1(short: none, ..args) = {\n  heading(level: 1, ..args)\n  [#metadata(short)<h1-short>]\n}\n#let my-h2(short: none, ..args) = {\n  heading(level: 2, ..args)\n  [#metadata(short)<h2-short>]\n}\n\n#my-h1(short: \"I. Section\")[This is I. Section]\n#my-h2(short: \"A-Chapter\")[This is Chapter A]\n#my-par(id: \"1\", lorem(20))\n#my-par(id: \"2\", lorem(20))\n#my-h2(short: \"B-Chapter\")[This is Chapter B]\n#my-par(id: \"1\", lorem(50))\n#my-par(id: \"2\", lorem(20))\n\n#pagebreak()\n\n#my-h1(short: \"II. Section\")[This is II. Section]\n#my-h2(short: \"C-Chapter\")[This is Chapter C]\n#my-par(id: \"1\", lorem(20))\n#my-par(id: \"2\", lorem(20))\n#my-par(id: \"3\", lorem(150))\n\n#my-h2(short: \"D-Chapter\")[This is Chapter D]\n#my-par(id: \"11\", lorem(50))\n#my-par(id: \"11a\", lorem(20))\n\n#my-h1(short: \"III. Section\")[This is III. Section]\n#my-h2(short: \"E-Chapter\")[This is Chapter E]\n#my-par(id: \"11\", lorem(20))\n```\n\n![image|690x459](upload://f9XACd6LRFYHiyqHgoGUpNlAgWN.png)",
      "reply_to_post_number": 9,
      "reply_count": 2,
      "quote_count": 0,
      "like_count": 1,
      "reads": 28,
      "score": 30.6,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 332
    },
    {
      "id": 10466,
      "post_number": 11,
      "username": "a_w",
      "name": "Alex",
      "created_at": "2025-03-31T16:50:54.622Z",
      "updated_at": "2025-03-31T16:55:50.829Z",
      "cooked": "<p>Looks really good now and the exceptions are way more maintainable. Thank you for taking the time to even refactor the approach! <img src=\"https://forum.typst.app/images/emoji/apple/pray.png?v=12\" title=\":pray:\" class=\"emoji\" alt=\":pray:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>\n<p>Of course I managed to overlook two more edge cases <img src=\"https://forum.typst.app/images/emoji/apple/man_facepalming.png?v=12\" title=\":man_facepalming:\" class=\"emoji\" alt=\":man_facepalming:\" loading=\"lazy\" width=\"20\" height=\"20\"> but I’ve tried to catch them as good as I could… just–again–not very elegantly: I have chapters that contain no numbered paragraphs like the preface and text-only chapters in between as well.</p>\n<p>I tried to catch them like this:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">// Preface case\n// Get last section headline\n      if prevs.len() == 0 or nexts.len() == 0 {\n        return query(selector(&lt;h1-short&gt;)).filter(x =&gt; x.location().page() &lt;= here().page()).last().value\n      }\n\n// In-between case\n// Get last section + chapter headline\n      if prev != next { // should not happen\n        return query(selector(&lt;h1-short&gt;)).filter(x =&gt; x.location().page() &lt;= here().page()).last().value + \" \" + query(selector(&lt;h2-short&gt;)).filter(x =&gt; x.location().page() &lt;= here().page()).last().value\n      }\n\n// Split exceptions in header-content\n  if b == none {\n    return [#a.h1: #a.h2] //to leave wrong ID away\n  }\n  if b == a {\n    return [#a.h1: #a.h2: #a.id]\n  }\n</code></pre>\n<details>\n<summary>\nFull Code</summary>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let get-short(label, x) = {\n  let shorts = query(selector(label).before(x.location()))\n  return shorts.at(-1, default: none)\n}\n\n#let shorts-and-id(x) = {\n  let h1 = get-short(&lt;h1-short&gt;, x)\n  let h2 = get-short(&lt;h2-short&gt;, x)\n  return (h1: h1.value, h2: h2.value, id: x.value)\n}\n\n#let header-content(a, b) = {\n  if b == none {\n    return [#a.h1: #a.h2]\n  }\n  if b == a {\n    return [#a.h1: #a.h2: #a.id]\n  }\n  if a.h1 == b.h1 {\n    if a.h2 == b.h2 {\n      return [#a.h1: #a.h2: #a.id -- #b.id]\n    }\n    return [#a.h1: #a.h2: #a.id -- #b.h2: #b.id]\n  }\n  return [#a.h1: #a.h2: #a.id -- #b.h1: #b.h2: #b.id]\n}\n\n#set page(\n  width: 100mm,\n  height: 100mm,\n  header: context {\n    let pars = query(selector.or(&lt;h4-start&gt;, &lt;h4-end&gt;))\n      .filter(x =&gt; x.location().page() == here().page())\n      .map(shorts-and-id)\n      .dedup()\n    if pars.len() == 0 {\n      // No paragraph starting or ending on this page\n      // -&gt; check if a paragraph starts before and ends after this page\n      let prevs = query(selector(&lt;h4-start&gt;).before(here()))\n      let nexts = query(selector(&lt;h4-end&gt;).after(here()))\n      if prevs.len() == 0 or nexts.len() == 0 {\n        return query(selector(&lt;h1-short&gt;)).filter(x =&gt; x.location().page() &lt;= here().page()).last().value\n      }\n      let prev = shorts-and-id(prevs.last())\n      let next = shorts-and-id(nexts.first())\n      if prev != next { // should not happen\n        return query(selector(&lt;h1-short&gt;)).filter(x =&gt; x.location().page() &lt;= here().page()).last().value + \" \" + query(selector(&lt;h2-short&gt;)).filter(x =&gt; x.location().page() &lt;= here().page()).last().value\n      }\n      return header-content(prev, next)\n    }\n    return header-content(pars.first(), pars.at(-1, default: none))\n  },\n)\n\n#show heading.where(level: 4): it =&gt; it.body + h(1em)\n\n#let my-par(id: none, body) = par({\n  [#metadata([#id])&lt;h4-start&gt;]\n  if id != none {\n    heading(level: 4, id)\n  }\n  body\n  [#metadata([#id])&lt;h4-end&gt;]\n})\n\n#let my-h1(short: none, ..args) = {\n  heading(level: 1, ..args)\n  [#metadata(short)&lt;h1-short&gt;]\n}\n#let my-h2(short: none, ..args) = {\n  heading(level: 2, ..args)\n  [#metadata(short)&lt;h2-short&gt;]\n}\n\n#my-h1(short: \"Preface\")[Preface]\nPreface content #lorem(50)\n#pagebreak()\n\n#my-h1(short: \"I. Section\")[This is I. Section]\n#my-h2(short: \"A-Chapter\")[This is Chapter A]\n#my-par(id: \"1\", lorem(20))\n#my-par(id: \"2\", lorem(20))\n#my-h2(short: \"B-Chapter\")[This is Chapter B]\n#my-par(id: \"1\", lorem(50))\n#my-par(id: \"2\", lorem(20))\n\n#pagebreak()\n\n#my-h1(short: \"II. Section\")[This is II. Section]\n#my-h2(short: \"C-Chapter\")[This is Chapter C]\n#my-par(id: \"1\", lorem(20))\n#my-par(id: \"2\", lorem(20))\n#my-par(id: \"3\", lorem(150))\n\n#my-h2(short: \"D-Chapter\")[This is Chapter D]\n#my-par(id: \"11\", lorem(50))\n#my-par(id: \"11a\", lorem(20))\n\n#my-h1(short: \"III. Section\")[This is III. Section]\n#my-h2(short: \"E-Chapter\")[This is Chapter E]\n#my-par(id: \"11\", lorem(50))\n#my-par(id: \"11a\", lorem(20))\n\n#my-h2(short: \"F-Chapter\")[This is Chapter F]\nRegular Content #lorem(200)\n\n#my-h2(short: \"G-Chapter\")[This is Chapter G]\nRegular Content #lorem(100)\n\n#my-h2(short: \"H-Chapter\")[This is Chapter H]\n#my-par(id: \"1\", lorem(50))\n#my-par(id: \"2\", lorem(20))\n</code></pre>\n</details>\n<p>Resulting in:<br>\n<div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://forum.typst.app/uploads/default/original/2X/3/313b4a82e56985279ca2bf8d90dafc0405cf5bf0.jpeg\" data-download-href=\"https://forum.typst.app/uploads/default/313b4a82e56985279ca2bf8d90dafc0405cf5bf0\" title=\"should-not-happen\"><img src=\"https://forum.typst.app/uploads/default/optimized/2X/3/313b4a82e56985279ca2bf8d90dafc0405cf5bf0_2_665x500.jpeg\" alt=\"should-not-happen\" data-base62-sha1=\"71wqrHCvV7WYDbs41uZJcksaWre\" width=\"665\" height=\"500\" srcset=\"https://forum.typst.app/uploads/default/optimized/2X/3/313b4a82e56985279ca2bf8d90dafc0405cf5bf0_2_665x500.jpeg, https://forum.typst.app/uploads/default/optimized/2X/3/313b4a82e56985279ca2bf8d90dafc0405cf5bf0_2_997x750.jpeg 1.5x, https://forum.typst.app/uploads/default/optimized/2X/3/313b4a82e56985279ca2bf8d90dafc0405cf5bf0_2_1330x1000.jpeg 2x\" data-dominant-color=\"EBEBEB\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">should-not-happen</span><span class=\"informations\">1920×1442 334 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>It’s probably not a very “clean” solution. This is for learning purposes only now and I’m sorry to keep bothering you, but if I may: How would you have solved this? (I’m quite confident this is the last issue I have with this, since it basically works already thanks to your help!)</p>",
      "raw": "Looks really good now and the exceptions are way more maintainable. Thank you for taking the time to even refactor the approach! 🙏\n\nOf course I managed to overlook two more edge cases 🤦‍♂️ but I've tried to catch them as good as I could… just–again–not very elegantly: I have chapters that contain no numbered paragraphs like the preface and text-only chapters in between as well.\n\nI tried to catch them like this:\n```typ\n// Preface case\n// Get last section headline\n      if prevs.len() == 0 or nexts.len() == 0 {\n        return query(selector(<h1-short>)).filter(x => x.location().page() <= here().page()).last().value\n      }\n\n// In-between case\n// Get last section + chapter headline\n      if prev != next { // should not happen\n        return query(selector(<h1-short>)).filter(x => x.location().page() <= here().page()).last().value + \" \" + query(selector(<h2-short>)).filter(x => x.location().page() <= here().page()).last().value\n      }\n\n// Split exceptions in header-content\n  if b == none {\n    return [#a.h1: #a.h2] //to leave wrong ID away\n  }\n  if b == a {\n    return [#a.h1: #a.h2: #a.id]\n  }\n```\n\n[details=\"Full Code\"]\n```typ\n#let get-short(label, x) = {\n  let shorts = query(selector(label).before(x.location()))\n  return shorts.at(-1, default: none)\n}\n\n#let shorts-and-id(x) = {\n  let h1 = get-short(<h1-short>, x)\n  let h2 = get-short(<h2-short>, x)\n  return (h1: h1.value, h2: h2.value, id: x.value)\n}\n\n#let header-content(a, b) = {\n  if b == none {\n    return [#a.h1: #a.h2]\n  }\n  if b == a {\n    return [#a.h1: #a.h2: #a.id]\n  }\n  if a.h1 == b.h1 {\n    if a.h2 == b.h2 {\n      return [#a.h1: #a.h2: #a.id -- #b.id]\n    }\n    return [#a.h1: #a.h2: #a.id -- #b.h2: #b.id]\n  }\n  return [#a.h1: #a.h2: #a.id -- #b.h1: #b.h2: #b.id]\n}\n\n#set page(\n  width: 100mm,\n  height: 100mm,\n  header: context {\n    let pars = query(selector.or(<h4-start>, <h4-end>))\n      .filter(x => x.location().page() == here().page())\n      .map(shorts-and-id)\n      .dedup()\n    if pars.len() == 0 {\n      // No paragraph starting or ending on this page\n      // -> check if a paragraph starts before and ends after this page\n      let prevs = query(selector(<h4-start>).before(here()))\n      let nexts = query(selector(<h4-end>).after(here()))\n      if prevs.len() == 0 or nexts.len() == 0 {\n        return query(selector(<h1-short>)).filter(x => x.location().page() <= here().page()).last().value\n      }\n      let prev = shorts-and-id(prevs.last())\n      let next = shorts-and-id(nexts.first())\n      if prev != next { // should not happen\n        return query(selector(<h1-short>)).filter(x => x.location().page() <= here().page()).last().value + \" \" + query(selector(<h2-short>)).filter(x => x.location().page() <= here().page()).last().value\n      }\n      return header-content(prev, next)\n    }\n    return header-content(pars.first(), pars.at(-1, default: none))\n  },\n)\n\n#show heading.where(level: 4): it => it.body + h(1em)\n\n#let my-par(id: none, body) = par({\n  [#metadata([#id])<h4-start>]\n  if id != none {\n    heading(level: 4, id)\n  }\n  body\n  [#metadata([#id])<h4-end>]\n})\n\n#let my-h1(short: none, ..args) = {\n  heading(level: 1, ..args)\n  [#metadata(short)<h1-short>]\n}\n#let my-h2(short: none, ..args) = {\n  heading(level: 2, ..args)\n  [#metadata(short)<h2-short>]\n}\n\n#my-h1(short: \"Preface\")[Preface]\nPreface content #lorem(50)\n#pagebreak()\n\n#my-h1(short: \"I. Section\")[This is I. Section]\n#my-h2(short: \"A-Chapter\")[This is Chapter A]\n#my-par(id: \"1\", lorem(20))\n#my-par(id: \"2\", lorem(20))\n#my-h2(short: \"B-Chapter\")[This is Chapter B]\n#my-par(id: \"1\", lorem(50))\n#my-par(id: \"2\", lorem(20))\n\n#pagebreak()\n\n#my-h1(short: \"II. Section\")[This is II. Section]\n#my-h2(short: \"C-Chapter\")[This is Chapter C]\n#my-par(id: \"1\", lorem(20))\n#my-par(id: \"2\", lorem(20))\n#my-par(id: \"3\", lorem(150))\n\n#my-h2(short: \"D-Chapter\")[This is Chapter D]\n#my-par(id: \"11\", lorem(50))\n#my-par(id: \"11a\", lorem(20))\n\n#my-h1(short: \"III. Section\")[This is III. Section]\n#my-h2(short: \"E-Chapter\")[This is Chapter E]\n#my-par(id: \"11\", lorem(50))\n#my-par(id: \"11a\", lorem(20))\n\n#my-h2(short: \"F-Chapter\")[This is Chapter F]\nRegular Content #lorem(200)\n\n#my-h2(short: \"G-Chapter\")[This is Chapter G]\nRegular Content #lorem(100)\n\n#my-h2(short: \"H-Chapter\")[This is Chapter H]\n#my-par(id: \"1\", lorem(50))\n#my-par(id: \"2\", lorem(20))\n```\n[/details]\n\n\nResulting in:\n![should-not-happen|665x500](upload://71wqrHCvV7WYDbs41uZJcksaWre.jpeg)\n\nIt's probably not a very \"clean\" solution. This is for learning purposes only now and I'm sorry to keep bothering you, but if I may: How would you have solved this? (I'm quite confident this is the last issue I have with this, since it basically works already thanks to your help!)",
      "reply_to_post_number": 10,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 25,
      "score": 5.0,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 566
    },
    {
      "id": 10596,
      "post_number": 12,
      "username": "a_w",
      "name": "Alex",
      "created_at": "2025-04-03T13:48:00.337Z",
      "updated_at": "2025-04-03T13:56:07.426Z",
      "cooked": "<p>After happily thinking that I’ve successfully implemented the solution, I ran into (or created) one more edge case: In my real-world example, the paragraphs are inline, so:</p>\n<pre data-code-wrap=\"txt\"><code class=\"lang-txt\">1. First paragraph 2. Second one\n</code></pre>\n<p>instead of</p>\n<pre data-code-wrap=\"txt\"><code class=\"lang-txt\">1. First paragraph\n2. Second one\n</code></pre>\n<p>It didn’t recognize it at first because it only creates a problem when the last “paragraph” (which is <code>text()</code>) doesn’t flow onto the next page. (Disclaimer: I’m not even sure I fully get the problem). But the case looks like so:</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://forum.typst.app/uploads/default/original/2X/f/f0c08584deb9166a4f92184ed8f17cfa8801ede7.png\" data-download-href=\"https://forum.typst.app/uploads/default/f0c08584deb9166a4f92184ed8f17cfa8801ede7\" title=\"text-problem\"><img src=\"https://forum.typst.app/uploads/default/optimized/2X/f/f0c08584deb9166a4f92184ed8f17cfa8801ede7_2_690x233.png\" alt=\"text-problem\" data-base62-sha1=\"ylN4f6lqk0wuI2pWS9frajmkNUP\" width=\"690\" height=\"233\" srcset=\"https://forum.typst.app/uploads/default/optimized/2X/f/f0c08584deb9166a4f92184ed8f17cfa8801ede7_2_690x233.png, https://forum.typst.app/uploads/default/optimized/2X/f/f0c08584deb9166a4f92184ed8f17cfa8801ede7_2_1035x349.png 1.5x, https://forum.typst.app/uploads/default/optimized/2X/f/f0c08584deb9166a4f92184ed8f17cfa8801ede7_2_1380x466.png 2x\" data-dominant-color=\"EEEEEE\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">text-problem</span><span class=\"informations\">2344×792 291 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>Can I adapt the prev/next query or adapt the element while keeping it “inline” to get this case right?</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">let prevs = query(selector(&lt;h4-start&gt;).before(here()))\nlet nexts = query(selector(&lt;h4-end&gt;).after(here()))\n\n#let my-par(id: none, body) = text({\n  [#metadata([#id])&lt;h4-start&gt;]\n  if id != none {\n    heading(level: 4, id)\n  }\n  body\n  [#metadata([#id])&lt;h4-end&gt;]\n  // hide(\"​\") // ← 🥴 Uncomment to fix the issue\n})\n</code></pre>\n<p><strong>The best fix I was able to come up with is to end a zero-width space at the end</strong> of my paragraph. But I’d like to understand the problem and maybe fix it in a non-hacky way if possible.</p>\n<details>\n<summary>\nFull Code Example</summary>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let get-short(label, x) = {\n  let shorts = query(selector(label).before(x.location()))\n  return shorts.at(-1, default: none)\n}\n\n#let shorts-and-id(x) = {\n  let h1 = get-short(&lt;h1-short&gt;, x)\n  let h2 = get-short(&lt;h2-short&gt;, x)\n  return (h1: h1.value, h2: h2.value, id: x.value)\n}\n\n#let header-content(a, b) = {\n  if b == none {\n    return [#a.h1: #a.h2]\n  }\n  if b == a {\n    return [#a.h1: #a.h2: #a.id]\n  }\n  if a.h1 == b.h1 {\n    if a.h2 == b.h2 {\n      return [#a.h1: #a.h2: #a.id -- #b.id]\n    }\n    return [#a.h1: #a.h2: #a.id -- #b.h2: #b.id]\n  }\n  return [#a.h1: #a.h2: #a.id -- #b.h1: #b.h2: #b.id]\n}\n\n#set page(\n  width: 100mm,\n  height: 100mm,\n  header: context {\n    let pars = query(selector.or(&lt;h4-start&gt;, &lt;h4-end&gt;))\n      .filter(x =&gt; x.location().page() == here().page())\n      .map(shorts-and-id)\n      .dedup()\n    if pars.len() == 0 {\n      // No paragraph starting or ending on this page\n      // -&gt; check if a paragraph starts before and ends after this page\n      let prevs = query(selector(&lt;h4-start&gt;).before(here()))\n      let nexts = query(selector(&lt;h4-end&gt;).after(here()))\n      if prevs.len() == 0 or nexts.len() == 0 {\n        // ↓ 🥴 Still looking for improvement here too\n        return query(selector(&lt;h1-short&gt;)).filter(x =&gt; x.location().page() &lt;= here().page()).last().value \n      }\n      let prev = shorts-and-id(prevs.last())\n      let next = shorts-and-id(nexts.first())\n      if prev != next { // should not happen\n        // ↓ 🥴 Still looking for improvement here too \n        return query(selector(&lt;h1-short&gt;)).filter(x =&gt; x.location().page() &lt;= here().page()).last().value + \" \" + query(selector(&lt;h2-short&gt;)).filter(x =&gt; x.location().page() &lt;= here().page()).last().value\n      }\n      return header-content(prev, next)\n    }\n    return header-content(pars.first(), pars.at(-1, default: none))\n  },\n)\n\n#show heading.where(level: 4): it =&gt; it.body + h(1em)\n\n// Change text() to par() here ↓ to see the difference\n#let my-par(id: none, body) = text({\n  [#metadata([#id])&lt;h4-start&gt;]\n  if id != none {\n    heading(level: 4, id)\n  }\n  body\n  [#metadata([#id])&lt;h4-end&gt;]\n  // hide(\"​\") // ← 🥴 Uncomment to fix the issue\n})\n\n#let my-h1(short: none, ..args) = {\n  heading(level: 1, ..args)\n  [#metadata(short)&lt;h1-short&gt;]\n}\n#let my-h2(short: none, ..args) = {\n  heading(level: 2, ..args)\n  [#metadata(short)&lt;h2-short&gt;]\n}\n\n#my-h1(short: \"Preface\")[Preface]\nPreface content #lorem(50)\n#pagebreak()\n\n#my-h1(short: \"I. Section\")[This is I. Section]\n#my-h2(short: \"A-Chapter\")[This is Chapter A]\n#my-par(id: \"1\", lorem(20))\n#my-par(id: \"2\", lorem(50))\n\n//#my-h2(short: \"B-Chapter\")[This is Chapter B]\n#text(red, \"Counter remains at 2–5 ↑ despite (2) ending on the last page\")\n#my-par(id: \"3\", lorem(50))\n#my-par(id: \"4\", lorem(20))\n#my-par(id: \"5\", lorem(40))\n#text(green, \"Counts 5 ↑ correctly if it crosses the page \")\n\n// #my-h1(short: \"II. Section\")[This is II. Section]\n// #my-h2(short: \"C-Chapter\")[This is Chapter C]\n// #my-par(id: \"1\", lorem(20))\n// #my-par(id: \"2\", lorem(20))\n// #my-par(id: \"3\", lorem(50))\n\n// #my-h2(short: \"D-Chapter\")[This is Chapter D]\n// #my-par(id: \"11\", lorem(50))\n// #my-par(id: \"11a\", lorem(20))\n\n// #my-h1(short: \"III. Section\")[This is III. Section]\n// #my-h2(short: \"E-Chapter\")[This is Chapter E]\n// #my-par(id: \"11\", lorem(50))\n// #my-par(id: \"11a\", lorem(20))\n\n// #my-h2(short: \"F-Chapter\")[This is Chapter F]\n// Regular Content #lorem(200)\n\n// #my-h2(short: \"G-Chapter\")[This is Chapter G]\n// Regular Content #lorem(100)\n\n// #my-h2(short: \"H-Chapter\")[This is Chapter H]\n// #my-par(id: \"1\", lorem(50))\n// #my-par(id: \"2\", lorem(20))\n</code></pre>\n</details>",
      "raw": "After happily thinking that I've successfully implemented the solution, I ran into (or created) one more edge case: In my real-world example, the paragraphs are inline, so:\n\n```txt\n1. First paragraph 2. Second one\n```\ninstead of\n```txt\n1. First paragraph\n2. Second one\n```\n\nIt didn't recognize it at first because it only creates a problem when the last \"paragraph\" (which is `text()`) doesn't flow onto the next page. (Disclaimer: I'm not even sure I fully get the problem). But the case looks like so:\n\n![text-problem|690x233](upload://ylN4f6lqk0wuI2pWS9frajmkNUP.png)\n\nCan I adapt the prev/next query or adapt the element while keeping it \"inline\" to get this case right?\n\n```typ\nlet prevs = query(selector(<h4-start>).before(here()))\nlet nexts = query(selector(<h4-end>).after(here()))\n\n#let my-par(id: none, body) = text({\n  [#metadata([#id])<h4-start>]\n  if id != none {\n    heading(level: 4, id)\n  }\n  body\n  [#metadata([#id])<h4-end>]\n  // hide(\"​\") // ← 🥴 Uncomment to fix the issue\n})\n```\n\n**The best fix I was able to come up with is to end a zero-width space at the end** of my paragraph. But I'd like to understand the problem and maybe fix it in a non-hacky way if possible.\n\n\n[details=\"Full Code Example\"]\n```typ\n#let get-short(label, x) = {\n  let shorts = query(selector(label).before(x.location()))\n  return shorts.at(-1, default: none)\n}\n\n#let shorts-and-id(x) = {\n  let h1 = get-short(<h1-short>, x)\n  let h2 = get-short(<h2-short>, x)\n  return (h1: h1.value, h2: h2.value, id: x.value)\n}\n\n#let header-content(a, b) = {\n  if b == none {\n    return [#a.h1: #a.h2]\n  }\n  if b == a {\n    return [#a.h1: #a.h2: #a.id]\n  }\n  if a.h1 == b.h1 {\n    if a.h2 == b.h2 {\n      return [#a.h1: #a.h2: #a.id -- #b.id]\n    }\n    return [#a.h1: #a.h2: #a.id -- #b.h2: #b.id]\n  }\n  return [#a.h1: #a.h2: #a.id -- #b.h1: #b.h2: #b.id]\n}\n\n#set page(\n  width: 100mm,\n  height: 100mm,\n  header: context {\n    let pars = query(selector.or(<h4-start>, <h4-end>))\n      .filter(x => x.location().page() == here().page())\n      .map(shorts-and-id)\n      .dedup()\n    if pars.len() == 0 {\n      // No paragraph starting or ending on this page\n      // -> check if a paragraph starts before and ends after this page\n      let prevs = query(selector(<h4-start>).before(here()))\n      let nexts = query(selector(<h4-end>).after(here()))\n      if prevs.len() == 0 or nexts.len() == 0 {\n        // ↓ 🥴 Still looking for improvement here too\n        return query(selector(<h1-short>)).filter(x => x.location().page() <= here().page()).last().value \n      }\n      let prev = shorts-and-id(prevs.last())\n      let next = shorts-and-id(nexts.first())\n      if prev != next { // should not happen\n        // ↓ 🥴 Still looking for improvement here too \n        return query(selector(<h1-short>)).filter(x => x.location().page() <= here().page()).last().value + \" \" + query(selector(<h2-short>)).filter(x => x.location().page() <= here().page()).last().value\n      }\n      return header-content(prev, next)\n    }\n    return header-content(pars.first(), pars.at(-1, default: none))\n  },\n)\n\n#show heading.where(level: 4): it => it.body + h(1em)\n\n// Change text() to par() here ↓ to see the difference\n#let my-par(id: none, body) = text({\n  [#metadata([#id])<h4-start>]\n  if id != none {\n    heading(level: 4, id)\n  }\n  body\n  [#metadata([#id])<h4-end>]\n  // hide(\"​\") // ← 🥴 Uncomment to fix the issue\n})\n\n#let my-h1(short: none, ..args) = {\n  heading(level: 1, ..args)\n  [#metadata(short)<h1-short>]\n}\n#let my-h2(short: none, ..args) = {\n  heading(level: 2, ..args)\n  [#metadata(short)<h2-short>]\n}\n\n#my-h1(short: \"Preface\")[Preface]\nPreface content #lorem(50)\n#pagebreak()\n\n#my-h1(short: \"I. Section\")[This is I. Section]\n#my-h2(short: \"A-Chapter\")[This is Chapter A]\n#my-par(id: \"1\", lorem(20))\n#my-par(id: \"2\", lorem(50))\n\n//#my-h2(short: \"B-Chapter\")[This is Chapter B]\n#text(red, \"Counter remains at 2–5 ↑ despite (2) ending on the last page\")\n#my-par(id: \"3\", lorem(50))\n#my-par(id: \"4\", lorem(20))\n#my-par(id: \"5\", lorem(40))\n#text(green, \"Counts 5 ↑ correctly if it crosses the page \")\n\n// #my-h1(short: \"II. Section\")[This is II. Section]\n// #my-h2(short: \"C-Chapter\")[This is Chapter C]\n// #my-par(id: \"1\", lorem(20))\n// #my-par(id: \"2\", lorem(20))\n// #my-par(id: \"3\", lorem(50))\n\n// #my-h2(short: \"D-Chapter\")[This is Chapter D]\n// #my-par(id: \"11\", lorem(50))\n// #my-par(id: \"11a\", lorem(20))\n\n// #my-h1(short: \"III. Section\")[This is III. Section]\n// #my-h2(short: \"E-Chapter\")[This is Chapter E]\n// #my-par(id: \"11\", lorem(50))\n// #my-par(id: \"11a\", lorem(20))\n\n// #my-h2(short: \"F-Chapter\")[This is Chapter F]\n// Regular Content #lorem(200)\n\n// #my-h2(short: \"G-Chapter\")[This is Chapter G]\n// Regular Content #lorem(100)\n\n// #my-h2(short: \"H-Chapter\")[This is Chapter H]\n// #my-par(id: \"1\", lorem(50))\n// #my-par(id: \"2\", lorem(20))\n```\n[/details]",
      "reply_to_post_number": 10,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 22,
      "score": 4.4,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 566
    },
    {
      "id": 10683,
      "post_number": 13,
      "username": "sijo",
      "name": "",
      "created_at": "2025-04-06T10:25:46.712Z",
      "updated_at": "2025-04-06T10:26:03.497Z",
      "cooked": "<p>I think normally when metadata is added after a paragraph it’s not part of the paragraph. In the previous version of this code <code>my-par</code> was making an actual paragraph, so it forced the metadata to be part of the paragraph. Now it’s not the case anymore. To make the metadata part of the paragraph you can add some more text after it like your invisible space (maybe a cleaner version would be to append <code>#sym.zws</code>), or you can wrap the metadata in a box…</p>",
      "raw": "I think normally when metadata is added after a paragraph it's not part of the paragraph. In the previous version of this code `my-par` was making an actual paragraph, so it forced the metadata to be part of the paragraph. Now it's not the case anymore. To make the metadata part of the paragraph you can add some more text after it like your invisible space (maybe a cleaner version would be to append `#sym.zws`), or you can wrap the metadata in a box...",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 0,
      "reads": 19,
      "score": 8.8,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 332
    },
    {
      "id": 10685,
      "post_number": 14,
      "username": "a_w",
      "name": "Alex",
      "created_at": "2025-04-06T10:35:46.885Z",
      "updated_at": "2025-04-06T10:35:46.885Z",
      "cooked": "<aside class=\"quote no-group\" data-username=\"sijo\" data-post=\"13\" data-topic=\"3456\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/letter_avatar_proxy/v4/letter/s/0A3649/48.png\" class=\"avatar\"> sijo:</div>\n<blockquote>\n<p>or you can wrap the metadata in a box…</p>\n</blockquote>\n</aside>\n<p>Ahh, that makes sense! I think <code>box()[#metadata([#id])&lt;h4-end&gt;]</code> might make the least troubles. Thanks for the input! <img src=\"https://forum.typst.app/images/emoji/apple/pray.png?v=12\" title=\":pray:\" class=\"emoji\" alt=\":pray:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>",
      "raw": "[quote=\"sijo, post:13, topic:3456\"]\nor you can wrap the metadata in a box…\n[/quote]\n\nAhh, that makes sense! I think `box()[#metadata([#id])<h4-end>]` might make the least troubles. Thanks for the input! 🙏",
      "reply_to_post_number": 13,
      "reply_count": 1,
      "quote_count": 1,
      "like_count": 0,
      "reads": 20,
      "score": 9.0,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 566
    },
    {
      "id": 10687,
      "post_number": 15,
      "username": "Andrew",
      "name": "",
      "created_at": "2025-04-06T10:43:57.782Z",
      "updated_at": "2025-04-06T10:43:57.782Z",
      "cooked": "<aside class=\"quote no-group\" data-username=\"a_w\" data-post=\"14\" data-topic=\"3456\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/user_avatar/forum.typst.app/a_w/48/1206_2.png\" class=\"avatar\"> a_w:</div>\n<blockquote>\n<p><code>box()[#metadata([#id])&lt;h4-end&gt;]</code></p>\n</blockquote>\n</aside>\n<p>You can write it like this: <code>box[#metadata[#id]&lt;h4-end&gt;]</code>.</p>",
      "raw": "[quote=\"a_w, post:14, topic:3456\"]\n`box()[#metadata([#id])<h4-end>]`\n[/quote]\n\nYou can write it like this: `box[#metadata[#id]<h4-end>]`.",
      "reply_to_post_number": 14,
      "reply_count": 0,
      "quote_count": 1,
      "like_count": 1,
      "reads": 19,
      "score": 18.8,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 51
    }
  ],
  "scraped_at": "2025-06-10T09:49:52.040099"
}