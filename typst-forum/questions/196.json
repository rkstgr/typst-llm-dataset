{
  "topic_metadata": {
    "id": 196,
    "title": "Why can't I use a function in a chapter even though I imported it at the start of my main file?",
    "slug": "why-cant-i-use-a-function-in-a-chapter-even-though-i-imported-it-at-the-start-of-my-main-file",
    "posts_count": 7,
    "created_at": "2024-09-15T14:57:02.706Z",
    "last_posted_at": "2024-09-19T03:56:17.476Z",
    "views": 799,
    "like_count": 8,
    "reply_count": 4,
    "has_accepted_answer": true,
    "accepted_answer_post_number": 2,
    "accepted_answer_username": "SillyFreak",
    "tags": [
      "scripting"
    ],
    "category_id": 5,
    "participant_count": 4,
    "word_count": 1052
  },
  "posts": [
    {
      "id": 907,
      "post_number": 1,
      "username": "SillyFreak",
      "name": "SillyFreak",
      "created_at": "2024-09-15T14:57:02.840Z",
      "updated_at": "2024-09-15T14:57:25.217Z",
      "cooked": "<p>My main Typst file looks like this:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#import \"funcs.typ\": my-func\n\n#include \"chapter.typ\"\n</code></pre>\n<p>However, when I call <code>my-func()</code> inside the chapter file, I get the error “unknown variable: my-func”. Calling it in the main file, however, works. How can I fix that?</p>",
      "raw": "My main Typst file looks like this:\n\n```typ\n#import \"funcs.typ\": my-func\n\n#include \"chapter.typ\"\n```\n\nHowever, when I call `my-func()` inside the chapter file, I get the error \"unknown variable: my-func\". Calling it in the main file, however, works. How can I fix that?",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 88,
      "score": 2487.4,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 32
    },
    {
      "id": 908,
      "post_number": 2,
      "username": "SillyFreak",
      "name": "SillyFreak",
      "created_at": "2024-09-15T14:57:39.343Z",
      "updated_at": "2024-09-15T15:02:29.239Z",
      "cooked": "<p>You need to define (in this case, import) <code>my-func()</code> in the file you want to use it, i.e. <code>chapter.typ</code>. Imports don’t “carry over” from the files including them.</p>\n<p>If you have many imports that you don’t want to repeat in many files, you can bundle them in a single file, like this:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">// prelude.typ\n#import \"@preview/package:0.1.0\"\n#import \"funcs.typ\": my-func\n</code></pre>\n<p>&nbsp;</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">// main.typ\n#import \"prelude.typ\": *\n\n#package.some-function()\n\n#include \"chapter.typ\"\n</code></pre>\n<p>&nbsp;</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">// chapter.typ\n#import \"prelude.typ\": *\n\n#my-func()\n</code></pre>\n<p>The name <em>prelude</em> is just a suggestion; it comes from programming languages that use that name for their set of “default” imports that are automatically available.</p>\n<hr>\n<p><strong>Explanation:</strong> If you’re used to <code>#include</code> from C, it may come as a surprise that Typst’s import and include features work fairly differently. With C-style includes, the code from <code>chapter.typ</code> would be effectively “copy/pasted” into your main file and, because <code>my-func()</code> is available in the main file, it would also work in the included chapter.</p>\n<p>Typst’s name resolution instead uses so-called <em>lexical scoping</em>: variables (including functions) are only available if they’re defined in the <em>surrounding code</em>. Take this example:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let greeting = \"Hello\"\n\n#let greet() = {\n  greeting + \" World\"\n}\n\n#greet()\n</code></pre>\n<p>Here, the variable <code>greeting</code> can be used in <code>greet()</code> because the functions’s body is surrounded by the rest of the file, where the variable is defined. Calling <code>greet()</code> works because the code at the same “level” and before the code also counts.</p>\n<p>The file itself is not “surrounded” by anything*, so a function such as <code>my-func()</code> would not be available; you can’t do anything from outside to change that.</p>\n<p>*The exception is that built-in modules and names such as <code>math</code> or <code>heading</code> are always available; they can be thought of as being “defined in surrounding code” and form the <em>proper</em> prelude that Typst code has access to.</p>",
      "raw": "You need to define (in this case, import) `my-func()` in the file you want to use it, i.e. `chapter.typ`. Imports don't \"carry over\" from the files including them.\n\nIf you have many imports that you don't want to repeat in many files, you can bundle them in a single file, like this:\n\n```typ\n// prelude.typ\n#import \"@preview/package:0.1.0\"\n#import \"funcs.typ\": my-func\n```\n&nbsp;\n```typ\n// main.typ\n#import \"prelude.typ\": *\n\n#package.some-function()\n\n#include \"chapter.typ\"\n```\n&nbsp;\n```typ\n// chapter.typ\n#import \"prelude.typ\": *\n\n#my-func()\n```\n\nThe name _prelude_ is just a suggestion; it comes from programming languages that use that name for their set of \"default\" imports that are automatically available.\n\n---\n\n**Explanation:** If you're used to `#include` from C, it may come as a surprise that Typst's import and include features work fairly differently. With C-style includes, the code from `chapter.typ` would be effectively \"copy/pasted\" into your main file and, because `my-func()` is available in the main file, it would also work in the included chapter.\n\nTypst's name resolution instead uses so-called _lexical scoping_: variables (including functions) are only available if they're defined in the _surrounding code_. Take this example:\n\n```typ\n#let greeting = \"Hello\"\n\n#let greet() = {\n  greeting + \" World\"\n}\n\n#greet()\n```\n\nHere, the variable `greeting` can be used in `greet()` because the functions's body is surrounded by the rest of the file, where the variable is defined. Calling `greet()` works because the code at the same \"level\" and before the code also counts.\n\nThe file itself is not \"surrounded\" by anything*, so a function such as `my-func()` would not be available; you can't do anything from outside to change that.\n\n\\*The exception is that built-in modules and names such as `math` or `heading` are always available; they can be thought of as being \"defined in surrounding code\" and form the _proper_ prelude that Typst code has access to.",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 2,
      "reads": 89,
      "score": 197.6,
      "accepted_answer": true,
      "trust_level": 3,
      "user_id": 32
    },
    {
      "id": 1171,
      "post_number": 3,
      "username": "Rogier",
      "name": "Rogier",
      "created_at": "2024-09-16T08:49:47.354Z",
      "updated_at": "2024-09-16T08:49:47.354Z",
      "cooked": "<p>I have actually desperately been trying to find an “inline import” method in Typst. It would solve so many of my little issues and make the templates I make easier to use for others.</p>\n<p>For example I use acrostiche for acronym management. it would be great if people could just use acrostiche in their files without having to specifically import it.</p>\n<p>I’m not saying the behaviour of the current <span class=\"hashtag-raw\">#import</span> should be changed. I’m saying another function. “<span class=\"hashtag-raw\">#input</span>” or “<span class=\"hashtag-raw\">#inline-include</span>” or something.</p>",
      "raw": "I have actually desperately been trying to find an \"inline import\" method in Typst. It would solve so many of my little issues and make the templates I make easier to use for others.\n\nFor example I use acrostiche for acronym management. it would be great if people could just use acrostiche in their files without having to specifically import it.\n\nI'm not saying the behaviour of the current #import should be changed. I'm saying another function. \"#input\" or \"#inline-include\" or something.",
      "reply_to_post_number": 2,
      "reply_count": 2,
      "quote_count": 0,
      "like_count": 2,
      "reads": 61,
      "score": 57.2,
      "accepted_answer": false,
      "trust_level": 1,
      "user_id": 263
    },
    {
      "id": 1259,
      "post_number": 4,
      "username": "EaterOfSnacks",
      "name": "EaterOfSnacks",
      "created_at": "2024-09-16T12:48:33.190Z",
      "updated_at": "2024-09-16T12:48:33.190Z",
      "cooked": "<p>Nice if that could be configured with a settings/manifest file in the same directory, a little like a cargo.toml file.</p>",
      "raw": "Nice if that could be configured with a settings/manifest file in the same directory, a little like a cargo.toml file.",
      "reply_to_post_number": 3,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 58,
      "score": 11.6,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 36
    },
    {
      "id": 1396,
      "post_number": 5,
      "username": "SillyFreak",
      "name": "SillyFreak",
      "created_at": "2024-09-16T17:24:00.334Z",
      "updated_at": "2024-09-16T17:24:00.334Z",
      "cooked": "<aside class=\"quote no-group\" data-username=\"Rogier\" data-post=\"3\" data-topic=\"196\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/letter_avatar_proxy/v4/letter/r/220F66/48.png\" class=\"avatar\"> Rogier:</div>\n<blockquote>\n<p>I have actually desperately been trying to find an “inline import” method in Typst</p>\n</blockquote>\n</aside>\n<p>This is actually possible to do:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let my-import(pkg) = {\n  import pkg as p\n  p\n}\n\n#my-import(\"@preview/example:0.1.0\").add(1, 2)\n</code></pre>\n<p>One problem is that this only works for package imports; for files you’d run into path problems, such as here: <a href=\"https://forum.typst.app/t/why-are-paths-always-relative-to-the-current-file/306\" class=\"inline-onebox\">Why are paths always relative to the current file?</a> The other problem is of course that, unless this was built-in, you’d <em>still</em> need to import or write that function yourself…</p>\n<hr>\n<p>Personally I think the way to allow this is to allow specifying an actual prelude somehow. That “somehow” would probably be the <code>typst.toml</code> file that already contains <a href=\"https://github.com/typst/packages/?tab=readme-ov-file#package-format\" rel=\"noopener nofollow ugc\">metadata for packages</a>, and make it more appropriate for documents in addition to packages (and templates).</p>\n<p>Using a prelude file for this would mean that the regular Typst <code>import</code> and <code>let</code> statements could still be used, they’d very naturally specify the package versions to use at a single location, and not require completely new concepts.</p>\n<hr>\n<p>The downside in general of any such approach is that Typst code becomes less “copy-pasteable”: right now, you can look at the file and find everything that the code you’re copying needs; either directly there or in it imports. (Well there’s already one tiny caveat to that: your file may require a <em>specific</em> version of Typst to compile, which is not written down in every file.)</p>",
      "raw": "[quote=\"Rogier, post:3, topic:196\"]\nI have actually desperately been trying to find an “inline import” method in Typst\n[/quote]\n\nThis is actually possible to do:\n\n```typ\n#let my-import(pkg) = {\n  import pkg as p\n  p\n}\n\n#my-import(\"@preview/example:0.1.0\").add(1, 2)\n```\n\nOne problem is that this only works for package imports; for files you'd run into path problems, such as here: https://forum.typst.app/t/why-are-paths-always-relative-to-the-current-file/306 The other problem is of course that, unless this was built-in, you'd _still_ need to import or write that function yourself...\n\n---\n\nPersonally I think the way to allow this is to allow specifying an actual prelude somehow. That \"somehow\" would probably be the `typst.toml` file that already contains [metadata for packages](https://github.com/typst/packages/?tab=readme-ov-file#package-format), and make it more appropriate for documents in addition to packages (and templates).\n\nUsing a prelude file for this would mean that the regular Typst `import` and `let` statements could still be used, they'd very naturally specify the package versions to use at a single location, and not require completely new concepts.\n\n---\n\nThe downside in general of any such approach is that Typst code becomes less \"copy-pasteable\": right now, you can look at the file and find everything that the code you're copying needs; either directly there or in it imports. (Well there's already one tiny caveat to that: your file may require a _specific_ version of Typst to compile, which is not written down in every file.)",
      "reply_to_post_number": 3,
      "reply_count": 1,
      "quote_count": 1,
      "like_count": 1,
      "reads": 57,
      "score": 46.4,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 32
    },
    {
      "id": 1529,
      "post_number": 6,
      "username": "EaterOfSnacks",
      "name": "EaterOfSnacks",
      "created_at": "2024-09-17T09:50:15.361Z",
      "updated_at": "2024-09-17T09:50:15.361Z",
      "cooked": "<p>I think portability is a great default. But IMO it should be just that: a default that can be overridden, subject to a few compiler warnings or what-have-you. If we really insist on plopping a package or template file in some arbitrary directory as a repository for useful functions, on our own heads be it. It would still be possible to write a “scoop it all up and package it” script, a little like the way Indesign can collect and package all assets, properly linked, ready for despatch to printers or publishers…</p>",
      "raw": "I think portability is a great default. But IMO it should be just that: a default that can be overridden, subject to a few compiler warnings or what-have-you. If we really insist on plopping a package or template file in some arbitrary directory as a repository for useful functions, on our own heads be it. It would still be possible to write a \"scoop it all up and package it\" script, a little like the way Indesign can collect and package all assets, properly linked, ready for despatch to printers or publishers...",
      "reply_to_post_number": 5,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 51,
      "score": 25.0,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 36
    },
    {
      "id": 1843,
      "post_number": 7,
      "username": "PgBiel",
      "name": "",
      "created_at": "2024-09-19T03:56:17.476Z",
      "updated_at": "2024-09-19T03:56:17.476Z",
      "cooked": "<blockquote>\n<p>If we really insist on plopping a package or template file in some arbitrary directory as a repository for useful functions, on our own heads be it.</p>\n</blockquote>\n<p>As a brief comment, I wanted to mention that this is already possible.  Consider the project structure below:</p>\n<pre data-code-wrap=\"txt\"><code class=\"lang-txt\">project\n├── some\n│   └── sub\n│       └── folder\n│           └── file.typ\n└── template.typ\n</code></pre>\n<p>You can import your template from anywhere in your project easily through <code>/absolute/paths/from/project/root</code>, by just adding the line at the top of the <code>file.typ</code> example below:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">// template.typ\n\n#let func(x) = [Hello #x]\n\n// file.typ\n\n// Note the '/' before template.typ\n// Works at any level of nesting\n#import \"/template.typ\": *\n\n// Can use\n#func[ABC ABC ABC]\n</code></pre>\n<p>I’d consider this equivalent to a per-project preamble (even more flexible than that, actually, since you can pick what to import, import multiple files or a different file, and so on).<br>\nYou can even use symlinks here if you want <code>template.typ</code> to point at some arbitrary file in your system which could change depending on a script you write (for example).</p>\n<p>So the desired functionality is retained, just in a way that is more integrated with the Typst language, and also more readable and portable as was already mentioned.</p>",
      "raw": "> If we really insist on plopping a package or template file in some arbitrary directory as a repository for useful functions, on our own heads be it.\n\nAs a brief comment, I wanted to mention that this is already possible.  Consider the project structure below:\n\n```txt\nproject\n├── some\n│   └── sub\n│       └── folder\n│           └── file.typ\n└── template.typ\n```\n\nYou can import your template from anywhere in your project easily through `/absolute/paths/from/project/root`, by just adding the line at the top of the `file.typ` example below:\n\n```typ\n// template.typ\n\n#let func(x) = [Hello #x]\n\n// file.typ\n\n// Note the '/' before template.typ\n// Works at any level of nesting\n#import \"/template.typ\": *\n\n// Can use\n#func[ABC ABC ABC]\n```\n\nI'd consider this equivalent to a per-project preamble (even more flexible than that, actually, since you can pick what to import, import multiple files or a different file, and so on).\nYou can even use symlinks here if you want `template.typ` to point at some arbitrary file in your system which could change depending on a script you write (for example).\n\nSo the desired functionality is retained, just in a way that is more integrated with the Typst language, and also more readable and portable as was already mentioned.",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 3,
      "reads": 46,
      "score": 104.0,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 3
    }
  ],
  "scraped_at": "2025-06-10T09:58:57.295694"
}