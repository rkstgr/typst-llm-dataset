{
  "topic_metadata": {
    "id": 3664,
    "title": "How to cleanly declare arguments to document?",
    "slug": "how-to-cleanly-declare-arguments-to-document",
    "posts_count": 5,
    "created_at": "2025-04-15T16:02:33.722Z",
    "last_posted_at": "2025-04-16T21:09:37.373Z",
    "views": 109,
    "like_count": 6,
    "reply_count": 2,
    "has_accepted_answer": true,
    "accepted_answer_post_number": 2,
    "accepted_answer_username": "quachpas",
    "tags": [
      "scripting",
      "data-loading"
    ],
    "category_id": 5,
    "participant_count": 3,
    "word_count": 757
  },
  "posts": [
    {
      "id": 11119,
      "post_number": 1,
      "username": "Nicholas",
      "name": "Nicholas",
      "created_at": "2025-04-15T16:02:33.875Z",
      "updated_at": "2025-04-18T19:25:55.385Z",
      "cooked": "<p>I’m experimenting with writing a document in a way that exposes arguments for query. This is per-se not that complicated, but I struggle with doing it cleanly. My ideal result would look something like this:</p>\n<pre data-code-wrap=\"typst\"><code class=\"lang-typst\">#import \"some-package\": declare_args\n#let args = declare_args((sender: \"Alice\", receiver: \"Bob\"))\n\nHi #args.receiver, this is #args.sender\n</code></pre>\n<p>where the <code>declare_args</code> function:</p>\n<ul>\n<li>inserts a <code>metadata</code> content block with the args, such that we can query for it from an external program</li>\n<li>replaces the values of <code>sender</code> and <code>receiver</code> by values from <code>sys.inputs</code> (if provided)</li>\n<li>colors all values of keys that were not provided via <code>sys.inputs</code> red to show they need to be provided (but not stopping the compilation)</li>\n</ul>\n<p>This is as such not possible, since typst cannot return a value and insert a block at the same time.</p>\n<p>I was able to get the following variants of this, but am not happy with them:</p>\n<pre data-code-wrap=\"typst\"><code class=\"lang-typst\">#let args =(sender: \"Alice\",receiver: \"Bob\")\n#declare_args(args) // basically #metadata(args) &lt;args&gt;\n#let args = mark_required(args) // Merge sys.inputs and color them\n// needs two calls and reassigns the args\n</code></pre>\n<p>.</p>\n<pre data-code-wrap=\"typst\"><code class=\"lang-typst\">#let (args, meta) =declare_and_mark((sender: \"Alice\",receiver: \"Bob\")) // just the other two functions combined returning an array\n#meta\n// You need to insert that meta variable and don't really notice if your forget\n</code></pre>\n<p>.</p>\n<pre data-code-wrap=\"typst\"><code class=\"lang-typst\">// Using state and a regex rule, collect all occurrences of ARG_*, replace them with sys.inputs.at(*) or text(red, *) and insert a metadata tag of state.final()\n#show: regex_spam\nHi ARGS_sender, this is ARGS_receiver\n// Using a variable gives better hints and autocompletion. (and regex rules are scary)\n</code></pre>\n<p>.</p>\n<pre data-code-wrap=\"typst\"><code class=\"lang-typst\">#let arg_func(key) =&gt; [\n  #metadata(key) &lt;arg&gt;\n  #sys.inputs.at(key,default: text(red, args.at(key)))\n]\nHi arg_func(\"receiver\"), this is arg_func(\"sender\")\n// Again, the variable with fields just has better support\n</code></pre>\n<p>What I tried but didn’t get to work:</p>\n<ul>\n<li>A show rule that somehow injects a variable into the document (not possible due to scoping)</li>\n<li>Returning a variable and inserting a content block by the same function (not possible)</li>\n</ul>\n<p>Any ideas how I could get closer to my ideal result?</p>",
      "raw": "I'm experimenting with writing a document in a way that exposes arguments for query. This is per-se not that complicated, but I struggle with doing it cleanly. My ideal result would look something like this:\n```typst\n#import \"some-package\": declare_args\n#let args = declare_args((sender: \"Alice\", receiver: \"Bob\"))\n\nHi #args.receiver, this is #args.sender\n```\nwhere the `declare_args` function:\n - inserts a `metadata` content block with the args, such that we can query for it from an external program\n - replaces the values of `sender` and `receiver` by values from `sys.inputs` (if provided)\n - colors all values of keys that were not provided via `sys.inputs` red to show they need to be provided (but not stopping the compilation)\n\nThis is as such not possible, since typst cannot return a value and insert a block at the same time. \n\nI was able to get the following variants of this, but am not happy with them:\n```typst\n#let args =(sender: \"Alice\",receiver: \"Bob\")\n#declare_args(args) // basically #metadata(args) <args>\n#let args = mark_required(args) // Merge sys.inputs and color them\n// needs two calls and reassigns the args\n```\n.\n```typst\n#let (args, meta) =declare_and_mark((sender: \"Alice\",receiver: \"Bob\")) // just the other two functions combined returning an array\n#meta\n// You need to insert that meta variable and don't really notice if your forget\n```\n.\n```typst\n// Using state and a regex rule, collect all occurrences of ARG_*, replace them with sys.inputs.at(*) or text(red, *) and insert a metadata tag of state.final()\n#show: regex_spam\nHi ARGS_sender, this is ARGS_receiver\n// Using a variable gives better hints and autocompletion. (and regex rules are scary)\n```\n.\n```typst\n#let arg_func(key) => [\n  #metadata(key) <arg>\n  #sys.inputs.at(key,default: text(red, args.at(key)))\n]\nHi arg_func(\"receiver\"), this is arg_func(\"sender\")\n// Again, the variable with fields just has better support\n```\n\n\nWhat I tried but didn't get to work:\n - A show rule that somehow injects a variable into the document (not possible due to scoping)\n - Returning a variable and inserting a content block by the same function (not possible)\n\nAny ideas how I could get closer to my ideal result?",
      "reply_to_post_number": null,
      "reply_count": 2,
      "quote_count": 0,
      "like_count": 0,
      "reads": 37,
      "score": 57.4,
      "accepted_answer": false,
      "trust_level": 1,
      "user_id": 1462
    },
    {
      "id": 11144,
      "post_number": 2,
      "username": "quachpas",
      "name": "Pascal Quach",
      "created_at": "2025-04-16T06:49:49.830Z",
      "updated_at": "2025-04-16T06:49:49.830Z",
      "cooked": "<p>Hello!<br>\nI think this should be achievable with the following code, you were nearly there!</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let declare_args(it) = {\n  let inputs = sys.inputs\n  for (k,v) in it {\n    (str(k): [#inputs.at(k, default: text(red, v))#metadata(v)#label(str(k))]) \n  }\n}\n#let args = declare_args((sender: \"Alice\", receiver: \"Bob\"))\n\nHi #args.sender, this is #args.receiver.\n</code></pre>\n<p>If I compile with input <code>sender=Steve</code>, I get<br>\n<img src=\"https://forum.typst.app/uploads/default/original/2X/d/d5ad9787d5a171978db2300bbcf88518d6cab8bd.png\" alt=\"image\" data-base62-sha1=\"uuhCrWbAVluhWLCs2ZEj7lCjIDP\" width=\"167\" height=\"42\"></p>\n<p>and you can query either a label or metadata directly to get</p>\n<pre data-code-wrap=\"shell\"><code class=\"lang-shell\">❯ typst query test.typ \"&lt;sender&gt;\"\n[{\"func\":\"metadata\",\"value\":\"Alice\",\"label\":\"&lt;sender&gt;\"}]\n❯ typst query test.typ \"&lt;receiver&gt;\"\n[{\"func\":\"metadata\",\"value\":\"Bob\",\"label\":\"&lt;receiver&gt;\"}]\n❯ typst query test.typ \"metadata\"\n[{\"func\":\"metadata\",\"value\":\"Alice\",\"label\":\"&lt;sender&gt;\"},{\"func\":\"metadata\",\"value\":\"Bob\",\"label\":\"&lt;receiver&gt;\"}]\n</code></pre>\n<aside class=\"quote no-group\" data-username=\"Nicholas\" data-post=\"1\" data-topic=\"3664\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/user_avatar/forum.typst.app/nicholas/48/2575_2.png\" class=\"avatar\"> Nicholas:</div>\n<blockquote>\n<p>This is as such not possible, since typst cannot return a value and insert a block at the same time.</p>\n</blockquote>\n</aside>\n<p>I am not sure what you mean here, but I think you forgot that you can just return a dictionary with content values!</p>",
      "raw": "Hello!\nI think this should be achievable with the following code, you were nearly there!\n\n```typ\n#let declare_args(it) = {\n  let inputs = sys.inputs\n  for (k,v) in it {\n    (str(k): [#inputs.at(k, default: text(red, v))#metadata(v)#label(str(k))]) \n  }\n}\n#let args = declare_args((sender: \"Alice\", receiver: \"Bob\"))\n\nHi #args.sender, this is #args.receiver.\n```\n\nIf I compile with input `sender=Steve`, I get\n![image|167x42](upload://uuhCrWbAVluhWLCs2ZEj7lCjIDP.png)\n\nand you can query either a label or metadata directly to get\n```shell\n❯ typst query test.typ \"<sender>\"\n[{\"func\":\"metadata\",\"value\":\"Alice\",\"label\":\"<sender>\"}]\n❯ typst query test.typ \"<receiver>\"\n[{\"func\":\"metadata\",\"value\":\"Bob\",\"label\":\"<receiver>\"}]\n❯ typst query test.typ \"metadata\"\n[{\"func\":\"metadata\",\"value\":\"Alice\",\"label\":\"<sender>\"},{\"func\":\"metadata\",\"value\":\"Bob\",\"label\":\"<receiver>\"}]\n```\n\n[quote=\"Nicholas, post:1, topic:3664\"]\nThis is as such not possible, since typst cannot return a value and insert a block at the same time.\n[/quote]\nI am not sure what you mean here, but I think you forgot that you can just return a dictionary with content values!",
      "reply_to_post_number": null,
      "reply_count": 2,
      "quote_count": 1,
      "like_count": 2,
      "reads": 26,
      "score": 60.2,
      "accepted_answer": true,
      "trust_level": 3,
      "user_id": 258
    },
    {
      "id": 11148,
      "post_number": 3,
      "username": "Nicholas",
      "name": "Nicholas",
      "created_at": "2025-04-16T10:50:11.180Z",
      "updated_at": "2025-04-16T10:50:11.180Z",
      "cooked": "<p>Thanks! That’s exactly what I wanted.</p>\n<aside class=\"quote no-group quote-modified\" data-username=\"quachpas\" data-post=\"2\" data-topic=\"3664\" data-full=\"true\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/letter_avatar_proxy/v4/letter/q/662200/48.png\" class=\"avatar\"> quachpas:</div>\n<blockquote>\n<aside class=\"quote no-group\" data-username=\"Nicholas\" data-post=\"1\" data-topic=\"3664\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/user_avatar/forum.typst.app/nicholas/48/2575_2.png\" class=\"avatar\"> Nicholas:</div>\n<blockquote>\n<p>This is as such not possible, since typst cannot return a value and insert a block at the same time.</p>\n</blockquote>\n</aside>\n<p>I am not sure what you mean here, but I think you forgot that you can just return a dictionary with content values!</p>\n</blockquote>\n</aside>\n<p>Just for your information, I tried to do something like this</p>\n<pre data-code-wrap=\"typst\"><code class=\"lang-typst\">#let declare_args(args) = {\n  [#metadata(args) &lt;args&gt;]\n  args.map(/* replace the values */)\n}\n</code></pre>\n<p>Which will fail, because it wants to join the resulting content and dictionary (which is perfectly reasonable, I just wanted to have it insert the content and return the args^^)</p>",
      "raw": "Thanks! That's exactly what I wanted.\n\n\n[quote=\"quachpas, post:2, topic:3664, full:true\"]\n[quote=\"Nicholas, post:1, topic:3664\"]\nThis is as such not possible, since typst cannot return a value and insert a block at the same time.\n[/quote]\nI am not sure what you mean here, but I think you forgot that you can just return a dictionary with content values!\n[/quote]\n\nJust for your information, I tried to do something like this\n```typst\n#let declare_args(args) = {\n  [#metadata(args) <args>]\n  args.map(/* replace the values */)\n}\n```\nWhich will fail, because it wants to join the resulting content and dictionary (which is perfectly reasonable, I just wanted to have it insert the content and return the args^^)",
      "reply_to_post_number": 2,
      "reply_count": 0,
      "quote_count": 2,
      "like_count": 1,
      "reads": 21,
      "score": 19.2,
      "accepted_answer": false,
      "trust_level": 1,
      "user_id": 1462
    },
    {
      "id": 11190,
      "post_number": 4,
      "username": "Andrew",
      "name": "",
      "created_at": "2025-04-16T21:07:37.601Z",
      "updated_at": "2025-04-16T21:07:37.601Z",
      "cooked": "<p>Keys in dictionary must be of type <code>str</code>, so you don’t need to convert them:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let declare-args(dictionary) = for (k, v) in dictionary {\n  ((k): [#sys.inputs.at(k, default: text(red, v))#metadata(v)#label(k)])\n}\n\n#let args = declare-args((sender: \"Alice\", receiver: \"Bob\"))\n\nHi #args.sender, this is #args.receiver.\n</code></pre>",
      "raw": "Keys in dictionary must be of type `str`, so you don't need to convert them:\n\n```typ\n#let declare-args(dictionary) = for (k, v) in dictionary {\n  ((k): [#sys.inputs.at(k, default: text(red, v))#metadata(v)#label(k)])\n}\n\n#let args = declare-args((sender: \"Alice\", receiver: \"Bob\"))\n\nHi #args.sender, this is #args.receiver.\n```",
      "reply_to_post_number": 2,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 1,
      "reads": 17,
      "score": 18.4,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 51
    },
    {
      "id": 11191,
      "post_number": 5,
      "username": "Andrew",
      "name": "",
      "created_at": "2025-04-16T21:09:37.373Z",
      "updated_at": "2025-04-16T21:09:37.373Z",
      "cooked": "<p>The for loop works the same way as this map-join call chain:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let declare-args(dictionary) = {\n  dictionary\n    .pairs()\n    .map(((k, v)) =&gt; (\n      (k): [#sys.inputs.at(k, default: text(red, v))#metadata(v)#label(k)],\n    ))\n    .join()\n}\n</code></pre>\n<p>But sometimes for loop is just cleaner, as in this case. But I saw a lot of cases where it’s the other way around.</p>",
      "raw": "The for loop works the same way as this map-join call chain:\n\n```typ\n#let declare-args(dictionary) = {\n  dictionary\n    .pairs()\n    .map(((k, v)) => (\n      (k): [#sys.inputs.at(k, default: text(red, v))#metadata(v)#label(k)],\n    ))\n    .join()\n}\n```\n\nBut sometimes for loop is just cleaner, as in this case. But I saw a lot of cases where it's the other way around.",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 2,
      "reads": 16,
      "score": 33.2,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 51
    }
  ],
  "scraped_at": "2025-06-10T09:49:10.097899"
}