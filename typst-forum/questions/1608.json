{
  "topic_metadata": {
    "id": 1608,
    "title": "How can I align multiple terms in a multi-line block equation?",
    "slug": "how-can-i-align-multiple-terms-in-a-multi-line-block-equation",
    "posts_count": 5,
    "created_at": "2024-11-08T14:03:53.975Z",
    "last_posted_at": "2024-11-08T17:47:15.976Z",
    "views": 696,
    "like_count": 7,
    "reply_count": 1,
    "has_accepted_answer": true,
    "accepted_answer_post_number": 4,
    "accepted_answer_username": "Eric",
    "tags": [
      "math"
    ],
    "category_id": 5,
    "participant_count": 3,
    "word_count": 911
  },
  "posts": [
    {
      "id": 5313,
      "post_number": 1,
      "username": "lampert",
      "name": "Joshua Lampert",
      "created_at": "2024-11-08T14:03:54.119Z",
      "updated_at": "2024-11-08T14:28:54.671Z",
      "cooked": "<p>I would like to have a multi-line equation, where the different terms in each equation of the different lines are aligned centrally, such that I can relate them to each other with <code>underbrace</code> and <code>overbrace</code>. The result should look like similar to this:<br>\n<div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://forum.typst.app/uploads/default/original/2X/9/9404f8730487f1d793aef5c6a36d0e7558ecbec5.png\" data-download-href=\"https://forum.typst.app/uploads/default/9404f8730487f1d793aef5c6a36d0e7558ecbec5\" title=\"image\"><img src=\"https://forum.typst.app/uploads/default/optimized/2X/9/9404f8730487f1d793aef5c6a36d0e7558ecbec5_2_690x166.png\" alt=\"image\" data-base62-sha1=\"l7rjwpLjKIAE3hTcRQYgg4sosV7\" width=\"690\" height=\"166\" srcset=\"https://forum.typst.app/uploads/default/optimized/2X/9/9404f8730487f1d793aef5c6a36d0e7558ecbec5_2_690x166.png, https://forum.typst.app/uploads/default/optimized/2X/9/9404f8730487f1d793aef5c6a36d0e7558ecbec5_2_1035x249.png 1.5x, https://forum.typst.app/uploads/default/original/2X/9/9404f8730487f1d793aef5c6a36d0e7558ecbec5.png 2x\" data-dominant-color=\"F1F1F1\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">image</span><span class=\"informations\">1068×258 23.7 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>which I created in LaTeX with</p>\n<pre><code class=\"lang-auto\">\\begin{equation*}\n\t\\begin{array}{ccccccc}\n\t\t\\underbrace{\\bm u^TPD\\bm v}_{\\vapprox} &amp;+&amp; \\underbrace{\\bm u^TD^TP\\bm v}_{\\vapprox} &amp;=&amp; \\underbrace{\\bm u^T\\bm e_R\\bm e_R^T\\bm v}_{\\veq} &amp;-&amp; \\underbrace{\\bm u^T\\bm e_L\\bm e_L^T\\bm v}_{\\veq}\\\\\n\t\t\\overbrace{\\displaystyle\\int_{x_L}^{x_R} uv_x\\tr dx} &amp;+&amp; \\overbrace{\\displaystyle\\int_{x_L}^{x_R} u_xv\\tr dx} &amp;=&amp; \\overbrace{u(x_R)v(x_R)} &amp;-&amp; \\overbrace{u(x_L)v(x_L)}\n\t\\end{array}\n\\end{equation*}\n</code></pre>\n<p>I tried two options, which are both not satisfying to me:</p>\n<ol>\n<li>using alignment points <code>&amp;</code>, but this does not center the terms,</li>\n<li>put everything in a matrix with no delimiter, but this feels a bit hacky and the integrals are too small like they are in inline equations.</li>\n</ol>\n<p>Code for first option:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">$ underbrace(bold(u)^T P D bold(v), vapprox) &amp;+&amp; underbrace(bold(u)^T D^T P bold(v), vapprox) &amp;=&amp;\n  underbrace(bold(u)^T bold(e)_R bold(e)_R^T bold(v), veq) &amp;-&amp; underbrace(bold(u)^T bold(e)_L bold(e)_L^T bold(v), veq) \\\n  overbrace(integral_(x_L)^(x_R) u v_x dif x) &amp;+&amp; overbrace(integral_(x_L)^(x_R) u_x v dif x) &amp;=&amp;\n  overbrace(u(x_R) v(x_R)) &amp;-&amp; overbrace(u(x_L) v(x_L)) $\n</code></pre>\n<p>Code for second option:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#set math.mat(delim: none)\n$ mat(\n    underbrace(bold(u)^T P D bold(v), vapprox), +, underbrace(bold(u)^T D^T P bold(v), vapprox), =, underbrace(bold(u)^T bold(e)_R bold(e)_R^T bold(v), veq), -, underbrace(bold(u)^T bold(e)_L bold(e)_L^T bold(v), veq) ;\n    overbrace(integral_(x_L)^(x_R) u v_x dif x), +, overbrace(integral_(x_L)^(x_R) u_x v dif x), =, overbrace(u(x_R) v(x_R)), -, overbrace(u(x_L) v(x_L))\n) $,\n</code></pre>\n<p>where both of these use</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let vapprox = (rotate(90deg)[$approx$])\n#let veq = (rotate(90deg)[$=$])\n</code></pre>\n<p>See also this document: <a href=\"https://typst.app/project/rOQLu8z7tgsvdfAwf8MAst\">https://typst.app/project/rOQLu8z7tgsvdfAwf8MAst</a><br>\nWhat would be the best way to achieve this?</p>",
      "raw": "I would like to have a multi-line equation, where the different terms in each equation of the different lines are aligned centrally, such that I can relate them to each other with `underbrace` and `overbrace`. The result should look like similar to this:\n![image|690x166](upload://l7rjwpLjKIAE3hTcRQYgg4sosV7.png)\n\nwhich I created in LaTeX with\n```\n\\begin{equation*}\n\t\\begin{array}{ccccccc}\n\t\t\\underbrace{\\bm u^TPD\\bm v}_{\\vapprox} &+& \\underbrace{\\bm u^TD^TP\\bm v}_{\\vapprox} &=& \\underbrace{\\bm u^T\\bm e_R\\bm e_R^T\\bm v}_{\\veq} &-& \\underbrace{\\bm u^T\\bm e_L\\bm e_L^T\\bm v}_{\\veq}\\\\\n\t\t\\overbrace{\\displaystyle\\int_{x_L}^{x_R} uv_x\\tr dx} &+& \\overbrace{\\displaystyle\\int_{x_L}^{x_R} u_xv\\tr dx} &=& \\overbrace{u(x_R)v(x_R)} &-& \\overbrace{u(x_L)v(x_L)}\n\t\\end{array}\n\\end{equation*}\n```\nI tried two options, which are both not satisfying to me:\n1. using alignment points `&`, but this does not center the terms,\n2. put everything in a matrix with no delimiter, but this feels a bit hacky and the integrals are too small like they are in inline equations.\n\nCode for first option:\n```typ\n$ underbrace(bold(u)^T P D bold(v), vapprox) &+& underbrace(bold(u)^T D^T P bold(v), vapprox) &=&\n  underbrace(bold(u)^T bold(e)_R bold(e)_R^T bold(v), veq) &-& underbrace(bold(u)^T bold(e)_L bold(e)_L^T bold(v), veq) \\\n  overbrace(integral_(x_L)^(x_R) u v_x dif x) &+& overbrace(integral_(x_L)^(x_R) u_x v dif x) &=&\n  overbrace(u(x_R) v(x_R)) &-& overbrace(u(x_L) v(x_L)) $\n```\nCode for second option:\n```typ\n#set math.mat(delim: none)\n$ mat(\n    underbrace(bold(u)^T P D bold(v), vapprox), +, underbrace(bold(u)^T D^T P bold(v), vapprox), =, underbrace(bold(u)^T bold(e)_R bold(e)_R^T bold(v), veq), -, underbrace(bold(u)^T bold(e)_L bold(e)_L^T bold(v), veq) ;\n    overbrace(integral_(x_L)^(x_R) u v_x dif x), +, overbrace(integral_(x_L)^(x_R) u_x v dif x), =, overbrace(u(x_R) v(x_R)), -, overbrace(u(x_L) v(x_L))\n) $,\n```\nwhere both of these use\n```typ\n#let vapprox = (rotate(90deg)[$approx$])\n#let veq = (rotate(90deg)[$=$])\n```\nSee also this document: https://typst.app/project/rOQLu8z7tgsvdfAwf8MAst\nWhat would be the best way to achieve this?",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 1,
      "reads": 48,
      "score": 3299.4,
      "accepted_answer": false,
      "trust_level": 1,
      "user_id": 667
    },
    {
      "id": 5314,
      "post_number": 2,
      "username": "lampert",
      "name": "Joshua Lampert",
      "created_at": "2024-11-08T14:21:06.117Z",
      "updated_at": "2024-11-08T14:21:06.117Z",
      "cooked": "<p>Of course I could use <code>display</code> in the second option to enlarge the integrals and this already comes close to what I want, but I am still wondering if there is a better option without <code>mat</code>.</p>",
      "raw": "Of course I could use `display` in the second option to enlarge the integrals and this already comes close to what I want, but I am still wondering if there is a better option without `mat`.",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 0,
      "reads": 43,
      "score": 28.4,
      "accepted_answer": false,
      "trust_level": 1,
      "user_id": 667
    },
    {
      "id": 5315,
      "post_number": 3,
      "username": "quachpas",
      "name": "Pascal Quach",
      "created_at": "2024-11-08T14:25:10.826Z",
      "updated_at": "2024-11-08T14:25:35.539Z",
      "cooked": "<p>I think you can use a grid for that!</p>",
      "raw": "I think you can use a grid for that!",
      "reply_to_post_number": 2,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 43,
      "score": 33.4,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 258
    },
    {
      "id": 5316,
      "post_number": 4,
      "username": "Eric",
      "name": "Eric Biedert",
      "created_at": "2024-11-08T15:20:39.238Z",
      "updated_at": "2024-11-08T15:20:39.238Z",
      "cooked": "<p>Using a grid will probably lead to misaligned baselines. I may have overdone it a bit, but here is a function for math-grids with custom gutter and alignments. It even allows passing arrays for alignments (like in default grids), and overriding the alignment of specific cells by wrapping them with the standard <code>align</code> element. <img src=\"https://forum.typst.app/images/emoji/apple/grin.png?v=12\" title=\":grin:\" class=\"emoji\" alt=\":grin:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>\n<details>\n<summary>\nFunction Definition</summary>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let mgrid(align: center, gutter: 1em, eq) = context {\n  if eq.func() != [].func() {\n    // Body is just a single element, so leave it as is.\n    return eq\n  }\n\n  // Split body at linebreaks and alignment points.\n  let lines = eq.children.split(linebreak()).map(line =&gt; line.split($&amp;$.body).map(array.join))\n\n  // Calculate width of each column.\n  let widths = ()\n  for line in lines {\n    for (i, part) in line.enumerate() {\n      let width = measure(math.equation(block: true, numbering: none, part)).width\n      if i &gt;= widths.len() {\n        widths.push(width)\n      } else {\n        widths.at(i) = calc.max(widths.at(i), width)\n      }\n    }\n  }\n\n  // Resolve alignment for each column.\n  let aligns = range(widths.len()).map(i =&gt; {\n    if type(align) == alignment { align }\n    else if type(align) == array { align.at(calc.rem(i, align.len())) }\n    else { panic(\"expected alignment or array as 'align'\") }\n  })\n\n  // Try to flatten sequence elements (to allow access to an underlying align\n  // element for overriding the alignment of single parts).\n  let flatten(seq) = {\n    if type(seq) != content or seq.func() != [].func() {\n      return seq\n    }\n    let children = seq.children.filter(c =&gt; c != [ ])\n    if children.len() == 1 { children.first() } else { seq }\n  }\n\n  // Display parts centered in each column and add gutter.\n  let layout-line(line) = {\n    if line.len() &lt; widths.len() {\n      line += (none,) * (widths.len() - line.len())\n    }\n    \n    line.zip(widths, aligns).map(((part, width, align)) =&gt; {\n      let part = flatten(part)\n      let part-width = measure(math.equation(block: true, numbering: none, part)).width\n      let delta = width - part-width\n\n      // Check if alignment is overridden.\n      if type(part) == content and part.func() == std.align {\n        align = part.alignment.x\n      }\n      \n      let (start, end) = if align == center {( h(delta/2), h(delta/2) )}\n                         else if align == left {( none, h(delta) )}\n                         else if align == right {( h(delta), none )}\n\n      start + part + end\n    }).join(h(gutter))\n  }\n\n  lines.map(layout-line).join(linebreak())\n}\n</code></pre>\n</details>\n<p>For your case, the use then looks like this:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">// Use display math here so that the bounds are correct.\n#let vapprox = rotate(90deg, $ approx $)\n#let veq = rotate(90deg, $ = $)\n\n$ mgrid(gutter: #1em,\n    underbrace(bold(u)^T P D bold(v))\n      &amp; + &amp; underbrace(bold(u)^T D^T P bold(v))\n      &amp; = &amp; underbrace(bold(u)^T bold(e)_R bold(e)_R^T bold(v))\n      &amp; - &amp; underbrace(bold(u)^T bold(e)_L bold(e)_L^T bold(v)) \\\n\n    vapprox &amp;&amp; vapprox &amp;&amp; veq &amp;&amp; veq \\\n  \n    overbrace(integral_(x_L)^(x_R) u v_x dif x)\n      &amp; + &amp; overbrace(integral_(x_L)^(x_R) u_x v dif x)\n      &amp; = &amp; overbrace(u(x_R) v(x_R))\n      &amp; - &amp; overbrace(u(x_L) v(x_L)) \\\n) $\n</code></pre>\n<p><img src=\"https://forum.typst.app/uploads/default/original/2X/0/02f025c5f68f39297badf9566695c1057d1544ef.png\" alt=\"Output of the above code.\" data-base62-sha1=\"pZt3FQZIYmbsVqlpBAxcSgEjpl\" width=\"542\" height=\"146\"></p>",
      "raw": "Using a grid will probably lead to misaligned baselines. I may have overdone it a bit, but here is a function for math-grids with custom gutter and alignments. It even allows passing arrays for alignments (like in default grids), and overriding the alignment of specific cells by wrapping them with the standard `align` element. :grin: \n\n[details=\"Function Definition\"]\n\n```typ\n#let mgrid(align: center, gutter: 1em, eq) = context {\n  if eq.func() != [].func() {\n    // Body is just a single element, so leave it as is.\n    return eq\n  }\n\n  // Split body at linebreaks and alignment points.\n  let lines = eq.children.split(linebreak()).map(line => line.split($&$.body).map(array.join))\n\n  // Calculate width of each column.\n  let widths = ()\n  for line in lines {\n    for (i, part) in line.enumerate() {\n      let width = measure(math.equation(block: true, numbering: none, part)).width\n      if i >= widths.len() {\n        widths.push(width)\n      } else {\n        widths.at(i) = calc.max(widths.at(i), width)\n      }\n    }\n  }\n\n  // Resolve alignment for each column.\n  let aligns = range(widths.len()).map(i => {\n    if type(align) == alignment { align }\n    else if type(align) == array { align.at(calc.rem(i, align.len())) }\n    else { panic(\"expected alignment or array as 'align'\") }\n  })\n\n  // Try to flatten sequence elements (to allow access to an underlying align\n  // element for overriding the alignment of single parts).\n  let flatten(seq) = {\n    if type(seq) != content or seq.func() != [].func() {\n      return seq\n    }\n    let children = seq.children.filter(c => c != [ ])\n    if children.len() == 1 { children.first() } else { seq }\n  }\n\n  // Display parts centered in each column and add gutter.\n  let layout-line(line) = {\n    if line.len() < widths.len() {\n      line += (none,) * (widths.len() - line.len())\n    }\n    \n    line.zip(widths, aligns).map(((part, width, align)) => {\n      let part = flatten(part)\n      let part-width = measure(math.equation(block: true, numbering: none, part)).width\n      let delta = width - part-width\n\n      // Check if alignment is overridden.\n      if type(part) == content and part.func() == std.align {\n        align = part.alignment.x\n      }\n      \n      let (start, end) = if align == center {( h(delta/2), h(delta/2) )}\n                         else if align == left {( none, h(delta) )}\n                         else if align == right {( h(delta), none )}\n\n      start + part + end\n    }).join(h(gutter))\n  }\n\n  lines.map(layout-line).join(linebreak())\n}\n```\n\n[/details]\n\nFor your case, the use then looks like this:\n\n```typ\n// Use display math here so that the bounds are correct.\n#let vapprox = rotate(90deg, $ approx $)\n#let veq = rotate(90deg, $ = $)\n\n$ mgrid(gutter: #1em,\n    underbrace(bold(u)^T P D bold(v))\n      & + & underbrace(bold(u)^T D^T P bold(v))\n      & = & underbrace(bold(u)^T bold(e)_R bold(e)_R^T bold(v))\n      & - & underbrace(bold(u)^T bold(e)_L bold(e)_L^T bold(v)) \\\n\n    vapprox && vapprox && veq && veq \\\n  \n    overbrace(integral_(x_L)^(x_R) u v_x dif x)\n      & + & overbrace(integral_(x_L)^(x_R) u_x v dif x)\n      & = & overbrace(u(x_R) v(x_R))\n      & - & overbrace(u(x_L) v(x_L)) \\\n) $\n```\n\n![Output of the above code.|678x183, 80%](upload://pZt3FQZIYmbsVqlpBAxcSgEjpl.png)",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 6,
      "reads": 44,
      "score": 178.6,
      "accepted_answer": true,
      "trust_level": 2,
      "user_id": 88
    },
    {
      "id": 5319,
      "post_number": 5,
      "username": "lampert",
      "name": "Joshua Lampert",
      "created_at": "2024-11-08T17:47:15.976Z",
      "updated_at": "2024-11-08T17:47:15.976Z",
      "cooked": "<p>Wow, that’s pretty awesome <a class=\"mention\" href=\"/u/eric\">@Eric</a>. This is a function I will likely use more often in the future. Really helpful. Thanks a lot for your effort <a class=\"mention\" href=\"/u/eric\">@Eric</a>!</p>",
      "raw": "Wow, that's pretty awesome @Eric. This is a function I will likely use more often in the future. Really helpful. Thanks a lot for your effort @Eric!",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 35,
      "score": 26.8,
      "accepted_answer": false,
      "trust_level": 1,
      "user_id": 667
    }
  ],
  "scraped_at": "2025-06-10T09:55:17.523006"
}