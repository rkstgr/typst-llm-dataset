{
  "topic_metadata": {
    "id": 778,
    "title": "Can I attach and update state in metadata?",
    "slug": "can-i-attach-and-update-state-in-metadata",
    "posts_count": 6,
    "created_at": "2024-09-28T17:52:51.790Z",
    "last_posted_at": "2024-09-29T13:13:03.145Z",
    "views": 201,
    "like_count": 5,
    "reply_count": 2,
    "has_accepted_answer": true,
    "accepted_answer_post_number": 2,
    "accepted_answer_username": "SillyFreak",
    "tags": [
      "scripting",
      "state",
      "metadata"
    ],
    "category_id": 5,
    "participant_count": 3,
    "word_count": 771
  },
  "posts": [
    {
      "id": 2887,
      "post_number": 1,
      "username": "gabe",
      "name": "",
      "created_at": "2024-09-28T17:52:51.938Z",
      "updated_at": "2024-09-28T17:52:51.938Z",
      "cooked": "<p>I have some global state that I want to be able to query. Multiple files contribute their data to this state, and each file gets its own label. So, it would be natural to put all the files’ state into their own metadata blocks, query them by label, and update them when needed.</p>\n<p>I tried the following, but the state isn’t updated.</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#metadata(state(\"test\", 0)) &lt;test&gt;\n#context query(&lt;test&gt;).first().value.update(cs =&gt; {\n  cs += 1\n})\n#context query(&lt;test&gt;)\n</code></pre>\n<p>Outputs: <code>(metadata(value: state(\"test\", 0)),)</code>.</p>",
      "raw": "I have some global state that I want to be able to query. Multiple files contribute their data to this state, and each file gets its own label. So, it would be natural to put all the files' state into their own metadata blocks, query them by label, and update them when needed.\n\nI tried the following, but the state isn't updated.\n\n```typ\n#metadata(state(\"test\", 0)) <test>\n#context query(<test>).first().value.update(cs => {\n  cs += 1\n})\n#context query(<test>)\n```\n\nOutputs: `(metadata(value: state(\"test\", 0)),)`.",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 34,
      "score": 581.8,
      "accepted_answer": false,
      "trust_level": 1,
      "user_id": 433
    },
    {
      "id": 2888,
      "post_number": 2,
      "username": "SillyFreak",
      "name": "SillyFreak",
      "created_at": "2024-09-28T18:16:29.647Z",
      "updated_at": "2024-09-28T18:58:45.919Z",
      "cooked": "<p>Careful, there are a few things in your post that make me think you have the wrong mental model.</p>\n<p>first, the <code>update()</code> method. This works by returning a <em>new</em> value <em>based on</em> the previous one. However, you try to <em>modify</em> the parameter:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">// BAD\n#state(\"test\", 0).update(cs =&gt; {\n  // this statement has no result, only a side effect\n  // its result is thus implicitly none\n  cs += 1\n  // the block ends here, returning the last expression's value\n  // instead of incrementing, the state is now none\n})\n\n// GOOD\n#state(\"test\", 0).update(cs =&gt; {\n  cs + 1\n  // the block ends here, returning 1\n})\n</code></pre>\n<p>second, you’re not actually retrieving the state’s current value:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">// BAD: you're just looking up the metadata\n#context query(&lt;test&gt;)\n// gives (metadata(value: state(\"test\", 0)),)\n\n// BETTER: extracting the state out of the metadata\n#context query(&lt;test&gt;).first().value\n// gives state(\"test\", 0)\n\n// GOOD\n#context query(&lt;test&gt;).first().value.get()\n// gives the actual state value\n</code></pre>\n<p>the state itself is not modified by an update, thus the “BETTER” code always has a 0 inside: that’s how the state was set up. Only with <code>get()</code> do you extract the value.</p>\n<p>Finally, both states and labels have globally unique names, so putting state inside labelled metadata doesn’t bring much benefit. Also, state is <em>only</em> identified by the name:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#metadata(state(\"test\", 0)) &lt;test&gt;\n#metadata(state(\"test\", 0)) &lt;test2&gt;\n#context query(&lt;test&gt;).first().value.update(cs =&gt; cs + 1)\n\n#context query(&lt;test2&gt;).first().value.get()\n// prints 1, because the \"test\" state was updated\n</code></pre>\n<p>Thus, I’d recommend to just replace labels with state names, that makes more sense.</p>\n<p>One final note on something peculiar – consider this:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#metadata(state(\"test\", 0)) &lt;test&gt;\n#metadata(state(\"test\", 1)) &lt;test2&gt;\n#context query(&lt;test&gt;).first().value.update(cs =&gt; cs + 1)\n\n#context query(&lt;test2&gt;).first().value.get()\n// prints 2, because the \"test\" state was updated from its initial value of 1\n</code></pre>\n<p>state updates affect all state “objects” of the same name, but the initial value of the <em>specific</em> object matters! It’s therefore not recommended to create multiple different states. My recommendation is to put each state in a variable and import that variable.</p>",
      "raw": "Careful, there are a few things in your post that make me think you have the wrong mental model.\n\nfirst, the `update()` method. This works by returning a _new_ value _based on_ the previous one. However, you try to _modify_ the parameter:\n\n```typ\n// BAD\n#state(\"test\", 0).update(cs => {\n  // this statement has no result, only a side effect\n  // its result is thus implicitly none\n  cs += 1\n  // the block ends here, returning the last expression's value\n  // instead of incrementing, the state is now none\n})\n\n// GOOD\n#state(\"test\", 0).update(cs => {\n  cs + 1\n  // the block ends here, returning 1\n})\n```\n\nsecond, you're not actually retrieving the state's current value:\n\n```typ\n// BAD: you're just looking up the metadata\n#context query(<test>)\n// gives (metadata(value: state(\"test\", 0)),)\n\n// BETTER: extracting the state out of the metadata\n#context query(<test>).first().value\n// gives state(\"test\", 0)\n\n// GOOD\n#context query(<test>).first().value.get()\n// gives the actual state value\n```\n\nthe state itself is not modified by an update, thus the \"BETTER\" code always has a 0 inside: that's how the state was set up. Only with `get()` do you extract the value.\n\nFinally, both states and labels have globally unique names, so putting state inside labelled metadata doesn't bring much benefit. Also, state is _only_ identified by the name:\n\n```typ\n#metadata(state(\"test\", 0)) <test>\n#metadata(state(\"test\", 0)) <test2>\n#context query(<test>).first().value.update(cs => cs + 1)\n\n#context query(<test2>).first().value.get()\n// prints 1, because the \"test\" state was updated\n```\n\nThus, I'd recommend to just replace labels with state names, that makes more sense.\n\nOne final note on something peculiar -- consider this:\n\n```typ\n#metadata(state(\"test\", 0)) <test>\n#metadata(state(\"test\", 1)) <test2>\n#context query(<test>).first().value.update(cs => cs + 1)\n\n#context query(<test2>).first().value.get()\n// prints 2, because the \"test\" state was updated from its initial value of 1\n```\n\nstate updates affect all state \"objects\" of the same name, but the initial value of the _specific_ object matters! It's therefore not recommended to create multiple different states. My recommendation is to put each state in a variable and import that variable.",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 2,
      "reads": 34,
      "score": 141.8,
      "accepted_answer": true,
      "trust_level": 3,
      "user_id": 32
    },
    {
      "id": 2890,
      "post_number": 3,
      "username": "gabe",
      "name": "",
      "created_at": "2024-09-28T18:59:01.742Z",
      "updated_at": "2024-09-28T18:59:24.458Z",
      "cooked": "<p>Thanks for taking the time to explain all the little details.</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#state(\"test\", 0).update(cs =&gt; cs += 1)\n// Wouldn't even make sense, because if we don't use a function we would do, for example:\n#state(\"test\", 0).update(1)\n</code></pre>\n<p>Is the following description of states accurate? States themselves never change, but instead we put down markers (which live in the content) that are used to compute what the value of state at a given position should be. The markers that we put down only have the name of the state and the desired operation. When we call state.get(), we’re taking that state’s initial value, applying all the markers that match its name that we’ve seen thus far, and giving the result.</p>\n<p>I have a related question, then, about another function of metadata. Since the contained state itself isn’t updated, is there a way to query the final value of a state from the CLI?</p>",
      "raw": "Thanks for taking the time to explain all the little details. \n\n```typ\n#state(\"test\", 0).update(cs => cs += 1)\n// Wouldn't even make sense, because if we don't use a function we would do, for example:\n#state(\"test\", 0).update(1)\n```\n\nIs the following description of states accurate? States themselves never change, but instead we put down markers (which live in the content) that are used to compute what the value of state at a given position should be. The markers that we put down only have the name of the state and the desired operation. When we call state.get(), we're taking that state's initial value, applying all the markers that match its name that we've seen thus far, and giving the result.\n\nI have a related question, then, about another function of metadata. Since the contained state itself isn't updated, is there a way to query the final value of a state from the CLI?",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 2,
      "reads": 24,
      "score": 94.8,
      "accepted_answer": false,
      "trust_level": 1,
      "user_id": 433
    },
    {
      "id": 2891,
      "post_number": 4,
      "username": "SillyFreak",
      "name": "SillyFreak",
      "created_at": "2024-09-28T19:02:49.509Z",
      "updated_at": "2024-09-28T19:02:49.509Z",
      "cooked": "<p>Your description is spot-on! the <code>state</code> itself is immutable, and <code>get()</code> collects all <code>update()</code> contents up to that point.</p>\n<aside class=\"quote no-group\" data-username=\"gabe\" data-post=\"3\" data-topic=\"778\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/user_avatar/forum.typst.app/gabe/48/620_2.png\" class=\"avatar\"> gabe:</div>\n<blockquote>\n<p>I have a related question, then, about another function of metadata. Since the contained state itself isn’t updated, is there a way to query the final value of a state from the CLI?</p>\n</blockquote>\n</aside>\n<p>I think this would make a decent question on its own that could help people in the future, would you mind opening a new question with a fitting title for it?</p>",
      "raw": "Your description is spot-on! the `state` itself is immutable, and `get()` collects all `update()` contents up to that point.\n\n[quote=\"gabe, post:3, topic:778\"]\nI have a related question, then, about another function of metadata. Since the contained state itself isn’t updated, is there a way to query the final value of a state from the CLI?\n[/quote]\n\nI think this would make a decent question on its own that could help people in the future, would you mind opening a new question with a fitting title for it?",
      "reply_to_post_number": 3,
      "reply_count": 1,
      "quote_count": 1,
      "like_count": 1,
      "reads": 24,
      "score": 34.8,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 32
    },
    {
      "id": 2893,
      "post_number": 5,
      "username": "gabe",
      "name": "",
      "created_at": "2024-09-28T19:08:47.441Z",
      "updated_at": "2024-09-28T19:08:47.441Z",
      "cooked": "<p>Great, thank you! I’ll go ahead and open a new question.</p>",
      "raw": "Great, thank you! I'll go ahead and open a new question.",
      "reply_to_post_number": 4,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 23,
      "score": 9.6,
      "accepted_answer": false,
      "trust_level": 1,
      "user_id": 433
    },
    {
      "id": 2942,
      "post_number": 6,
      "username": "Andrew",
      "name": "",
      "created_at": "2024-09-29T13:13:03.145Z",
      "updated_at": "2024-09-29T13:13:03.145Z",
      "cooked": "<p>I will link <a href=\"https://forum.typst.app/t/how-to-create-invisible-label/775/8\" class=\"inline-onebox\">How to create invisible label? - #8 by Andrew</a> to again mention that <code>cs =+ 1</code> will return <code>none</code> and that for integer number counting using <code>counter</code> over <code>state</code> is the preferred way. And subsequently, all counters are initialized with <code>0</code> value, and therefore you don’t need to explicitly set it in any way.</p>",
      "raw": "I will link https://forum.typst.app/t/how-to-create-invisible-label/775/8 to again mention that `cs =+ 1` will return `none` and that for integer number counting using `counter` over `state` is the preferred way. And subsequently, all counters are initialized with `0` value, and therefore you don't need to explicitly set it in any way.",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 23,
      "score": 29.6,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 51
    }
  ],
  "scraped_at": "2025-06-10T09:57:51.634512"
}