{
  "topic_metadata": {
    "id": 3849,
    "title": "How to write a show rule that only affects the current section?",
    "slug": "how-to-write-a-show-rule-that-only-affects-the-current-section",
    "posts_count": 6,
    "created_at": "2025-04-28T13:02:18.875Z",
    "last_posted_at": "2025-04-29T15:39:56.204Z",
    "views": 141,
    "like_count": 5,
    "reply_count": 2,
    "has_accepted_answer": true,
    "accepted_answer_post_number": 5,
    "accepted_answer_username": "bluss",
    "tags": [
      "styling"
    ],
    "category_id": 5,
    "participant_count": 3,
    "word_count": 1646
  },
  "posts": [
    {
      "id": 11720,
      "post_number": 1,
      "username": "bluss",
      "name": "Ulrik",
      "created_at": "2025-04-28T13:02:18.995Z",
      "updated_at": "2025-04-28T23:38:18.177Z",
      "cooked": "<p>Is there a way to write a show rule that only applies to the current section (as defined by headings), without having to enclose all such sections in <code>[]</code>?</p>\n<p>Something like the following:</p>\n<pre data-code-wrap=\"typst\"><code class=\"lang-typst\">= A1\n// this is a special show rule that's only valid until `A2` (exclusive)\n#show: until-next-heading.with(x =&gt; text(red, x))\n\nThis text will be red.\n\n// This is a special show rule that's only valid until `B1` (exclusive)\n// because we are currently inside a heading level 1.\n#show: until-next-heading-same-level.with(underline)\n\nAnd this text will be red and underlined.\n\n== A2\nThis text will be black and underlined.\n\n== A3\nThis text will be black and underlined\n\n= B1\nThis text will be black.\n</code></pre>\n<p>I’m not sure if this is possible in current typst. Maybe using something that minces and reprocesses content (sequence/internal typst type inspection)? But hopefully we prefer solutions that use documented typst functionality instead, if possible.</p>",
      "raw": "Is there a way to write a show rule that only applies to the current section (as defined by headings), without having to enclose all such sections in `[]`?\n\nSomething like the following:\n\n```typst\n= A1\n// this is a special show rule that's only valid until `A2` (exclusive)\n#show: until-next-heading.with(x => text(red, x))\n\nThis text will be red.\n\n// This is a special show rule that's only valid until `B1` (exclusive)\n// because we are currently inside a heading level 1.\n#show: until-next-heading-same-level.with(underline)\n\nAnd this text will be red and underlined.\n\n== A2\nThis text will be black and underlined.\n\n== A3\nThis text will be black and underlined\n\n= B1\nThis text will be black.\n```\n\nI'm not sure if this is possible in current typst. Maybe using something that minces and reprocesses content (sequence/internal typst type inspection)? But hopefully we prefer solutions that use documented typst functionality instead, if possible.",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 39,
      "score": 262.8,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 1272
    },
    {
      "id": 11726,
      "post_number": 2,
      "username": "janekfleper",
      "name": "Janek Fleper",
      "created_at": "2025-04-28T14:49:51.345Z",
      "updated_at": "2025-04-28T14:58:51.691Z",
      "cooked": "<p>I found a solution that allows you to specify rules that contain a function, a filter function and a stop function. Extending this to have a specific start function/condition should also be possible. Currently the show rule starts wherever it is called. The first text line in your example is therefore red and underlined (for now).</p>\n<p>The idea is to use a general show rule (as you already did in your example) where you iterate over all children of the content sequence. The iteration for each rule is “stopped” when the corresponding function returns true. The filter allows you to exclude content from the rule, e.g. the headings in your case.</p>\n<p>This solution is also compatible with other show rules as long as you call them <em>before</em> the general show rule. E.g. the following show rule to change the font color in level 2 headings will work just fine:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#show heading.where(level: 2): set text(blue)\n</code></pre>\n<p>Some comments on the code:</p>\n<ul>\n<li>If the (general) body does not have the “children” key, the rules are not applied. This happened when I applied other show rules <em>after</em> the general rule. I don’t know how many other cases there are.</li>\n<li>If you don’t want to apply a filter, just set the return value of the function to <code>true</code>. There is currently no check if a rule has the “filter” key.</li>\n<li>You can target specific headings in the stop function by checking more than the level. I used the actual content here as an example. This is not very elegant yet, checking the heading label here would probably be better. But I will leave this up to you. <img src=\"https://forum.typst.app/images/emoji/apple/slight_smile.png?v=12\" title=\":slight_smile:\" class=\"emoji\" alt=\":slight_smile:\" loading=\"lazy\" width=\"20\" height=\"20\"></li>\n</ul>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let apply-rule(children, rule) = {\n  let i = 0\n  for child in children {\n    if rule.at(\"stop\")(child) { break }\n    if rule.at(\"filter\")(child) { (rule.at(\"func\")(child),) } else { (child,) }\n    i += 1\n  }\n  children.slice(i,)\n}\n\n#let rules = (\n  (\n    func: text.with(red),\n    filter: child =&gt; child.func() != heading,\n    stop: child =&gt; child.func() == heading and child.depth == 2 and child.body == [A2],\n  ),\n  (\n    func: underline,\n    filter: child =&gt; child.func() != heading,\n    stop: child =&gt; child.func() == heading and child.depth == 1,\n  ),\n)\n\n#show: it =&gt; {\n  let children = if it.has(\"children\") { it.children } else { return it }\n  for rule in rules { children = apply-rule(children, rule) }\n  children.join([])\n}\n</code></pre>\n<details>\n<summary>\nYour example will then look like this</summary>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://forum.typst.app/uploads/default/original/2X/7/7a13fe8fe0ed4f8c9e1bc4d2d646bbb5a7202f3b.jpeg\" data-download-href=\"https://forum.typst.app/uploads/default/7a13fe8fe0ed4f8c9e1bc4d2d646bbb5a7202f3b\" title=\"forum_3849_show-rules-per-section\"><img src=\"https://forum.typst.app/uploads/default/optimized/2X/7/7a13fe8fe0ed4f8c9e1bc4d2d646bbb5a7202f3b_2_529x499.jpeg\" alt=\"forum_3849_show-rules-per-section\" data-base62-sha1=\"hpX5wJWHlhqGRDZY0DRLyTuONNF\" width=\"529\" height=\"499\" srcset=\"https://forum.typst.app/uploads/default/optimized/2X/7/7a13fe8fe0ed4f8c9e1bc4d2d646bbb5a7202f3b_2_529x499.jpeg, https://forum.typst.app/uploads/default/optimized/2X/7/7a13fe8fe0ed4f8c9e1bc4d2d646bbb5a7202f3b_2_793x748.jpeg 1.5x, https://forum.typst.app/uploads/default/optimized/2X/7/7a13fe8fe0ed4f8c9e1bc4d2d646bbb5a7202f3b_2_1058x998.jpeg 2x\" data-dominant-color=\"F7F4F4\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">forum_3849_show-rules-per-section</span><span class=\"informations\">1682×1588 206 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n</details>",
      "raw": "I found a solution that allows you to specify rules that contain a function, a filter function and a stop function. Extending this to have a specific start function/condition should also be possible. Currently the show rule starts wherever it is called. The first text line in your example is therefore red and underlined (for now).\n\nThe idea is to use a general show rule (as you already did in your example) where you iterate over all children of the content sequence. The iteration for each rule is \"stopped\" when the corresponding function returns true. The filter allows you to exclude content from the rule, e.g. the headings in your case.\n\nThis solution is also compatible with other show rules as long as you call them _before_ the general show rule. E.g. the following show rule to change the font color in level 2 headings will work just fine:\n```typ\n#show heading.where(level: 2): set text(blue)\n```\n\nSome comments on the code:\n- If the (general) body does not have the \"children\" key, the rules are not applied. This happened when I applied other show rules _after_ the general rule. I don't know how many other cases there are.\n- If you don't want to apply a filter, just set the return value of the function to `true`. There is currently no check if a rule has the \"filter\" key.\n- You can target specific headings in the stop function by checking more than the level. I used the actual content here as an example. This is not very elegant yet, checking the heading label here would probably be better. But I will leave this up to you. :slight_smile: \n```typ\n#let apply-rule(children, rule) = {\n  let i = 0\n  for child in children {\n    if rule.at(\"stop\")(child) { break }\n    if rule.at(\"filter\")(child) { (rule.at(\"func\")(child),) } else { (child,) }\n    i += 1\n  }\n  children.slice(i,)\n}\n\n#let rules = (\n  (\n    func: text.with(red),\n    filter: child => child.func() != heading,\n    stop: child => child.func() == heading and child.depth == 2 and child.body == [A2],\n  ),\n  (\n    func: underline,\n    filter: child => child.func() != heading,\n    stop: child => child.func() == heading and child.depth == 1,\n  ),\n)\n\n#show: it => {\n  let children = if it.has(\"children\") { it.children } else { return it }\n  for rule in rules { children = apply-rule(children, rule) }\n  children.join([])\n}\n```\n\n[details=\"Your example will then look like this\"]\n![forum_3849_show-rules-per-section|529x499, 100%](upload://hpX5wJWHlhqGRDZY0DRLyTuONNF.jpeg)\n[/details]",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 1,
      "reads": 37,
      "score": 32.4,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 69
    },
    {
      "id": 11736,
      "post_number": 3,
      "username": "Andrew",
      "name": "",
      "created_at": "2025-04-28T17:31:15.183Z",
      "updated_at": "2025-04-28T17:31:15.183Z",
      "cooked": "<p>You can make use of breakpoint-metadata or toggle-state to insert breakpoints in the document. Then either use a global show rule to iterate over content and check for breakpoints, or query the elements in the specified region, if they are queryable. Or use an element show rule and check if it is within the region where a specific styling is needed to be applied. Or the most basic thing: use <code>apply</code> and <code>unapply</code> sets of styling: just restore the initial styling after a specific point. With rule revoking, this will become much easier.</p>\n<aside class=\"onebox githubissue\" data-onebox-src=\"https://github.com/typst/typst/issues/420\">\n  <header class=\"source\">\n\n      <a href=\"https://github.com/typst/typst/issues/420\" target=\"_blank\" rel=\"noopener nofollow ugc\">github.com/typst/typst</a>\n  </header>\n\n  <article class=\"onebox-body\">\n    <div class=\"github-row\">\n  <div class=\"github-icon-container\" title=\"Issue\" data-github-private-repo=\"false\">\n\t  <svg width=\"60\" height=\"60\" class=\"github-icon\" viewBox=\"0 0 14 16\" aria-hidden=\"true\"><path fill-rule=\"evenodd\" d=\"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z\"></path></svg>\n  </div>\n\n  <div class=\"github-info-container\">\n    <h4>\n      <a href=\"https://github.com/typst/typst/issues/420\" target=\"_blank\" rel=\"noopener nofollow ugc\">Resetting `show` and `set` to its default / Revoke rules</a>\n    </h4>\n\n    <div class=\"github-info\">\n      <div class=\"date\">\n        opened <span class=\"discourse-local-date\" data-format=\"ll\" data-date=\"2023-03-29\" data-time=\"09:57:11\" data-timezone=\"UTC\">09:57AM - 29 Mar 23 UTC</span>\n      </div>\n\n\n      <div class=\"user\">\n        <a href=\"https://github.com/FedericoStra\" target=\"_blank\" rel=\"noopener nofollow ugc\">\n          <img alt=\"FedericoStra\" src=\"https://forum.typst.app/uploads/default/original/2X/a/a090875a5024a5a2c9f71f1e0226f5a5d6d77a2b.jpeg\" class=\"onebox-avatar-inline\" width=\"20\" height=\"20\" data-dominant-color=\"D1D1D1\">\n          FedericoStra\n        </a>\n      </div>\n    </div>\n\n    <div class=\"labels\">\n        <span style=\"display:inline-block;margin-top:2px;background-color: #B8B8B8;padding: 2px;border-radius: 4px;color: #fff;margin-left: 3px;\">\n          feature request\n        </span>\n        <span style=\"display:inline-block;margin-top:2px;background-color: #B8B8B8;padding: 2px;border-radius: 4px;color: #fff;margin-left: 3px;\">\n          styling\n        </span>\n    </div>\n  </div>\n</div>\n\n  <div class=\"github-row\">\n    <p class=\"github-body-container\">I think we need a way to reset [`show` rules](https://typst.app/docs/reference/s<span class=\"show-more-container\"><a href=\"\" rel=\"noopener\" class=\"show-more\">…</a></span><span class=\"excerpt hidden\">tyling/#show-rules) to their default.\n\n```typst\n// introduce a custom style for all text objects\n#show text: box.with(stroke: .4pt + red, outset: (bottom: .3em, rest: .1em), radius: .1em)\n\nSome simple text.\nSome other text wrapped in a tight red box.\n\n// how do we turn it off?!\n#show text: it =&gt; it\n\nUgh!\n```\n\nSimilarly, after a [`set` rule](https://typst.app/docs/reference/styling/#set-rules) there is no simple way of \"unsetting\" it (reverting to the default), apart from explicitly writing the default or wrapping everything in a scope.</span></p>\n  </div>\n\n  </article>\n\n  <div class=\"onebox-metadata\">\n    \n    \n  </div>\n\n  <div style=\"clear: both\"></div>\n</aside>\n",
      "raw": "You can make use of breakpoint-metadata or toggle-state to insert breakpoints in the document. Then either use a global show rule to iterate over content and check for breakpoints, or query the elements in the specified region, if they are queryable. Or use an element show rule and check if it is within the region where a specific styling is needed to be applied. Or the most basic thing: use `apply` and `unapply` sets of styling: just restore the initial styling after a specific point. With rule revoking, this will become much easier.\n\nhttps://github.com/typst/typst/issues/420",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 1,
      "reads": 33,
      "score": 26.6,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 51
    },
    {
      "id": 11740,
      "post_number": 4,
      "username": "bluss",
      "name": "Ulrik",
      "created_at": "2025-04-28T17:38:57.175Z",
      "updated_at": "2025-04-28T17:38:57.175Z",
      "cooked": "<aside class=\"quote no-group\" data-username=\"janekfleper\" data-post=\"2\" data-topic=\"3849\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/letter_avatar_proxy/v4/letter/j/8F38B1/48.png\" class=\"avatar\"> janekfleper:</div>\n<blockquote>\n<p>I found a solution that allows you to specify rules that contain a function</p>\n</blockquote>\n</aside>\n<p>I think that’s very nicely expressed in code. If this was used I’d like to do this but recursively, so that it interacts well with all other styling rules. Not easy, but I guess it can be done. Like you say it has a problem with show rules and other transformations that come after it.</p>\n<aside class=\"quote no-group\" data-username=\"Andrew\" data-post=\"3\" data-topic=\"3849\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/user_avatar/forum.typst.app/andrew/48/62_2.png\" class=\"avatar\"> Andrew:</div>\n<blockquote>\n<p>You can make use of breakpoint-metadata or toggle-state to insert breakpoints in the document.</p>\n</blockquote>\n</aside>\n<p>Thanks for the ideas - I’ll experiment and see if I understand and can realize that. I think I see what you mean with using state.</p>",
      "raw": "[quote=\"janekfleper, post:2, topic:3849\"]\nI found a solution that allows you to specify rules that contain a function\n[/quote]\n\nI think that's very nicely expressed in code. If this was used I'd like to do this but recursively, so that it interacts well with all other styling rules. Not easy, but I guess it can be done. Like you say it has a problem with show rules and other transformations that come after it.\n\n[quote=\"Andrew, post:3, topic:3849\"]\nYou can make use of breakpoint-metadata or toggle-state to insert breakpoints in the document.\n[/quote]\n\nThanks for the ideas - I'll experiment and see if I understand and can realize that. I think I see what you mean with using state.",
      "reply_to_post_number": 2,
      "reply_count": 0,
      "quote_count": 2,
      "like_count": 0,
      "reads": 31,
      "score": 11.2,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 1272
    },
    {
      "id": 11744,
      "post_number": 5,
      "username": "bluss",
      "name": "Ulrik",
      "created_at": "2025-04-28T17:53:37.754Z",
      "updated_at": "2025-04-29T11:42:08.308Z",
      "cooked": "<p>Here’s an initial version of the state tracking and local show rules that Andrew alluded to - if I understand correctly.</p>\n<p>Idea - a state variable keeps track of the current heading.</p>\n<p>A show rule is split into pieces by being applied element by element (for example, to each <code>text</code> or each <code>par</code> or <code>list</code>.) This way we can track state updates that happen between these elements.</p>\n<details>\n<summary>Code and Output</summary>\n<p><img src=\"https://forum.typst.app/uploads/default/original/2X/b/b572d9d642bec223c38f4c4b87cef5e361fda83d.png\" alt=\"bild\" data-base62-sha1=\"pTaukc4EVTcIHHSnWG1VLAPn2cl\" width=\"375\" height=\"396\"></p>\n<pre data-code-wrap=\"typst\"><code class=\"lang-typst\">#let heading-tracker = state(\"heading-tracker\", none)\n\n#show heading: it =&gt; {\n  heading-tracker.update(it)\n  it\n}\n\n/// Apply show rule `rule` to the `body` inside current section\n/// The rule is applied to the given `element` similar to `show &lt;element&gt;: rule`\n#let show-this-section(rule, body, element: text, subsections: false) = context {\n  let start-heading = heading-tracker.get()\n  show element: it =&gt; context {\n    let local-heading = heading-tracker.get()\n    let allow-rule = if subsections {\n      // any higher level than start is the new ancestor\n      let levels = range(1, start-heading.level + 1)\n      let ancestor-selector = selector.or(..levels.map(l =&gt; heading.where(level: l)))\n      let ancestor-heading = query(ancestor-selector\n        .after(start-heading.location())\n        .before(local-heading.location())\n        ).last()\n      ancestor-heading == start-heading\n    } else {\n      start-heading == local-heading\n    }\n    if allow-rule {\n      rule(it)\n    } else {\n      it\n    }\n  }\n  body\n}\n\n= A1\n\n#show: show-this-section.with(text.with(red))\n\nThis text will be red.\n\n#show: show-this-section.with(underline, element: par, subsections: true)\n\nAnd this text will be red and underlined.\n\n== A2\nThis text will be black and underlined.\n\n== A3\n\n#show: show-this-section.with(text.with(blue), element: par, subsections: true)\nThis text will be blue and underlined\n\n= B1\nThis text will be black.\n\n== B2\n\nStill black\n</code></pre>\n<ul>\n<li>Version 1: just using heading name and level in state</li>\n<li>Version 2: use heading element in state and query for ancestor heading</li>\n<li>Version 3: Removed extra nesting of show rule that was not necessary</li>\n<li>Version 4: Fix bug with subsections not reset correctly</li>\n</ul>\n</details>\n<p>This is not everything I’d like to do per section, but it answers the initial question perfectly and so I can’t ask for more in this particular topic. Thanks for the help!</p>",
      "raw": "Here's an initial version of the state tracking and local show rules that Andrew alluded to - if I understand correctly.\n\nIdea - a state variable keeps track of the current heading.\n\nA show rule is split into pieces by being applied element by element (for example, to each `text` or each `par` or `list`.) This way we can track state updates that happen between these elements.\n\n<details>\n<summary>Code and Output</summary>\n\n![bild|375x396](upload://pTaukc4EVTcIHHSnWG1VLAPn2cl.png)\n\n\n```typst\n#let heading-tracker = state(\"heading-tracker\", none)\n\n#show heading: it => {\n  heading-tracker.update(it)\n  it\n}\n\n/// Apply show rule `rule` to the `body` inside current section\n/// The rule is applied to the given `element` similar to `show <element>: rule`\n#let show-this-section(rule, body, element: text, subsections: false) = context {\n  let start-heading = heading-tracker.get()\n  show element: it => context {\n    let local-heading = heading-tracker.get()\n    let allow-rule = if subsections {\n      // any higher level than start is the new ancestor\n      let levels = range(1, start-heading.level + 1)\n      let ancestor-selector = selector.or(..levels.map(l => heading.where(level: l)))\n      let ancestor-heading = query(ancestor-selector\n        .after(start-heading.location())\n        .before(local-heading.location())\n        ).last()\n      ancestor-heading == start-heading\n    } else {\n      start-heading == local-heading\n    }\n    if allow-rule {\n      rule(it)\n    } else {\n      it\n    }\n  }\n  body\n}\n\n= A1\n\n#show: show-this-section.with(text.with(red))\n\nThis text will be red.\n\n#show: show-this-section.with(underline, element: par, subsections: true)\n\nAnd this text will be red and underlined.\n\n== A2\nThis text will be black and underlined.\n\n== A3\n\n#show: show-this-section.with(text.with(blue), element: par, subsections: true)\nThis text will be blue and underlined\n\n= B1\nThis text will be black.\n\n== B2\n\nStill black\n```\n\n- Version 1: just using heading name and level in state\n- Version 2: use heading element in state and query for ancestor heading\n- Version 3: Removed extra nesting of show rule that was not necessary\n- Version 4: Fix bug with subsections not reset correctly\n\n</details>\n\nThis is not everything I'd like to do per section, but it answers the initial question perfectly and so I can't ask for more in this particular topic. Thanks for the help!",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 2,
      "reads": 27,
      "score": 40.4,
      "accepted_answer": true,
      "trust_level": 3,
      "user_id": 1272
    },
    {
      "id": 11792,
      "post_number": 6,
      "username": "Andrew",
      "name": "",
      "created_at": "2025-04-29T15:39:56.204Z",
      "updated_at": "2025-04-29T15:39:56.204Z",
      "cooked": "<p>I was thinking about same-element (heading), but I guess you can do this with any:</p>\n<details><summary>toggle-state solution + output</summary>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let toggle = state(\"toggle\", false)\n\n#show text: it =&gt; context {\n  if not toggle.get() { return it }\n  let style = query(selector(&lt;style&gt;).before(here()))\n  if style.len() == 0 { return it }\n  let (wrapper, style) = style.last().value\n  set text(..style)\n  if wrapper == none { it } else { wrapper(it) }\n}\n\n#let unset-text-style() = toggle.update(false)\n#let set-text-style(wrapper: none, ..style) = [\n  #metadata((wrapper: wrapper, style: style))&lt;style&gt;\n  #toggle.update(true)\n]\n\n#set-text-style(fill: red)\n\n= A1\n\nThis text will be red.\n\n#set-text-style(red, wrapper: underline)\n\nAnd this text will be red and underlined.\n\n#set-text-style(wrapper: underline)\n\n== A2\nThis text will be black and underlined.\n\n== A3\n\n#set-text-style(blue, wrapper: underline)\n\nThis text will be blue and underlined\n\n#unset-text-style()\n\n= B1\nThis text will be black.\n\n== B2\n\nStill black\n</code></pre>\n<p><img src=\"https://forum.typst.app/uploads/default/original/2X/f/ff39eacd8ba329ee75c37f4ac6c36e1532d04a33.png\" alt=\"image\" data-base62-sha1=\"ApPQcBZbp8yIXNOrZeQsOSJn0un\" width=\"318\" height=\"396\"></p>\n</details>\n<p>For the OP, since you can deduce the implicit breakpoint, you don’t need to manually unset styling.</p>\n<details><summary>OP solution + output</summary>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let text-toggle-h = state(\"text-toggle-h\", false)\n#let text-toggle-slh = state(\"text-toggle-slh\", false)\n\n#show heading: it =&gt; text-toggle-h.update(false) + it\n#show heading: it =&gt; context {\n  if not text-toggle-slh.get() { return it }\n\n  let style = query(selector(&lt;style-slh&gt;).before(here()))\n  if style.len() == 0 { return it }\n\n  let headings = query(selector(heading).before(style.last().location()))\n  if headings.len() == 0 { return it }\n\n  let level = headings.last().level\n  if it.level == level { text-toggle-slh.update(false) }\n  it\n}\n\n#show text: it =&gt; context {\n  if not text-toggle-h.get() and not text-toggle-slh.get() { return it }\n\n  show: it =&gt; {\n    if not text-toggle-h.get() { return it }\n    let style = query(selector(&lt;style-h&gt;).before(here()))\n    if style.len() == 0 { return it }\n    let (wrapper, style) = style.last().value\n    set text(..style)\n    if wrapper == none { it } else { wrapper(it) }\n  }\n\n  show: it =&gt; {\n    if not text-toggle-slh.get() { return it }\n    let style = query(selector(&lt;style-slh&gt;).before(here()))\n    if style.len() == 0 { return it }\n    let (wrapper, style) = style.last().value\n    set text(..style)\n    if wrapper == none { it } else { wrapper(it) }\n  }\n\n  it\n}\n\n#let unset-text-style() = toggle.update(false)\n#let set-text-style-until-next-heading(wrapper: none, ..style) = [\n  #metadata((wrapper: wrapper, style: style))&lt;style-h&gt;\n  #text-toggle-h.update(true)\n]\n#let set-text-style-until-next-same-level-heading(wrapper: none, ..style) = [\n  #metadata((wrapper: wrapper, style: style))&lt;style-slh&gt;\n  #text-toggle-slh.update(true)\n]\n\n= A1\n#set-text-style-until-next-heading(red)\n\nThis text will be red.\n\n#set-text-style-until-next-same-level-heading(wrapper: underline)\n\nAnd this text will be red and underlined.\n\n== A2\nThis text will be black and underlined.\n\n== A3\n\nThis text will be black and underlined\n\n= B1\nThis text will be black.\n</code></pre>\n<p><img src=\"https://forum.typst.app/uploads/default/original/2X/e/e78fe81c910df06cb192cbb1abe07e49e78bb9f7.png\" alt=\"image\" data-base62-sha1=\"x2uC5t9T62AjGN4m5qmKah1s0L5\" width=\"321\" height=\"305\"></p>\n</details>\n<p>Of course, naming and stuff can be refactored. You probably can generalize this too by providing <code>element</code> argument, instead of having per-element functions.</p>",
      "raw": "I was thinking about same-element (heading), but I guess you can do this with any:\n\n<details><summary>toggle-state solution + output</summary>\n\n```typ\n#let toggle = state(\"toggle\", false)\n\n#show text: it => context {\n  if not toggle.get() { return it }\n  let style = query(selector(<style>).before(here()))\n  if style.len() == 0 { return it }\n  let (wrapper, style) = style.last().value\n  set text(..style)\n  if wrapper == none { it } else { wrapper(it) }\n}\n\n#let unset-text-style() = toggle.update(false)\n#let set-text-style(wrapper: none, ..style) = [\n  #metadata((wrapper: wrapper, style: style))<style>\n  #toggle.update(true)\n]\n\n#set-text-style(fill: red)\n\n= A1\n\nThis text will be red.\n\n#set-text-style(red, wrapper: underline)\n\nAnd this text will be red and underlined.\n\n#set-text-style(wrapper: underline)\n\n== A2\nThis text will be black and underlined.\n\n== A3\n\n#set-text-style(blue, wrapper: underline)\n\nThis text will be blue and underlined\n\n#unset-text-style()\n\n= B1\nThis text will be black.\n\n== B2\n\nStill black\n```\n\n![image|318x396](upload://ApPQcBZbp8yIXNOrZeQsOSJn0un.png)\n\n</details>\n\nFor the OP, since you can deduce the implicit breakpoint, you don't need to manually unset styling.\n\n<details><summary>OP solution + output</summary>\n\n```typ\n#let text-toggle-h = state(\"text-toggle-h\", false)\n#let text-toggle-slh = state(\"text-toggle-slh\", false)\n\n#show heading: it => text-toggle-h.update(false) + it\n#show heading: it => context {\n  if not text-toggle-slh.get() { return it }\n\n  let style = query(selector(<style-slh>).before(here()))\n  if style.len() == 0 { return it }\n\n  let headings = query(selector(heading).before(style.last().location()))\n  if headings.len() == 0 { return it }\n\n  let level = headings.last().level\n  if it.level == level { text-toggle-slh.update(false) }\n  it\n}\n\n#show text: it => context {\n  if not text-toggle-h.get() and not text-toggle-slh.get() { return it }\n\n  show: it => {\n    if not text-toggle-h.get() { return it }\n    let style = query(selector(<style-h>).before(here()))\n    if style.len() == 0 { return it }\n    let (wrapper, style) = style.last().value\n    set text(..style)\n    if wrapper == none { it } else { wrapper(it) }\n  }\n\n  show: it => {\n    if not text-toggle-slh.get() { return it }\n    let style = query(selector(<style-slh>).before(here()))\n    if style.len() == 0 { return it }\n    let (wrapper, style) = style.last().value\n    set text(..style)\n    if wrapper == none { it } else { wrapper(it) }\n  }\n\n  it\n}\n\n#let unset-text-style() = toggle.update(false)\n#let set-text-style-until-next-heading(wrapper: none, ..style) = [\n  #metadata((wrapper: wrapper, style: style))<style-h>\n  #text-toggle-h.update(true)\n]\n#let set-text-style-until-next-same-level-heading(wrapper: none, ..style) = [\n  #metadata((wrapper: wrapper, style: style))<style-slh>\n  #text-toggle-slh.update(true)\n]\n\n= A1\n#set-text-style-until-next-heading(red)\n\nThis text will be red.\n\n#set-text-style-until-next-same-level-heading(wrapper: underline)\n\nAnd this text will be red and underlined.\n\n== A2\nThis text will be black and underlined.\n\n== A3\n\nThis text will be black and underlined\n\n= B1\nThis text will be black.\n```\n\n![image|321x305](upload://x2uC5t9T62AjGN4m5qmKah1s0L5.png)\n\n</details>\n\nOf course, naming and stuff can be refactored. You probably can generalize this too by providing `element` argument, instead of having per-element functions.",
      "reply_to_post_number": 5,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 1,
      "reads": 23,
      "score": 19.6,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 51
    }
  ],
  "scraped_at": "2025-06-10T09:48:32.678053"
}