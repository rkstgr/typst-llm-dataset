{
  "topic_metadata": {
    "id": 1380,
    "title": "Is it possible to calculate intersection points between two cetz plots?",
    "slug": "is-it-possible-to-calculate-intersection-points-between-two-cetz-plots",
    "posts_count": 4,
    "created_at": "2024-10-27T19:31:58.442Z",
    "last_posted_at": "2025-03-28T18:20:37.080Z",
    "views": 229,
    "like_count": 3,
    "reply_count": 2,
    "has_accepted_answer": true,
    "accepted_answer_post_number": 2,
    "accepted_answer_username": "Tiggax",
    "tags": [
      "cetz"
    ],
    "category_id": 5,
    "participant_count": 3,
    "word_count": 518
  },
  "posts": [
    {
      "id": 4734,
      "post_number": 1,
      "username": "Mathemensch",
      "name": "Alexander Schulz",
      "created_at": "2024-10-27T19:31:58.580Z",
      "updated_at": "2024-10-27T19:31:58.580Z",
      "cooked": "<p>I was trying different ways to calculate the intersection points from two cetz plots.</p>\n<pre data-code-wrap=\"typst\"><code class=\"lang-typst\">#canvas(\n      length: 1cm,\n      {\n        import draw: *\n        plot.plot(\n          size: (5, 5),\n          axis-style: \"school-book\",\n          x-label: [$x$],\n          y-label: [$y$],\n          {\n            intersections(\n              \"i\",\n              {\n                plot.add(\n                  style: (stroke: black + 1.5pt),\n                  domain: (-1, 1),\n                  x =&gt; calc.pow(x, 4) - 2 * calc.pow(x, 2) + 1,\n                )\n                plot.add(\n                  style: (stroke: black + 1.5pt),\n                  domain: (-1, 1),\n                  x =&gt; -(calc.pow(x, 4) - 2 * calc.pow(x, 2) + 1),\n                )\n              },\n            )\n          },\n        )\n      },\n    )\n</code></pre>\n<p>Is this even possible, or should i calculate the intersection points outside of typst/cetz?</p>",
      "raw": "I was trying different ways to calculate the intersection points from two cetz plots.\n\n```typst\n#canvas(\n      length: 1cm,\n      {\n        import draw: *\n        plot.plot(\n          size: (5, 5),\n          axis-style: \"school-book\",\n          x-label: [$x$],\n          y-label: [$y$],\n          {\n            intersections(\n              \"i\",\n              {\n                plot.add(\n                  style: (stroke: black + 1.5pt),\n                  domain: (-1, 1),\n                  x => calc.pow(x, 4) - 2 * calc.pow(x, 2) + 1,\n                )\n                plot.add(\n                  style: (stroke: black + 1.5pt),\n                  domain: (-1, 1),\n                  x => -(calc.pow(x, 4) - 2 * calc.pow(x, 2) + 1),\n                )\n              },\n            )\n          },\n        )\n      },\n    )\n```\n\nIs this even possible, or should i calculate the intersection points outside of typst/cetz?",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 49,
      "score": 754.8,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 307
    },
    {
      "id": 4770,
      "post_number": 2,
      "username": "Tiggax",
      "name": "",
      "created_at": "2024-10-28T13:49:46.443Z",
      "updated_at": "2024-10-28T13:58:12.726Z",
      "cooked": "<p>When you mean calculate them, do you want to reference them (like point to them) or do you want the values?</p>\n<p>If you need to have a reference, you could do something like my example:</p>\n<pre><code class=\"lang-auto\">#import \"@preview/cetz:0.3.1\": canvas, draw\n#import \"@preview/cetz-plot:0.1.0\": plot\n\n\n#let intersection(plotA, plotB, style: (stroke: red + 2pt)) = {\n  let dataA = plotA.first().data\n  let dataB = plotB.first().data\n\n  let points = dataA.filter(x =&gt; x in dataB)\n\n  for ((i, point)) in points.enumerate() {\n    plot.add-anchor(\"i_\" + str(i),point )\n  }\n\n  plotA\n  plotB\n}\n\n#canvas(\n  length: 1cm,\n  {\n    import draw: *\n    plot.plot(\n      name: \"my_plot\",\n      size: (5, 5),\n      axis-style: \"school-book\",\n      x-label: [$x$],\n      y-label: [$y$],\n      {\n      intersection(\n        plot.add(\n          style: (stroke: black + 1.5pt),\n          domain: (-1, 1),\n          x =&gt; calc.pow(x, 4) - 2 * calc.pow(x, 2) + 1,\n        ),\n        plot.add(\n          style: (stroke: black + 1.5pt),\n          domain: (-1, 1),\n          x =&gt; -(calc.pow(x, 4) - 2 * calc.pow(x, 2) + 1),\n        )\n      )\n      }\n    )\n\n    // reference the point with {plot name}.i_{number}\n    line(\"my_plot.i_1\", ((), \"|-\", (0,3.5)), mark: (start: \"&gt;\"), name: \"line\")\n    content(\"line.end\", [Here], anchor: \"south\", padding: .1)\n  },\n)\n</code></pre>\n<p>The function just takes the plots, and access its values, before passing it on. This can be modified to for example output the values and so on.<br>\n(note: intersections might not be shown 100% of the time, since the calculation is discrete.)</p>",
      "raw": "When you mean calculate them, do you want to reference them (like point to them) or do you want the values?\n \nIf you need to have a reference, you could do something like my example:\n```\n#import \"@preview/cetz:0.3.1\": canvas, draw\n#import \"@preview/cetz-plot:0.1.0\": plot\n\n\n#let intersection(plotA, plotB, style: (stroke: red + 2pt)) = {\n  let dataA = plotA.first().data\n  let dataB = plotB.first().data\n\n  let points = dataA.filter(x => x in dataB)\n\n  for ((i, point)) in points.enumerate() {\n    plot.add-anchor(\"i_\" + str(i),point )\n  }\n\n  plotA\n  plotB\n}\n\n#canvas(\n  length: 1cm,\n  {\n    import draw: *\n    plot.plot(\n      name: \"my_plot\",\n      size: (5, 5),\n      axis-style: \"school-book\",\n      x-label: [$x$],\n      y-label: [$y$],\n      {\n      intersection(\n        plot.add(\n          style: (stroke: black + 1.5pt),\n          domain: (-1, 1),\n          x => calc.pow(x, 4) - 2 * calc.pow(x, 2) + 1,\n        ),\n        plot.add(\n          style: (stroke: black + 1.5pt),\n          domain: (-1, 1),\n          x => -(calc.pow(x, 4) - 2 * calc.pow(x, 2) + 1),\n        )\n      )\n      }\n    )\n\n    // reference the point with {plot name}.i_{number}\n    line(\"my_plot.i_1\", ((), \"|-\", (0,3.5)), mark: (start: \">\"), name: \"line\")\n    content(\"line.end\", [Here], anchor: \"south\", padding: .1)\n  },\n)\n```\nThe function just takes the plots, and access its values, before passing it on. This can be modified to for example output the values and so on.\n(note: intersections might not be shown 100% of the time, since the calculation is discrete.)",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 2,
      "reads": 45,
      "score": 49.0,
      "accepted_answer": true,
      "trust_level": 2,
      "user_id": 71
    },
    {
      "id": 5377,
      "post_number": 3,
      "username": "Mathemensch",
      "name": "Alexander Schulz",
      "created_at": "2024-11-09T12:38:33.723Z",
      "updated_at": "2024-11-09T12:38:33.723Z",
      "cooked": "<p>Thank’s for your quick solution!</p>\n<p>I’ve used your code to create a similar, but different approach, to solve this problem. Now the only remaining issue is the scaling of the drawn objects in the <code>plot.annotate</code> function.</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let intersection(plotA, plotB, style: (stroke: red + 2pt)) = {\n  import draw: *\n  let dataA = plotA.first().data\n  let dataB = plotB.first().data\n\n  plot.annotate({\n    hide({\n      intersections(\"i\", line(..plotA.first().data), line(..plotB.first().data))\n    })\n    for-each-anchor(\"i\", (name) =&gt; {\n      circle(\"i.\" + name, radius: 0.05, fill: red)\n    })\n  })\n\n  plotA\n  plotB\n}\n\n#canvas(\n  length: 1cm,\n  {\n    import draw: *\n    plot.plot(\n      name: \"plot\",\n      size: (10, 10),\n      axis-style: \"school-book\",\n      x-label: [$x$],\n      y-label: [$y$],\n      {\n        intersection(\n          plot.add(\n            style: (stroke: black + 1.5pt),\n            domain: (-1, 1),\n            x =&gt; calc.pow(x, 4) - 2 * calc.pow(x, 2) + 1,\n          ),\n          plot.add(\n            style: (stroke: black + 1.5pt),\n            domain: (-1, 1),\n            x =&gt; -(calc.pow(x, 4) - 2 * calc.pow(x, 2) + 0.5),\n          ),\n        )\n      },\n    )\n  },\n)\n</code></pre>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://forum.typst.app/uploads/default/original/2X/3/3725be31cbbb287bdd4dcef5738ade7e840ff05e.png\" data-download-href=\"https://forum.typst.app/uploads/default/3725be31cbbb287bdd4dcef5738ade7e840ff05e\" title=\"SCR-20241109-melu\"><img src=\"https://forum.typst.app/uploads/default/optimized/2X/3/3725be31cbbb287bdd4dcef5738ade7e840ff05e_2_529x500.png\" alt=\"SCR-20241109-melu\" data-base62-sha1=\"7RR7JBkeHMpyyDtsxCG8eqW4vBI\" width=\"529\" height=\"500\" srcset=\"https://forum.typst.app/uploads/default/optimized/2X/3/3725be31cbbb287bdd4dcef5738ade7e840ff05e_2_529x500.png, https://forum.typst.app/uploads/default/original/2X/3/3725be31cbbb287bdd4dcef5738ade7e840ff05e.png 1.5x, https://forum.typst.app/uploads/default/original/2X/3/3725be31cbbb287bdd4dcef5738ade7e840ff05e.png 2x\" data-dominant-color=\"F9F8F8\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">SCR-20241109-melu</span><span class=\"informations\">642×606 40.3 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>Is there any option to make the circle perfectly round, without manually calculating the scale base of the axis scaling?</p>",
      "raw": "Thank's for your quick solution!\n\nI've used your code to create a similar, but different approach, to solve this problem. Now the only remaining issue is the scaling of the drawn objects in the `plot.annotate` function.\n\n``` typ\n#let intersection(plotA, plotB, style: (stroke: red + 2pt)) = {\n  import draw: *\n  let dataA = plotA.first().data\n  let dataB = plotB.first().data\n\n  plot.annotate({\n    hide({\n      intersections(\"i\", line(..plotA.first().data), line(..plotB.first().data))\n    })\n    for-each-anchor(\"i\", (name) => {\n      circle(\"i.\" + name, radius: 0.05, fill: red)\n    })\n  })\n\n  plotA\n  plotB\n}\n\n#canvas(\n  length: 1cm,\n  {\n    import draw: *\n    plot.plot(\n      name: \"plot\",\n      size: (10, 10),\n      axis-style: \"school-book\",\n      x-label: [$x$],\n      y-label: [$y$],\n      {\n        intersection(\n          plot.add(\n            style: (stroke: black + 1.5pt),\n            domain: (-1, 1),\n            x => calc.pow(x, 4) - 2 * calc.pow(x, 2) + 1,\n          ),\n          plot.add(\n            style: (stroke: black + 1.5pt),\n            domain: (-1, 1),\n            x => -(calc.pow(x, 4) - 2 * calc.pow(x, 2) + 0.5),\n          ),\n        )\n      },\n    )\n  },\n)\n```\n\n![SCR-20241109-melu|529x500, 100%](upload://7RR7JBkeHMpyyDtsxCG8eqW4vBI.png)\n\n\nIs there any option to make the circle perfectly round, without manually calculating the scale base of the axis scaling?",
      "reply_to_post_number": 2,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 1,
      "reads": 36,
      "score": 32.2,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 307
    },
    {
      "id": 10372,
      "post_number": 4,
      "username": "Bryn",
      "name": "Bryn Humberstone",
      "created_at": "2025-03-28T18:20:37.080Z",
      "updated_at": "2025-03-28T18:20:37.080Z",
      "cooked": "<p>This is a good question and probably should be posted as a new question in the forum.</p>",
      "raw": "This is a good question and probably should be posted as a new question in the forum.",
      "reply_to_post_number": 3,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 20,
      "score": 4.0,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 389
    }
  ],
  "scraped_at": "2025-06-10T09:55:53.842410"
}