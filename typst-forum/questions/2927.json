{
  "topic_metadata": {
    "id": 2927,
    "title": "How do I calculate the width of content without having context everywhere?",
    "slug": "how-do-i-calculate-the-width-of-content-without-having-context-everywhere",
    "posts_count": 6,
    "created_at": "2025-02-22T19:03:26.809Z",
    "last_posted_at": "2025-02-24T07:57:26.669Z",
    "views": 127,
    "like_count": 4,
    "reply_count": 4,
    "has_accepted_answer": true,
    "accepted_answer_post_number": 2,
    "accepted_answer_username": "SillyFreak",
    "tags": [
      "context",
      "measure"
    ],
    "category_id": 5,
    "participant_count": 3,
    "word_count": 866
  },
  "posts": [
    {
      "id": 8894,
      "post_number": 1,
      "username": "Bolt",
      "name": "",
      "created_at": "2025-02-22T19:03:26.950Z",
      "updated_at": "2025-02-22T19:39:34.500Z",
      "cooked": "<p>I’m working on a package with displays a syntax tree using cetz, but I’m having trouble calculating the width of the leaf nodes. Currently it only works for strings with an approximation of <code>label.len() / 7 + 0.5</code> which has worked surprisingly well, but I want to do better.</p>\n<p>This is what I’ve been trying:</p>\n<pre data-code-wrap=\"typc\"><code class=\"lang-typc\">let width(node) = context {\n  let (_label, children) = node\n  if type(children) == content {\n    measure(children).width.cm\n  } else if type(children) == array {\n    children.map(width).sum()\n  }\n}\n</code></pre>\n<p>But I’m getting <code>Assertion failed: Incorrect type for body: content</code> from cetz.</p>\n<p>For reference the broader function and where it’s called from is</p>\n<pre data-code-wrap=\"typc\"><code class=\"lang-typc\">let tree-recursive(node, id: (0,), x: 0, y: 0) = context {\n  let wid = width(node)\n  ...\n  // show label with cetz.draw.content\n  ...\n  // call recursively on children with modified coords\n}\ncetz.canvas(tree-recursive(node))\n</code></pre>\n<p>Any ideas on how to solve this? My instinct is that I shouldn’t need this much context, but I don’t know how to get any better an approximation without using it.</p>",
      "raw": "I'm working on a package with displays a syntax tree using cetz, but I'm having trouble calculating the width of the leaf nodes. Currently it only works for strings with an approximation of `label.len() / 7 + 0.5` which has worked surprisingly well, but I want to do better. \n\nThis is what I've been trying:\n```typc\nlet width(node) = context {\n  let (_label, children) = node\n  if type(children) == content {\n    measure(children).width.cm\n  } else if type(children) == array {\n    children.map(width).sum()\n  }\n}\n```\nBut I'm getting `Assertion failed: Incorrect type for body: content` from cetz.\n\nFor reference the broader function and where it's called from is \n```typc\nlet tree-recursive(node, id: (0,), x: 0, y: 0) = context {\n  let wid = width(node)\n  ...\n  // show label with cetz.draw.content\n  ...\n  // call recursively on children with modified coords\n}\ncetz.canvas(tree-recursive(node))\n```\nAny ideas on how to solve this? My instinct is that I shouldn't need this much context, but I don't know how to get any better an approximation without using it.",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 0,
      "reads": 38,
      "score": 242.6,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 737
    },
    {
      "id": 8895,
      "post_number": 2,
      "username": "SillyFreak",
      "name": "SillyFreak",
      "created_at": "2025-02-22T19:35:28.627Z",
      "updated_at": "2025-02-22T19:35:28.627Z",
      "cooked": "<p>You need context, but not that much. I suspect that this will basically work if you put the whole CeTZ canvas into the context, and don’t use <code>context</code> anywhere else.</p>\n<aside class=\"quote no-group\" data-username=\"Bolt\" data-post=\"1\" data-topic=\"2927\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/letter_avatar_proxy/v4/letter/b/11566C/48.png\" class=\"avatar\"> Bolt:</div>\n<blockquote>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">let width(node) = context {\n</code></pre>\n</blockquote>\n</aside>\n<p>this function would not return a length but <code>content</code> (and <code>children.map(width)</code> would result in an array of contents instead of an array of lengths as well). To learn more about the reasons, take a look at <a href=\"https://forum.typst.app/t/why-is-the-value-i-receive-from-context-always-content/164/2\" class=\"inline-onebox\">Why is the value I receive from context always content? - #2 by laurmaedje</a></p>\n<p>Since each <code>context</code> expression results in opaque content, everything that depends on the non-opaque values within the block needs to be nested inside the context. Since the CeTZ canvas itself needs structured data (i.e. the CeTZ drawing functions) you can’t put context between the canvas and the drawing functions; from that it follows that you put the context <em>around</em> the canvas.</p>",
      "raw": "You need context, but not that much. I suspect that this will basically work if you put the whole CeTZ canvas into the context, and don't use `context` anywhere else.\n\n[quote=\"Bolt, post:1, topic:2927\"]\n```typ\nlet width(node) = context {\n```\n[/quote]\nthis function would not return a length but `content` (and `children.map(width)` would result in an array of contents instead of an array of lengths as well). To learn more about the reasons, take a look at https://forum.typst.app/t/why-is-the-value-i-receive-from-context-always-content/164/2?u=sillyfreak\n\nSince each `context` expression results in opaque content, everything that depends on the non-opaque values within the block needs to be nested inside the context. Since the CeTZ canvas itself needs structured data (i.e. the CeTZ drawing functions) you can't put context between the canvas and the drawing functions; from that it follows that you put the context _around_ the canvas.",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 1,
      "like_count": 0,
      "reads": 34,
      "score": 31.8,
      "accepted_answer": true,
      "trust_level": 3,
      "user_id": 32
    },
    {
      "id": 8907,
      "post_number": 3,
      "username": "Bolt",
      "name": "",
      "created_at": "2025-02-23T03:02:04.489Z",
      "updated_at": "2025-02-23T03:02:04.489Z",
      "cooked": "<p>Is this what you meant? It seems to work, but it thought that context blocks should be minimized? Here basically all the code is in one.</p>\n<pre data-code-wrap=\"typc\"><code class=\"lang-typc\">let tree(node, ...) = context {\n  // helper functions\n  let width(node) = { ... }\n  let offset(node) = { ... }\n  ...\n  // the big function\n  let tree-recursive(node, ...) = { ... }\n  cetz.canvas(tree-recursive(node))\n}\n</code></pre>",
      "raw": "Is this what you meant? It seems to work, but it thought that context blocks should be minimized? Here basically all the code is in one. \n\n```typc\nlet tree(node, ...) = context {\n  // helper functions\n  let width(node) = { ... }\n  let offset(node) = { ... }\n  ...\n  // the big function\n  let tree-recursive(node, ...) = { ... }\n  cetz.canvas(tree-recursive(node))\n}\n```",
      "reply_to_post_number": 2,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 0,
      "reads": 31,
      "score": 11.2,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 737
    },
    {
      "id": 8921,
      "post_number": 4,
      "username": "SillyFreak",
      "name": "SillyFreak",
      "created_at": "2025-02-23T15:30:18.957Z",
      "updated_at": "2025-02-23T15:30:18.957Z",
      "cooked": "<aside class=\"quote no-group\" data-username=\"Bolt\" data-post=\"3\" data-topic=\"2927\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/letter_avatar_proxy/v4/letter/b/11566C/48.png\" class=\"avatar\"> Bolt:</div>\n<blockquote>\n<p>but it thought that context blocks should be minimized?</p>\n</blockquote>\n</aside>\n<p>As far as I understand, that is largely not an issue anymore since 0.12. Back with 0.11, there were cases where making context smaller was important, although I’m not sure what the implications were.</p>\n<p>In any case, even then you’d have had to make the context <em>big enough</em> and what you’re doing here is already the smallest context scope possible (at least as long that we assume that there’s no way around measuring inside the diagram). And even though it’s quite a bit of <em>code</em>, I’d say one diagram is actually not that big of a scope anyway.</p>\n<p>That said, what are the implications of using a large scope? One important one is that the context is “frozen” in the whole scope. Consider this:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#context {\n  [#text.size]\n  set text(size: 2em)\n  [#text.size]\n}\n</code></pre>\n<p>both of these will print the same value, but in different font sizes! You access <code>text.size</code> contextually, and the value you access is the one active at the beginning of the context block. One way around this is to break this into two smaller context blocks, but even if that is not possible, you can work around this by nesting context blocks:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#context {\n  [#text.size]\n  set text(size: 2em)\n  context [#text.size]\n}\n</code></pre>\n<p>Another implication is that context blocks will sometimes fail in early iterations. Typst will retry when the context changes, but if the source and consumer of that change are in the same block, this won’t work. The workaround is the same:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let x = state(\"x\")\n#context {\n  x.update(1)\n\n  // bad: the context fails and the update isn't applied,\n  // leading to the context to continue failing\n  // assert.eq(x.get(), 1)\n\n  // good: only this context fails, so the update is applied\n  // on the next attempt, this succeeds\n  context assert.eq(x.get(), 1)\n}\n</code></pre>\n<p>You can read more about this behavior here: <a href=\"https://forum.typst.app/t/is-an-assert-supposed-to-be-able-to-change-behavior-when-it-doesnt-fail/1433/2\" class=\"inline-onebox\">Is an assert supposed to be able to change behavior when it \"doesn't\" fail? - #2 by laurmaedje</a> and in the issue linked there.</p>",
      "raw": "[quote=\"Bolt, post:3, topic:2927\"]\nbut it thought that context blocks should be minimized?\n[/quote]\n\nAs far as I understand, that is largely not an issue anymore since 0.12. Back with 0.11, there were cases where making context smaller was important, although I'm not sure what the implications were.\n\nIn any case, even then you'd have had to make the context _big enough_ and what you're doing here is already the smallest context scope possible (at least as long that we assume that there's no way around measuring inside the diagram). And even though it's quite a bit of _code_, I'd say one diagram is actually not that big of a scope anyway.\n\nThat said, what are the implications of using a large scope? One important one is that the context is \"frozen\" in the whole scope. Consider this:\n```typ\n#context {\n  [#text.size]\n  set text(size: 2em)\n  [#text.size]\n}\n```\nboth of these will print the same value, but in different font sizes! You access `text.size` contextually, and the value you access is the one active at the beginning of the context block. One way around this is to break this into two smaller context blocks, but even if that is not possible, you can work around this by nesting context blocks:\n```typ\n#context {\n  [#text.size]\n  set text(size: 2em)\n  context [#text.size]\n}\n```\nAnother implication is that context blocks will sometimes fail in early iterations. Typst will retry when the context changes, but if the source and consumer of that change are in the same block, this won't work. The workaround is the same:\n```typ\n#let x = state(\"x\")\n#context {\n  x.update(1)\n\n  // bad: the context fails and the update isn't applied,\n  // leading to the context to continue failing\n  // assert.eq(x.get(), 1)\n\n  // good: only this context fails, so the update is applied\n  // on the next attempt, this succeeds\n  context assert.eq(x.get(), 1)\n}\n```\nYou can read more about this behavior here: https://forum.typst.app/t/is-an-assert-supposed-to-be-able-to-change-behavior-when-it-doesnt-fail/1433/2?u=sillyfreak and in the issue linked there.",
      "reply_to_post_number": 3,
      "reply_count": 1,
      "quote_count": 1,
      "like_count": 2,
      "reads": 31,
      "score": 41.2,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 32
    },
    {
      "id": 8943,
      "post_number": 5,
      "username": "sijo",
      "name": "",
      "created_at": "2025-02-24T07:54:35.803Z",
      "updated_at": "2025-02-24T07:55:09.109Z",
      "cooked": "<p>I’m not sure the last example is really illustrating the retry issue: Isn’t it rather another case of freezing the wrong scope? If you do <code>#context{ x.update(1); x.get() }</code> the <code>get</code> call will use the state frozen before the update.</p>\n<p>Maybe this is a better example:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#context {\n  // This heading is never inserted because the context block fails\n  // due the assert\n  heading[A]\n  // Adding context in front of the assert fixes the error as then it's\n  // only this context that fails\n  assert(query(heading).len() &gt; 0)\n}\n</code></pre>",
      "raw": "I'm not sure the last example is really illustrating the retry issue: Isn't it rather another case of freezing the wrong scope? If you do `#context{ x.update(1); x.get() }` the `get` call will use the state frozen before the update.\n\nMaybe this is a better example:\n\n```typ\n#context {\n  // This heading is never inserted because the context block fails\n  // due the assert\n  heading[A]\n  // Adding context in front of the assert fixes the error as then it's\n  // only this context that fails\n  assert(query(heading).len() > 0)\n}\n```",
      "reply_to_post_number": 4,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 1,
      "reads": 23,
      "score": 54.6,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 332
    },
    {
      "id": 8944,
      "post_number": 6,
      "username": "SillyFreak",
      "name": "SillyFreak",
      "created_at": "2025-02-24T07:57:26.669Z",
      "updated_at": "2025-02-24T07:57:26.669Z",
      "cooked": "<p>You’re right, I didn’t think about that when thinking up an example. Thanks for adding a better one!</p>",
      "raw": "You're right, I didn't think about that when thinking up an example. Thanks for adding a better one!",
      "reply_to_post_number": 5,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 1,
      "reads": 23,
      "score": 19.6,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 32
    }
  ],
  "scraped_at": "2025-06-10T09:51:22.581437"
}