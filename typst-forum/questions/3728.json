{
  "topic_metadata": {
    "id": 3728,
    "title": "How to Automate Typesetting of Matrices within Function?",
    "slug": "how-to-automate-typesetting-of-matrices-within-function",
    "posts_count": 9,
    "created_at": "2025-04-19T13:37:21.905Z",
    "last_posted_at": "2025-04-20T17:56:00.595Z",
    "views": 80,
    "like_count": 5,
    "reply_count": 6,
    "has_accepted_answer": true,
    "accepted_answer_post_number": 2,
    "accepted_answer_username": "janekfleper",
    "tags": [
      "scripting",
      "math"
    ],
    "category_id": 5,
    "participant_count": 3,
    "word_count": 6146
  },
  "posts": [
    {
      "id": 11328,
      "post_number": 1,
      "username": "Paul744",
      "name": "Paul",
      "created_at": "2025-04-19T13:37:22.068Z",
      "updated_at": "2025-04-19T17:11:33.779Z",
      "cooked": "<p>I am toying around with Typst’s scripting functionality, and I was trying to see if it was robust enough to automate the calculation of structure constants for SU(3) in its 3-dimensional representation. However, I am facing a couple issues with rendering and with algebraic numbers. The code I currently have is below.</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let Tr = math.upright(\"Tr\")\n#let complex(a, b) = (a, b)\n#let complex-add(z1, z2) = (z1.at(0) + z2.at(0), z1.at(1) + z2.at(1))\n#let complex-sub(z1, z2) = (z1.at(0) - z2.at(0), z1.at(1) - z2.at(1))\n#let complex-mul(z1, z2) = (\n  z1.at(0) * z2.at(0) - z1.at(1) * z2.at(1),\n  z1.at(0) * z2.at(1) + z1.at(1) * z2.at(0)\n)\n#let complex-neg(z) = (-z.at(0), -z.at(1))\n#let complex-scale(z, s) = (z.at(0) * s, z.at(1) * s)\n\n#let format-complex(z) = {\n  let real = z.at(0)\n  let imag = z.at(1)\n  \n  if imag == 0 {\n    return str(real)\n  } else if real == 0 {\n    if imag == 1 { return \"i\" }\n    else if imag == -1 { return \"-i\" }\n    else { return str(imag) + \"i\" }\n  } else {\n    let sign = if imag &gt; 0 { \"+\" } else { \"-\" }\n    let abs-imag = calc.abs(imag)\n    if abs-imag == 1 {\n      return str(real) + sign + \"i\"\n    } else {\n      return str(real) + sign + str(abs-imag) + \"i\"\n    }\n  }\n}\n\n#let mat-add(A, B) = {\n  let rows = A.len()\n  let cols = A.at(0).len()\n  \n  let result = ()\n  for i in range(rows) {\n    let row = ()\n    for j in range(cols) {\n      row.push(complex-add(A.at(i).at(j), B.at(i).at(j)))\n    }\n    result.push(row)\n  }\n  \n  return result\n}\n\n#let mat-sub(A, B) = {\n  let rows = A.len()\n  let cols = A.at(0).len()\n  \n  let result = ()\n  for i in range(rows) {\n    let row = ()\n    for j in range(cols) {\n      row.push(complex-sub(A.at(i).at(j), B.at(i).at(j)))\n    }\n    result.push(row)\n  }\n  \n  return result\n}\n\n#let mat-mul(A, B) = {\n  let rows_A = A.len()\n  let cols_A = A.at(0).len()\n  let cols_B = B.at(0).len()\n  \n  let result = ()\n  for i in range(rows_A) {\n    let row = ()\n    for j in range(cols_B) {\n      let sum = complex(0, 0)\n      for k in range(cols_A) {\n        sum = complex-add(sum, complex-mul(A.at(i).at(k), B.at(k).at(j)))\n      }\n      row.push(sum)\n    }\n    result.push(row)\n  }\n  \n  return result\n}\n\n#let mat-commutator(A, B) = {\n  let AB = mat-mul(A, B)\n  let BA = mat-mul(B, A)\n  return mat-sub(AB, BA)\n}\n\n#let mat-trace(A) = {\n  let sum = complex(0, 0)\n  let n = A.len()\n  \n  for i in range(n) {\n    sum = complex-add(sum, A.at(i).at(i))\n  }\n  \n  return sum\n}\n\n// Define Gell-Mann matrices\n#let t1 = (\n  (complex(0, 0), complex(0.5, 0), complex(0, 0)),\n  (complex(0.5, 0), complex(0, 0), complex(0, 0)),\n  (complex(0, 0), complex(0, 0), complex(0, 0))\n)\n\n#let t2 = (\n  (complex(0, 0), complex(0, -0.5), complex(0, 0)),\n  (complex(0, 0.5), complex(0, 0), complex(0, 0)),\n  (complex(0, 0), complex(0, 0), complex(0, 0))\n)\n\n#let t3 = (\n  (complex(0.5, 0), complex(0, 0), complex(0, 0)),\n  (complex(0, 0), complex(-0.5, 0), complex(0, 0)),\n  (complex(0, 0), complex(0, 0), complex(0, 0))\n)\n\n#let t4 = (\n  (complex(0, 0), complex(0, 0), complex(0.5, 0)),\n  (complex(0, 0), complex(0, 0), complex(0, 0)),\n  (complex(0.5, 0), complex(0, 0), complex(0, 0))\n)\n\n#let t5 = (\n  (complex(0, 0), complex(0, 0), complex(0, -0.5)),\n  (complex(0, 0), complex(0, 0), complex(0, 0)),\n  (complex(0, 0.5), complex(0, 0), complex(0, 0))\n)\n\n#let t6 = (\n  (complex(0, 0), complex(0, 0), complex(0, 0)),\n  (complex(0, 0), complex(0, 0), complex(0.5, 0)),\n  (complex(0, 0), complex(0.5, 0), complex(0, 0))\n)\n\n#let t7 = (\n  (complex(0, 0), complex(0, 0), complex(0, 0)),\n  (complex(0, 0), complex(0, 0), complex(0, -0.5)),\n  (complex(0, 0), complex(0, 0.5), complex(0, 0))\n)\n\n#let factor = 1/(2*calc.sqrt(3))\n#let t8 = (\n  (complex(factor, 0), complex(0, 0), complex(0, 0)),\n  (complex(0, 0), complex(factor, 0), complex(0, 0)),\n  (complex(0, 0), complex(0, 0), complex(-2*factor, 0))\n)\n\n#let t = (t1, t2, t3, t4, t5, t6, t7, t8)\n\n#let calculate-f(a, b, c, Cr) = {\n  let a_idx = a - 1\n  let b_idx = b - 1\n  let c_idx = c - 1\n  \n  let comm = mat-commutator(t.at(a_idx), t.at(b_idx))\n  let prod = mat-mul(comm, t.at(c_idx))\n  let tr = mat-trace(prod)\n  \n  // f^(abc) = -i/Cr * Tr([t_a, t_b] t_c)\n  let result = complex-mul(complex(0, -1/Cr), tr)\n  \n  return (\n    commutator: comm,\n    product: prod,\n    trace: tr,\n    result: result\n  )\n}\n\n#let Cr = 1 // Normalization constant\n\n#let display-calculation(a, b, c) = {\n  let res = calculate-f(a, b, c, Cr)\n  \n  [\n    == Structure Constant $f^(#a #b #c)$\n    \n    *Step 1:* Calculate the commutator $[t_(#a), t_(#b)]$\n    \n    $ [t_(#a), t_(#b)] = t_(#a) t_(#b) - t_(#b) t_(#a) = mat(\n        #format-complex(res.commutator.at(0).at(0)), #format-complex(res.commutator.at(0).at(1)), #format-complex(res.commutator.at(0).at(2));\n        #format-complex(res.commutator.at(1).at(0)), #format-complex(res.commutator.at(1).at(1)), #format-complex(res.commutator.at(1).at(2));\n        #format-complex(res.commutator.at(2).at(0)), #format-complex(res.commutator.at(2).at(1)), #format-complex(res.commutator.at(2).at(2))\n      ) $\n    \n    *Step 2:* Multiply by $t_(#c)$ to get $[t_(#a), t_(#b)]t_(#c)$\n    \n    $ [t_(#a), t_(#b)]t_(#c) = mat(\n        #format-complex(res.product.at(0).at(0)), #format-complex(res.product.at(0).at(1)), #format-complex(res.product.at(0).at(2));\n        #format-complex(res.product.at(1).at(0)), #format-complex(res.product.at(1).at(1)), #format-complex(res.product.at(1).at(2));\n        #format-complex(res.product.at(2).at(0)), #format-complex(res.product.at(2).at(1)), #format-complex(res.product.at(2).at(2))\n      ) $\n    \n    *Step 3:* Calculate the trace\n    \n    $ Tr([t_(#a), t_(#b)]t_(#c)) = #format-complex(res.trace) $\n    \n    *Step 4:* Multiply by $-i/C_r$ to get the structure constant\n    \n    $ f^(#a #b #c) = frac(-i, C_r) Tr([t_(#a), t_(#b)]t_(#c)) = #format-complex(res.result) $\n  ]\n}\n\n// Sample calculations for a few structure constants\n#display-calculation(1, 2, 3)\n</code></pre>\n<p>The two primary issues I am having is that, when trying to render:</p>\n<pre data-code-wrap=\"typc\"><code class=\"lang-typc\">mat(\n        #format-complex(res.product.at(0).at(0)), #format-complex(res.product.at(0).at(1)), #format-complex(res.product.at(0).at(2));\n        #format-complex(res.product.at(1).at(0)), #format-complex(res.product.at(1).at(1)), #format-complex(res.product.at(1).at(2));\n        #format-complex(res.product.at(2).at(0)), #format-complex(res.product.at(2).at(1)), #format-complex(res.product.at(2).at(2))\n      ) \n</code></pre>\n<p>and similarly for the other matrix, it refuses to render as a matrix. What I get is, e.g. <code>(0.5i 0 00 −0.5i 00 0 0)</code>, rather than the block form it should have. I cannot figure out what’s going on. I assume the input matrix elements are somehow messing with the rendering.</p>\n<p>The second issue I am facing is that I need to use <code>1/(2*calc.sqrt(3))</code> for one of the Gell-Mann matrices, but that converts it to a float, making it impossible to render it as <code>1/sqrt(3)</code> if the output still has the <code>sqrt(3)</code>.</p>\n<p>Does anyone understand why the matrices aren’t rendering, and if there’s a way to get the <code>sqrt()</code> to still render, even if actual automated calculations require <code>calc.sqrt(3)</code>?</p>",
      "raw": "I am toying around with Typst's scripting functionality, and I was trying to see if it was robust enough to automate the calculation of structure constants for SU(3) in its 3-dimensional representation. However, I am facing a couple issues with rendering and with algebraic numbers. The code I currently have is below.\n\n```typ\n#let Tr = math.upright(\"Tr\")\n#let complex(a, b) = (a, b)\n#let complex-add(z1, z2) = (z1.at(0) + z2.at(0), z1.at(1) + z2.at(1))\n#let complex-sub(z1, z2) = (z1.at(0) - z2.at(0), z1.at(1) - z2.at(1))\n#let complex-mul(z1, z2) = (\n  z1.at(0) * z2.at(0) - z1.at(1) * z2.at(1),\n  z1.at(0) * z2.at(1) + z1.at(1) * z2.at(0)\n)\n#let complex-neg(z) = (-z.at(0), -z.at(1))\n#let complex-scale(z, s) = (z.at(0) * s, z.at(1) * s)\n\n#let format-complex(z) = {\n  let real = z.at(0)\n  let imag = z.at(1)\n  \n  if imag == 0 {\n    return str(real)\n  } else if real == 0 {\n    if imag == 1 { return \"i\" }\n    else if imag == -1 { return \"-i\" }\n    else { return str(imag) + \"i\" }\n  } else {\n    let sign = if imag > 0 { \"+\" } else { \"-\" }\n    let abs-imag = calc.abs(imag)\n    if abs-imag == 1 {\n      return str(real) + sign + \"i\"\n    } else {\n      return str(real) + sign + str(abs-imag) + \"i\"\n    }\n  }\n}\n\n#let mat-add(A, B) = {\n  let rows = A.len()\n  let cols = A.at(0).len()\n  \n  let result = ()\n  for i in range(rows) {\n    let row = ()\n    for j in range(cols) {\n      row.push(complex-add(A.at(i).at(j), B.at(i).at(j)))\n    }\n    result.push(row)\n  }\n  \n  return result\n}\n\n#let mat-sub(A, B) = {\n  let rows = A.len()\n  let cols = A.at(0).len()\n  \n  let result = ()\n  for i in range(rows) {\n    let row = ()\n    for j in range(cols) {\n      row.push(complex-sub(A.at(i).at(j), B.at(i).at(j)))\n    }\n    result.push(row)\n  }\n  \n  return result\n}\n\n#let mat-mul(A, B) = {\n  let rows_A = A.len()\n  let cols_A = A.at(0).len()\n  let cols_B = B.at(0).len()\n  \n  let result = ()\n  for i in range(rows_A) {\n    let row = ()\n    for j in range(cols_B) {\n      let sum = complex(0, 0)\n      for k in range(cols_A) {\n        sum = complex-add(sum, complex-mul(A.at(i).at(k), B.at(k).at(j)))\n      }\n      row.push(sum)\n    }\n    result.push(row)\n  }\n  \n  return result\n}\n\n#let mat-commutator(A, B) = {\n  let AB = mat-mul(A, B)\n  let BA = mat-mul(B, A)\n  return mat-sub(AB, BA)\n}\n\n#let mat-trace(A) = {\n  let sum = complex(0, 0)\n  let n = A.len()\n  \n  for i in range(n) {\n    sum = complex-add(sum, A.at(i).at(i))\n  }\n  \n  return sum\n}\n\n// Define Gell-Mann matrices\n#let t1 = (\n  (complex(0, 0), complex(0.5, 0), complex(0, 0)),\n  (complex(0.5, 0), complex(0, 0), complex(0, 0)),\n  (complex(0, 0), complex(0, 0), complex(0, 0))\n)\n\n#let t2 = (\n  (complex(0, 0), complex(0, -0.5), complex(0, 0)),\n  (complex(0, 0.5), complex(0, 0), complex(0, 0)),\n  (complex(0, 0), complex(0, 0), complex(0, 0))\n)\n\n#let t3 = (\n  (complex(0.5, 0), complex(0, 0), complex(0, 0)),\n  (complex(0, 0), complex(-0.5, 0), complex(0, 0)),\n  (complex(0, 0), complex(0, 0), complex(0, 0))\n)\n\n#let t4 = (\n  (complex(0, 0), complex(0, 0), complex(0.5, 0)),\n  (complex(0, 0), complex(0, 0), complex(0, 0)),\n  (complex(0.5, 0), complex(0, 0), complex(0, 0))\n)\n\n#let t5 = (\n  (complex(0, 0), complex(0, 0), complex(0, -0.5)),\n  (complex(0, 0), complex(0, 0), complex(0, 0)),\n  (complex(0, 0.5), complex(0, 0), complex(0, 0))\n)\n\n#let t6 = (\n  (complex(0, 0), complex(0, 0), complex(0, 0)),\n  (complex(0, 0), complex(0, 0), complex(0.5, 0)),\n  (complex(0, 0), complex(0.5, 0), complex(0, 0))\n)\n\n#let t7 = (\n  (complex(0, 0), complex(0, 0), complex(0, 0)),\n  (complex(0, 0), complex(0, 0), complex(0, -0.5)),\n  (complex(0, 0), complex(0, 0.5), complex(0, 0))\n)\n\n#let factor = 1/(2*calc.sqrt(3))\n#let t8 = (\n  (complex(factor, 0), complex(0, 0), complex(0, 0)),\n  (complex(0, 0), complex(factor, 0), complex(0, 0)),\n  (complex(0, 0), complex(0, 0), complex(-2*factor, 0))\n)\n\n#let t = (t1, t2, t3, t4, t5, t6, t7, t8)\n\n#let calculate-f(a, b, c, Cr) = {\n  let a_idx = a - 1\n  let b_idx = b - 1\n  let c_idx = c - 1\n  \n  let comm = mat-commutator(t.at(a_idx), t.at(b_idx))\n  let prod = mat-mul(comm, t.at(c_idx))\n  let tr = mat-trace(prod)\n  \n  // f^(abc) = -i/Cr * Tr([t_a, t_b] t_c)\n  let result = complex-mul(complex(0, -1/Cr), tr)\n  \n  return (\n    commutator: comm,\n    product: prod,\n    trace: tr,\n    result: result\n  )\n}\n\n#let Cr = 1 // Normalization constant\n\n#let display-calculation(a, b, c) = {\n  let res = calculate-f(a, b, c, Cr)\n  \n  [\n    == Structure Constant $f^(#a #b #c)$\n    \n    *Step 1:* Calculate the commutator $[t_(#a), t_(#b)]$\n    \n    $ [t_(#a), t_(#b)] = t_(#a) t_(#b) - t_(#b) t_(#a) = mat(\n        #format-complex(res.commutator.at(0).at(0)), #format-complex(res.commutator.at(0).at(1)), #format-complex(res.commutator.at(0).at(2));\n        #format-complex(res.commutator.at(1).at(0)), #format-complex(res.commutator.at(1).at(1)), #format-complex(res.commutator.at(1).at(2));\n        #format-complex(res.commutator.at(2).at(0)), #format-complex(res.commutator.at(2).at(1)), #format-complex(res.commutator.at(2).at(2))\n      ) $\n    \n    *Step 2:* Multiply by $t_(#c)$ to get $[t_(#a), t_(#b)]t_(#c)$\n    \n    $ [t_(#a), t_(#b)]t_(#c) = mat(\n        #format-complex(res.product.at(0).at(0)), #format-complex(res.product.at(0).at(1)), #format-complex(res.product.at(0).at(2));\n        #format-complex(res.product.at(1).at(0)), #format-complex(res.product.at(1).at(1)), #format-complex(res.product.at(1).at(2));\n        #format-complex(res.product.at(2).at(0)), #format-complex(res.product.at(2).at(1)), #format-complex(res.product.at(2).at(2))\n      ) $\n    \n    *Step 3:* Calculate the trace\n    \n    $ Tr([t_(#a), t_(#b)]t_(#c)) = #format-complex(res.trace) $\n    \n    *Step 4:* Multiply by $-i/C_r$ to get the structure constant\n    \n    $ f^(#a #b #c) = frac(-i, C_r) Tr([t_(#a), t_(#b)]t_(#c)) = #format-complex(res.result) $\n  ]\n}\n\n// Sample calculations for a few structure constants\n#display-calculation(1, 2, 3)\n```\n\nThe two primary issues I am having is that, when trying to render:\n\n```typc\nmat(\n        #format-complex(res.product.at(0).at(0)), #format-complex(res.product.at(0).at(1)), #format-complex(res.product.at(0).at(2));\n        #format-complex(res.product.at(1).at(0)), #format-complex(res.product.at(1).at(1)), #format-complex(res.product.at(1).at(2));\n        #format-complex(res.product.at(2).at(0)), #format-complex(res.product.at(2).at(1)), #format-complex(res.product.at(2).at(2))\n      ) \n```\n\nand similarly for the other matrix, it refuses to render as a matrix. What I get is, e.g. `(0.5i 0 00 −0.5i 00 0 0)`, rather than the block form it should have. I cannot figure out what's going on. I assume the input matrix elements are somehow messing with the rendering.\n\nThe second issue I am facing is that I need to use `1/(2*calc.sqrt(3))` for one of the Gell-Mann matrices, but that converts it to a float, making it impossible to render it as `1/sqrt(3)` if the output still has the `sqrt(3)`.\n\nDoes anyone understand why the matrices aren't rendering, and if there's a way to get the `sqrt()` to still render, even if actual automated calculations require `calc.sqrt(3)`?",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 0,
      "reads": 31,
      "score": 61.2,
      "accepted_answer": false,
      "trust_level": 1,
      "user_id": 788
    },
    {
      "id": 11335,
      "post_number": 2,
      "username": "janekfleper",
      "name": "Janek Fleper",
      "created_at": "2025-04-19T14:14:59.934Z",
      "updated_at": "2025-04-19T14:17:06.890Z",
      "cooked": "<aside class=\"quote no-group\" data-username=\"Paul744\" data-post=\"1\" data-topic=\"3728\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/letter_avatar_proxy/v4/letter/p/5D25C6/48.png\" class=\"avatar\"> Paul744:</div>\n<blockquote>\n<pre data-code-wrap=\"typm\"><code class=\"lang-typm\">mat(\n  #format-complex(res.product.at(0).at(0)), #format-complex(res.product.at(0).at(1)), #format-complex(res.product.at(0).at(2));\n  #format-complex(res.product.at(1).at(0)), #format-complex(res.product.at(1).at(1)), #format-complex(res.product.at(1).at(2));\n  #format-complex(res.product.at(2).at(0)), #format-complex(res.product.at(2).at(1)), #format-complex(res.product.at(2).at(2))\n) \n</code></pre>\n</blockquote>\n</aside>\n<p>Inserting a space before the semicolon fixes the rendering of the matrix, although I am not sure why the matrix function is behaving like that in the first place. You do not need the space when you create a matrix with (string) elements manually.</p>\n<p>Note that the code you shared did not compile because the function <code>Tr()</code> was not defined. For future questions please only share as much code as necessary to reproduce your issue. In this case the function <code>format-complex()</code> and the matrix would have been sufficient.</p>\n<p>I don’t really understand your second issue with <code>calc.sqrt(3)</code> and <code>1/sqrt(3)</code>. Could you please create a small (code) example to show what you are trying to achieve?</p>",
      "raw": "[quote=\"Paul744, post:1, topic:3728\"]\n```typm\nmat(\n  #format-complex(res.product.at(0).at(0)), #format-complex(res.product.at(0).at(1)), #format-complex(res.product.at(0).at(2));\n  #format-complex(res.product.at(1).at(0)), #format-complex(res.product.at(1).at(1)), #format-complex(res.product.at(1).at(2));\n  #format-complex(res.product.at(2).at(0)), #format-complex(res.product.at(2).at(1)), #format-complex(res.product.at(2).at(2))\n) \n```\n[/quote]\n\nInserting a space before the semicolon fixes the rendering of the matrix, although I am not sure why the matrix function is behaving like that in the first place. You do not need the space when you create a matrix with (string) elements manually.\n\nNote that the code you shared did not compile because the function `Tr()` was not defined. For future questions please only share as much code as necessary to reproduce your issue. In this case the function `format-complex()` and the matrix would have been sufficient.\n\nI don't really understand your second issue with `calc.sqrt(3)` and `1/sqrt(3)`. Could you please create a small (code) example to show what you are trying to achieve?",
      "reply_to_post_number": null,
      "reply_count": 2,
      "quote_count": 1,
      "like_count": 1,
      "reads": 28,
      "score": 30.6,
      "accepted_answer": true,
      "trust_level": 3,
      "user_id": 69
    },
    {
      "id": 11336,
      "post_number": 3,
      "username": "Paul744",
      "name": "Paul",
      "created_at": "2025-04-19T14:33:42.777Z",
      "updated_at": "2025-04-19T17:12:05.121Z",
      "cooked": "<p>Thanks for pointing out the spacing. Yeah, that is exceptionally odd, but if it works, it works.</p>\n<p>And thanks for pointing out the Tr() function issue. I defined that manually via:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let Tr = math.upright(\"Tr\")\n</code></pre>\n<p>I’ll add that to the original post.</p>\n<p>As for what I am trying to get out from the sqrt(3) situation, as an example, if one tries to evaluate:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#display-calculation(1, 2, 8)\n</code></pre>\n<p>one will get on step 2, a diagonal matrix with 0.14433756729740646i as the diagonal element, rather than something like i/(4 sqrt(3)). In short, I am trying to keep the actual sqrt() symbols around, but I don’t know if there’s a way to do that when the actual calculations have to be done with floats. Technically, I would like to get this working with stuff like 0.5 as well, but the sqrt(3) is the really egregious issue.</p>",
      "raw": "Thanks for pointing out the spacing. Yeah, that is exceptionally odd, but if it works, it works.\n\nAnd thanks for pointing out the Tr() function issue. I defined that manually via:\n```typ\n#let Tr = math.upright(\"Tr\")\n```\nI'll add that to the original post.\n\nAs for what I am trying to get out from the sqrt(3) situation, as an example, if one tries to evaluate:\n```typ\n#display-calculation(1, 2, 8)\n```\none will get on step 2, a diagonal matrix with 0.14433756729740646i as the diagonal element, rather than something like i/(4 sqrt(3)). In short, I am trying to keep the actual sqrt() symbols around, but I don't know if there's a way to do that when the actual calculations have to be done with floats. Technically, I would like to get this working with stuff like 0.5 as well, but the sqrt(3) is the really egregious issue.",
      "reply_to_post_number": 2,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 0,
      "reads": 28,
      "score": 10.6,
      "accepted_answer": false,
      "trust_level": 1,
      "user_id": 788
    },
    {
      "id": 11337,
      "post_number": 4,
      "username": "janekfleper",
      "name": "Janek Fleper",
      "created_at": "2025-04-19T14:42:29.992Z",
      "updated_at": "2025-04-19T14:43:04.868Z",
      "cooked": "<p>If you don’t actually need the prefactor <code>1/sqrt(3)</code> for the computation, could you not just store this separately from the matrix? You would then have an array <code>f</code> that holds the prefactors of the matrices <code>t1</code> to <code>t8</code>. The matrix computations would then just need integer math and you would include the prefactor(s) again after the computations.</p>",
      "raw": "If you don't actually need the prefactor `1/sqrt(3)` for the computation, could you not just store this separately from the matrix? You would then have an array `f` that holds the prefactors of the matrices `t1` to `t8`. The matrix computations would then just need integer math and you would include the prefactor(s) again after the computations.",
      "reply_to_post_number": 3,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 2,
      "reads": 26,
      "score": 40.2,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 69
    },
    {
      "id": 11338,
      "post_number": 5,
      "username": "Paul744",
      "name": "Paul",
      "created_at": "2025-04-19T14:53:26.105Z",
      "updated_at": "2025-04-19T14:53:26.105Z",
      "cooked": "<p>That’s actually a good point. This wouldn’t work for a more general calculation if I needed to be able to square sqrt(3) (assuming the calculation kept the problematic overflow like 3.0000000001), but since f^(a b c) is antisymmetric, that isn’t an issue. I’ll make use of that. Thanks.</p>",
      "raw": "That's actually a good point. This wouldn't work for a more general calculation if I needed to be able to square sqrt(3) (assuming the calculation kept the problematic overflow like 3.0000000001), but since f^(a b c) is antisymmetric, that isn't an issue. I'll make use of that. Thanks.",
      "reply_to_post_number": 4,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 0,
      "reads": 23,
      "score": 9.6,
      "accepted_answer": false,
      "trust_level": 1,
      "user_id": 788
    },
    {
      "id": 11339,
      "post_number": 6,
      "username": "janekfleper",
      "name": "Janek Fleper",
      "created_at": "2025-04-19T15:04:32.196Z",
      "updated_at": "2025-04-19T15:04:32.196Z",
      "cooked": "<p>You could generalize this further by storing the prefactor in a dictionary where the “value” and the “exponent” are kept separately, e.g.</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let f8 = (value: 3, exponent: decimal(\"0.5\"))\n</code></pre>\n<p>If you need to square this, you would then add the exponents to get <code>decimal(\"1.0\")</code> in which case you would just omit the square root. I know that this is not the most convenient thing to work with, but you can get vary far with integer + decimal math. Even multiplying and reducing fractions is possible without ever touching floating point math.</p>",
      "raw": "You could generalize this further by storing the prefactor in a dictionary where the \"value\" and the \"exponent\" are kept separately, e.g.\n\n```typ\n#let f8 = (value: 3, exponent: decimal(\"0.5\"))\n```\nIf you need to square this, you would then add the exponents to get `decimal(\"1.0\")` in which case you would just omit the square root. I know that this is not the most convenient thing to work with, but you can get vary far with integer + decimal math. Even multiplying and reducing fractions is possible without ever touching floating point math.",
      "reply_to_post_number": 5,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 1,
      "reads": 22,
      "score": 24.4,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 69
    },
    {
      "id": 11341,
      "post_number": 7,
      "username": "Paul744",
      "name": "Paul",
      "created_at": "2025-04-19T15:27:05.134Z",
      "updated_at": "2025-04-19T15:27:05.134Z",
      "cooked": "<p>I really like that dictionary idea, and I might have to play around to see if I can get that to work. And while I can see how one might do multiplication of fractions, it’s less obvious how one would do reduction, unless the idea is to do 0 actual multiplication when combining fractions, keeping all the factors separated, and then trying to track down terms with the same base.</p>",
      "raw": "I really like that dictionary idea, and I might have to play around to see if I can get that to work. And while I can see how one might do multiplication of fractions, it's less obvious how one would do reduction, unless the idea is to do 0 actual multiplication when combining fractions, keeping all the factors separated, and then trying to track down terms with the same base.",
      "reply_to_post_number": 6,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 22,
      "score": 9.4,
      "accepted_answer": false,
      "trust_level": 1,
      "user_id": 788
    },
    {
      "id": 11344,
      "post_number": 8,
      "username": "SillyFreak",
      "name": "SillyFreak",
      "created_at": "2025-04-19T17:13:49.830Z",
      "updated_at": "2025-04-19T17:13:49.830Z",
      "cooked": "<aside class=\"quote no-group\" data-username=\"janekfleper\" data-post=\"2\" data-topic=\"3728\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/letter_avatar_proxy/v4/letter/j/8F38B1/48.png\" class=\"avatar\"> janekfleper:</div>\n<blockquote>\n<p>Inserting a space before the semicolon fixes the rendering of the matrix, although I am not sure why the matrix function is behaving like that in the first place.</p>\n</blockquote>\n</aside>\n<p>The reason is that <code>;</code> ends a code block, and the function call is done with one (<code>#</code> starts it): <code>#format-complex(...);</code></p>\n<p>with the space, the code block already ends at <code>)</code> and thus the <code>;</code> is part of the matrix syntax</p>",
      "raw": "[quote=\"janekfleper, post:2, topic:3728\"]\nInserting a space before the semicolon fixes the rendering of the matrix, although I am not sure why the matrix function is behaving like that in the first place.\n[/quote]\n\nThe reason is that `;` ends a code block, and the function call is done with one (`#` starts it): `#format-complex(...);`\n\nwith the space, the code block already ends at `)` and thus the `;` is part of the matrix syntax",
      "reply_to_post_number": 2,
      "reply_count": 0,
      "quote_count": 1,
      "like_count": 1,
      "reads": 23,
      "score": 24.6,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 32
    },
    {
      "id": 11366,
      "post_number": 9,
      "username": "Paul744",
      "name": "Paul",
      "created_at": "2025-04-20T17:56:00.595Z",
      "updated_at": "2025-04-20T21:44:13.281Z",
      "cooked": "<p>In case anyone is curious, this is what I eventually got working:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let Tr = math.upright(\"Tr\")\n\n// ============ SYMBOLIC FRACTION IMPLEMENTATION ============\n\n// Basic symbolic fraction representation\n#let sym-frac(num, denom) = {\n  // Ensure we always have integer representations\n  if type(num) != int { num = calc.round(num) }\n  if type(denom) != int { denom = calc.round(denom) }\n  \n  // Handle special cases\n  if denom == 0 { panic(\"Division by zero\") }\n  if num == 0 { return (type: \"sym-frac\", num: 0, denom: 1, sign: 1) }\n  \n  // Normalize negative signs - always store them separately\n  let sign = 1\n  if (num &lt; 0 and denom &gt; 0) or (num &gt; 0 and denom &lt; 0) {\n    sign = -1 // Negative fraction\n  }\n  num = calc.abs(num)\n  denom = calc.abs(denom)\n  \n  // Create fraction with normalized sign\n  return (\n    type: \"sym-frac\",\n    num: num,     // Always positive\n    denom: denom, // Always positive\n    sign: sign    // -1 if fraction is negative, 1 if positive\n  )\n}\n\n// Fraction arithmetic operations\n#let frac-add(f1, f2) = {\n  if f1.type != \"sym-frac\" or f2.type != \"sym-frac\" {\n    panic(\"Expected symbolic fractions\")\n  }\n  \n  // a/b + c/d = (ad + bc)/bd\n  // With signs: (sign_a * a)/b + (sign_c * c)/d\n  let sign_a_val = if f1.sign &lt; 0 { -f1.num } else { f1.num }\n  let sign_c_val = if f2.sign &lt; 0 { -f2.num } else { f2.num }\n  \n  let num = sign_a_val * f2.denom + sign_c_val * f1.denom\n  let denom = f1.denom * f2.denom\n  \n  return sym-frac(num, denom)\n}\n\n#let frac-sub(f1, f2) = {\n  if f1.type != \"sym-frac\" or f2.type != \"sym-frac\" {\n    panic(\"Expected symbolic fractions\")\n  }\n  \n  // a/b - c/d = (ad - bc)/bd\n  // With signs: (sign_a * a)/b - (sign_c * c)/d\n  let sign_a_val = if f1.sign &lt; 0 { -f1.num } else { f1.num }\n  let sign_c_val = if f2.sign &lt; 0 { -f2.num } else { f2.num }\n  \n  let num = sign_a_val * f2.denom - sign_c_val * f1.denom\n  let denom = f1.denom * f2.denom\n  \n  return sym-frac(num, denom)\n}\n\n#let frac-mul(f1, f2) = {\n  if f1.type != \"sym-frac\" or f2.type != \"sym-frac\" {\n    panic(\"Expected symbolic fractions\")\n  }\n  \n  // (a/b) * (c/d) = (ac)/(bd)\n  // Sign: sign_a * sign_c\n  let num = f1.num * f2.num\n  let denom = f1.denom * f2.denom\n  let sign = f1.sign * f2.sign\n  \n  return (\n    type: \"sym-frac\",\n    num: num,\n    denom: denom,\n    sign: sign\n  )\n}\n\n#let frac-div(f1, f2) = {\n  if f1.type != \"sym-frac\" or f2.type != \"sym-frac\" {\n    panic(\"Expected symbolic fractions\")\n  }\n  \n  // (a/b) / (c/d) = (ad)/(bc)\n  // Sign: sign_a * sign_c\n  let num = f1.num * f2.denom\n  let denom = f1.denom * f2.num\n  let sign = f1.sign * f2.sign\n  \n  return (\n    type: \"sym-frac\",\n    num: num,\n    denom: denom,\n    sign: sign\n  )\n}\n\n#let frac-neg(f) = {\n  if f.type != \"sym-frac\" {\n    panic(\"Expected symbolic fraction\")\n  }\n  \n  // Negate the sign\n  return (\n    type: \"sym-frac\",\n    num: f.num,\n    denom: f.denom,\n    sign: -f.sign\n  )\n}\n\n#let frac-is-zero(f) = {\n  if f.type != \"sym-frac\" {\n    panic(\"Expected symbolic fraction\")\n  }\n  \n  return f.num == 0\n}\n\n#let frac-is-one(f) = {\n  if f.type != \"sym-frac\" {\n    panic(\"Expected symbolic fraction\")\n  }\n  \n  return f.num == f.denom and f.sign &gt; 0\n}\n\n// Format a symbolic fraction\n#let format-frac(f) = {\n  if f.type != \"sym-frac\" {\n    panic(\"Expected symbolic fraction\")\n  }\n  \n  if f.denom == 1 {\n    if f.sign &lt; 0 {\n      return [-#f.num]\n    } else {\n      return [#f.num]\n    }\n  } else {\n    let fraction = math.frac([#f.num], [#f.denom])\n    if f.sign &lt; 0 {\n      return [-#fraction]\n    } else {\n      return fraction\n    }\n  }\n}\n\n// ============ ALGEBRAIC NUMBER SYSTEM ============\n\n// Clone a dictionary (since Typst dictionaries don't have a clone method)\n#let clone-dict(dict) = {\n  let result = (:)\n  for (key, value) in dict {\n    result.insert(key, value)\n  }\n  return result\n}\n\n// Represent an algebraic number with symbolic fractions for coefficients\n#let alg-num(\n  real-coef-num: 1, real-coef-denom: 1, real-factors: (:),\n  imag-coef-num: 0, imag-coef-denom: 1, imag-factors: (:)\n) = {\n  return (\n    type: \"algebraic\",\n    real: (\n      coef: sym-frac(real-coef-num, real-coef-denom),\n      factors: clone-dict(real-factors)\n    ),\n    imag: (\n      coef: sym-frac(imag-coef-num, imag-coef-denom),\n      factors: clone-dict(imag-factors)\n    )\n  )\n}\n\n// Convenience constructors\n#let alg-int(n) = alg-num(real-coef-num: n, real-coef-denom: 1)\n#let alg-i = alg-num(real-coef-num: 0, imag-coef-num: 1, imag-coef-denom: 1)\n\n// Create a proper fraction\n#let alg-frac(num, denom) = {\n  return alg-num(real-coef-num: num, real-coef-denom: denom)\n}\n\n// Create a square root\n#let alg-sqrt(n) = {\n  let factors = (:)\n  // Convert n to string if it's an integer\n  let base = if type(n) == int { str(n) } else { n }\n  factors.insert(base, decimal(\"0.5\"))\n  return alg-num(real-factors: factors)\n}\n\n// Create a reciprocal square root (1/√n)\n#let alg-rsqrt(n) = {\n  let factors = (:)\n  // Convert n to string if it's an integer\n  let base = if type(n) == int { str(n) } else { n }\n  factors.insert(base, decimal(\"-0.5\"))\n  return alg-num(real-factors: factors)\n}\n\n// Check if a decimal is approximately an integer\n#let is-integer(dec) = {\n  let int_value = calc.round(dec)\n  if type(dec) == decimal {\n    return calc.abs(dec - decimal(str(int_value))) &lt; decimal(\"0.00001\")\n  } else {\n    return calc.abs(dec - int_value) &lt; 0.00001\n  }\n}\n\n// Simplify one part (real or imaginary) of an algebraic number\n#let simplify-part(part) = {\n  let coef = part.coef\n  let factors = clone-dict(part.factors)\n  \n  // Handle zero coefficient\n  if frac-is-zero(coef) {\n    return (coef: sym-frac(0, 1), factors: (:))\n  }\n  \n  // Simplify factors with zero or integer exponents\n  let keys = factors.keys()\n  for base in keys {\n    let exp = factors.at(base)\n    \n    // Convert to decimal if not already\n    if type(exp) != decimal {\n      exp = decimal(str(exp))\n      factors.at(base) = exp\n    }\n    \n    // Remove factors with zero exponent\n    if exp == decimal(\"0\") {\n      factors.remove(base)\n    }\n  }\n  \n  return (coef: coef, factors: factors)\n}\n\n// Simplify an algebraic number\n#let simplify-alg(num) = {\n  if num.type != \"algebraic\" {\n    return alg-int(num)\n  }\n  \n  // Simplify both parts\n  let real-part = simplify-part(num.real)\n  let imag-part = simplify-part(num.imag)\n  \n  // Create the simplified number\n  return (\n    type: \"algebraic\",\n    real: real-part,\n    imag: imag-part\n  )\n}\n\n// Multiply a part (real or imaginary) by another part\n#let multiply-parts(a, b) = {\n  // If either coefficient is zero, result is zero\n  if frac-is-zero(a.coef) or frac-is-zero(b.coef) {\n    return (coef: sym-frac(0, 1), factors: (:))\n  }\n  \n  // Multiply coefficients\n  let coef = frac-mul(a.coef, b.coef)\n  \n  // Combine factors by adding exponents\n  let result_factors = clone-dict(a.factors)\n  for (base, exp) in b.factors {\n    if base in result_factors {\n      result_factors.at(base) = result_factors.at(base) + exp\n    } else {\n      result_factors.insert(base, exp)\n    }\n  }\n  \n  return (coef: coef, factors: result_factors)\n}\n\n// Multiply two algebraic numbers\n#let alg-mul(a, b) = {\n  if a.type != \"algebraic\" {\n    a = alg-int(a)\n  }\n  if b.type != \"algebraic\" {\n    b = alg-int(b)\n  }\n  \n  // (a + bi)(c + di) = (ac - bd) + (ad + bc)i\n  \n  // Real part: ac - bd\n  let real_ac = multiply-parts(a.real, b.real)\n  let real_bd = multiply-parts(a.imag, b.imag)\n  \n  // Imaginary part: ad + bc\n  let imag_ad = multiply-parts(a.real, b.imag)\n  let imag_bc = multiply-parts(a.imag, b.real)\n  \n  // For the real part, need to subtract bd from ac\n  let real_result\n  if frac-is-zero(real_bd.coef) {\n    // If bd is zero, real part is just ac\n    real_result = real_ac\n  } else if frac-is-zero(real_ac.coef) {\n    // If ac is zero, real part is -bd\n    real_result = (\n      coef: frac-neg(real_bd.coef),\n      factors: real_bd.factors\n    )\n  } else {\n    // Both non-zero, but we can only combine if they have identical factors\n    let factors_match = true\n    if real_ac.factors.keys().sorted() == real_bd.factors.keys().sorted() {\n      for (base, exp_ac) in real_ac.factors {\n        let exp_bd = real_bd.factors.at(base, default: none)\n        if exp_bd == none or exp_ac != exp_bd {\n          factors_match = false\n          break\n        }\n      }\n    } else {\n      factors_match = false\n    }\n    \n    if factors_match {\n      real_result = (\n        coef: frac-sub(real_ac.coef, real_bd.coef),\n        factors: real_ac.factors\n      )\n    } else {\n      // If we can't combine, just use ac for now\n      real_result = real_ac\n    }\n  }\n  \n  // For the imaginary part, need to add ad and bc\n  let imag_result\n  if frac-is-zero(imag_ad.coef) {\n    // If ad is zero, imaginary part is just bc\n    imag_result = imag_bc\n  } else if frac-is-zero(imag_bc.coef) {\n    // If bc is zero, imaginary part is just ad\n    imag_result = imag_ad\n  } else {\n    // Both non-zero, but we can only combine if they have identical factors\n    let factors_match = true\n    if imag_ad.factors.keys().sorted() == imag_bc.factors.keys().sorted() {\n      for (base, exp_ad) in imag_ad.factors {\n        let exp_bc = imag_bc.factors.at(base, default: none)\n        if exp_bc == none or exp_ad != exp_bc {\n          factors_match = false\n          break\n        }\n      }\n    } else {\n      factors_match = false\n    }\n    \n    if factors_match {\n      imag_result = (\n        coef: frac-add(imag_ad.coef, imag_bc.coef),\n        factors: imag_ad.factors\n      )\n    } else {\n      // If we can't combine, just use ad for now\n      imag_result = imag_ad\n    }\n  }\n\n  return simplify-alg((\n    type: \"algebraic\",\n    real: real_result,\n    imag: imag_result\n  ))\n}\n\n// Calculate the complex conjugate of an algebraic number\n#let alg-conjugate(a) = {\n  if a.type != \"algebraic\" {\n    a = alg-int(a)\n  }\n  \n  // Negate the imaginary part\n  return (\n    type: \"algebraic\",\n    real: a.real,\n    imag: (\n      coef: frac-neg(a.imag.coef),\n      factors: clone-dict(a.imag.factors)\n    )\n  )\n}\n\n// Divide two algebraic numbers using a/(b+ci) = a(b-ci)/(b²+c²)\n#let alg-div(a, b) = {\n  if a.type != \"algebraic\" {\n    a = alg-int(a)\n  }\n  if b.type != \"algebraic\" {\n    b = alg-int(b)\n  }\n  \n  // Special case: denominator is pure real\n  if frac-is-zero(b.imag.coef) {\n    // Create copies of a's factors\n    let real_factors = clone-dict(a.real.factors)\n    let imag_factors = clone-dict(a.imag.factors)\n    \n    // For each factor in the denominator, add it with negated exponent\n    for (base, exp) in b.real.factors {\n      if base in real_factors {\n        real_factors.at(base) = real_factors.at(base) - exp\n      } else {\n        real_factors.insert(base, -exp) // Add with negative exponent\n      }\n      \n      if base in imag_factors {\n        imag_factors.at(base) = imag_factors.at(base) - exp\n      } else {\n        imag_factors.insert(base, -exp) // Add with negative exponent\n      }\n    }\n    \n    return (\n      type: \"algebraic\",\n      real: (\n        coef: frac-div(a.real.coef, b.real.coef),\n        factors: real_factors  // Now contains correct combined factors\n      ),\n      imag: (\n        coef: frac-div(a.imag.coef, b.real.coef),\n        factors: imag_factors  // Now contains correct combined factors\n      )\n    )\n  }\n  \n  // For complex denominators, multiply by conjugate\n  // a/(b+ci) = a(b-ci)/((b+ci)(b-ci)) = a(b-ci)/(b²+c²)\n  let b_conj = alg-conjugate(b)\n  \n  // Multiply numerator by conjugate of denominator\n  let num = alg-mul(a, b_conj)\n  \n  // Calculate denominator: (b+ci)(b-ci) = b² + c²\n  let denom = alg-mul(b, b_conj)\n  \n  // Now denom should be real-only\n  if not frac-is-zero(denom.imag.coef) {\n    // This should not happen mathematically\n    return simplify-alg(num)\n  }\n  \n  // Divide by the real denominator\n  return alg-div(num, denom)\n}\n\n// Format an algebraic number for display\n#let format-alg(num) = {\n  if num.type != \"algebraic\" {\n    return str(num)\n  }\n  \n  num = simplify-alg(num)\n  \n  // Special case for zero\n  if frac-is-zero(num.real.coef) and frac-is-zero(num.imag.coef) {\n    return \"0\"\n  }\n  \n  // Function to format a single part (real or imaginary)\n  let format-part(part) = {\n    let coef = part.coef\n    let factors = part.factors\n    \n    // If coefficient is zero, return empty content\n    if frac-is-zero(coef) {\n      return []\n    }\n    \n    // Separate factors into positive and negative exponents\n    let pos_factors = (:)\n    let neg_factors = (:)\n    for (base, exp) in factors {\n      if exp &gt; decimal(\"0\") {\n        pos_factors.insert(base, exp)\n      } else if exp &lt; decimal(\"0\") {\n        neg_factors.insert(base, -exp) // Store positive value in neg_factors\n      }\n    }\n    \n    // Get the sign for the entire expression\n    let sign_content = []\n    if coef.sign &lt; 0 {\n      sign_content = math.minus\n    }\n    \n    // Format the numerator (coefficient and positive exponent factors)\n    let num_content = []\n    \n    // Add coefficient absolute value if not 1 or if there are no positive factors\n    if coef.num != coef.denom or pos_factors.keys().len() == 0 {\n      if coef.num == coef.denom {\n        // Coefficient is 1, don't show it unless there are no factors\n        if pos_factors.keys().len() == 0 {\n          num_content = [1]\n        }\n      } else {\n        // Show the coefficient (always positive now)\n        num_content = [#coef.num]\n      }\n    }\n    \n    // Add positive exponent factors\n    let sorted_pos_factors = pos_factors.keys().sorted()\n    for base in sorted_pos_factors {\n      let exp = pos_factors.at(base)\n      if exp == decimal(\"0.5\") {\n        num_content = [#num_content #math.sqrt(base)]\n      } else if exp == decimal(\"1\") {\n        num_content = [#num_content #base]\n      } else {\n        num_content = [#num_content #base^(#exp)]\n      }\n    }\n    \n    // Check if we need a fraction\n    // If we have no negative factors and denominator is 1, no fraction needed\n    if neg_factors.keys().len() == 0 and coef.denom == 1 {\n      return [#sign_content #num_content]\n    }\n    \n    // Format the denominator (coefficient denominator and negative exponent factors)\n    let denom_content = []\n    \n    // Add coefficient denominator if not 1\n    if coef.denom != 1 {\n      denom_content = [#coef.denom]\n    }\n    \n    // Add negative exponent factors\n    let sorted_neg_factors = neg_factors.keys().sorted()\n    for base in sorted_neg_factors {\n      let exp = neg_factors.at(base)\n      if exp == decimal(\"0.5\") {\n        denom_content = [#denom_content #math.sqrt(base)]\n      } else if exp == decimal(\"1\") {\n        denom_content = [#denom_content #base]\n      } else {\n        denom_content = [#denom_content #base^(#exp)]\n      }\n    }\n    \n    // Return the fraction with sign outside\n    let fraction = math.frac([#num_content], [#denom_content])\n    return [#sign_content #fraction]\n  }\n  \n  // Format real and imaginary parts\n  let real_result = format-part(num.real)\n  let imag_result = format-part(num.imag)\n  \n  // If imaginary part has content, add 'i'\n  if not frac-is-zero(num.imag.coef) {\n    imag_result = [#imag_result i]\n  }\n  \n  // Combine real and imaginary parts\n  if frac-is-zero(num.real.coef) {\n    return imag_result\n  } else if frac-is-zero(num.imag.coef) {\n    return real_result\n  } else {\n    // Need + sign between real and imaginary parts (but only if imag is positive)\n    if num.imag.coef.sign &gt; 0 {\n      return [#real_result + #imag_result]\n    } else {\n      // The minus sign is already included in imag_result\n      return [#real_result #imag_result]\n    }\n  }\n}\n\n// ============ COMPLEX NUMBER IMPLEMENTATION (FOR MATRICES) ============\n\n// Basic complex number operations (used for matrices)\n#let complex(a, b) = (a, b)\n#let complex-add(z1, z2) = (z1.at(0) + z2.at(0), z1.at(1) + z2.at(1))\n#let complex-sub(z1, z2) = (z1.at(0) - z2.at(0), z1.at(1) - z2.at(1))\n#let complex-mul(z1, z2) = (\n  z1.at(0) * z2.at(0) - z1.at(1) * z2.at(1),\n  z1.at(0) * z2.at(1) + z1.at(1) * z2.at(0)\n)\n#let complex-scale(z, s) = (z.at(0) * s, z.at(1) * s)\n\n// Convert complex to algebraic\n#let complex-to-alg(z) = {\n  let real = z.at(0)\n  let imag = z.at(1)\n  \n  return alg-num(\n    real-coef-num: real, real-coef-denom: 1,\n    imag-coef-num: imag, imag-coef-denom: 1\n  )\n}\n\n// Format a complex number for matrix display\n#let format-complex(z) = {\n  let real = z.at(0)\n  let imag = z.at(1)\n  \n  if imag == 0 {\n    return str(real)\n  } else if real == 0 {\n    if imag == 1 { return \"i\" }\n    else if imag == -1 { return \"-i\" }\n    else { return str(imag) + \"i\" }\n  } else {\n    let sign = if imag &gt; 0 { \"+\" } else { \"-\" }\n    let abs-imag = calc.abs(imag)\n    if abs-imag == 1 {\n      return str(real) + sign + \"i\"\n    } else {\n      return str(real) + sign + str(abs-imag) + \"i\"\n    }\n  }\n}\n\n// ============ MATRIX OPERATIONS ============\n\n#let mat-add(A, B) = {\n  let rows = A.len()\n  let cols = A.at(0).len()\n  \n  let result = ()\n  for i in range(rows) {\n    let row = ()\n    for j in range(cols) {\n      row.push(complex-add(A.at(i).at(j), B.at(i).at(j)))\n    }\n    result.push(row)\n  }\n  \n  return result\n}\n\n#let mat-sub(A, B) = {\n  let rows = A.len()\n  let cols = A.at(0).len()\n  \n  let result = ()\n  for i in range(rows) {\n    let row = ()\n    for j in range(cols) {\n      row.push(complex-sub(A.at(i).at(j), B.at(i).at(j)))\n    }\n    result.push(row)\n  }\n  \n  return result\n}\n\n#let mat-mul(A, B) = {\n  let rows_A = A.len()\n  let cols_A = A.at(0).len()\n  let cols_B = B.at(0).len()\n  \n  let result = ()\n  for i in range(rows_A) {\n    let row = ()\n    for j in range(cols_B) {\n      let sum = complex(0, 0)\n      for k in range(cols_A) {\n        sum = complex-add(sum, complex-mul(A.at(i).at(k), B.at(k).at(j)))\n      }\n      row.push(sum)\n    }\n    result.push(row)\n  }\n  \n  return result\n}\n\n#let mat-commutator(A, B) = {\n  let AB = mat-mul(A, B)\n  let BA = mat-mul(B, A)\n  return mat-sub(AB, BA)\n}\n\n#let mat-trace(A) = {\n  let sum = complex(0, 0)\n  let n = A.len()\n  \n  for i in range(n) {\n    sum = complex-add(sum, A.at(i).at(i))\n  }\n  \n  return sum\n}\n\n// ============ GELL-MANN MATRICES ============\n\n// Define Gell-Mann matrices without prefactors\n#let t1_base = (\n  (complex(0, 0), complex(1, 0), complex(0, 0)),\n  (complex(1, 0), complex(0, 0), complex(0, 0)),\n  (complex(0, 0), complex(0, 0), complex(0, 0))\n)\n\n#let t2_base = (\n  (complex(0, 0), complex(0, -1), complex(0, 0)),\n  (complex(0, 1), complex(0, 0), complex(0, 0)),\n  (complex(0, 0), complex(0, 0), complex(0, 0))\n)\n\n#let t3_base = (\n  (complex(1, 0), complex(0, 0), complex(0, 0)),\n  (complex(0, 0), complex(-1, 0), complex(0, 0)),\n  (complex(0, 0), complex(0, 0), complex(0, 0))\n)\n\n#let t4_base = (\n  (complex(0, 0), complex(0, 0), complex(1, 0)),\n  (complex(0, 0), complex(0, 0), complex(0, 0)),\n  (complex(1, 0), complex(0, 0), complex(0, 0))\n)\n\n#let t5_base = (\n  (complex(0, 0), complex(0, 0), complex(0, -1)),\n  (complex(0, 0), complex(0, 0), complex(0, 0)),\n  (complex(0, 1), complex(0, 0), complex(0, 0))\n)\n\n#let t6_base = (\n  (complex(0, 0), complex(0, 0), complex(0, 0)),\n  (complex(0, 0), complex(0, 0), complex(1, 0)),\n  (complex(0, 0), complex(1, 0), complex(0, 0))\n)\n\n#let t7_base = (\n  (complex(0, 0), complex(0, 0), complex(0, 0)),\n  (complex(0, 0), complex(0, 0), complex(0, -1)),\n  (complex(0, 0), complex(0, 1), complex(0, 0))\n)\n\n#let t8_base = (\n  (complex(1, 0), complex(0, 0), complex(0, 0)),\n  (complex(0, 0), complex(1, 0), complex(0, 0)),\n  (complex(0, 0), complex(0, 0), complex(-2, 0))\n)\n\n// Create the algebraic prefactors with symbolic fractions\n#let half = alg-frac(1, 2)\n#let sqrt3 = alg-sqrt(3)\n#let half_sqrt3 = alg-div(half, sqrt3)\n\n// Define prefactors for each matrix\n#let prefactors = (\n  half,           // t1: 1/2\n  half,           // t2: 1/2\n  half,           // t3: 1/2\n  half,           // t4: 1/2\n  half,           // t5: 1/2\n  half,           // t6: 1/2\n  half,           // t7: 1/2\n  half_sqrt3      // t8: 1/(2√3)\n)\n\n// Scaled versions of the matrices for display\n#let t_bases = (t1_base, t2_base, t3_base, t4_base, t5_base, t6_base, t7_base, t8_base)\n\n// ============ STRUCTURE CONSTANT CALCULATION ============\n\n// Debug function to examine the structure of an algebraic number\n#let debug-alg(num) = {\n  if num.type != \"algebraic\" {\n    return \"not an algebraic number: \" + str(num)\n  }\n  \n  let real_coef = \"{ num: \" + str(num.real.coef.num) + \", denom: \" + str(num.real.coef.denom) + \" }\"\n  let imag_coef = \"{ num: \" + str(num.imag.coef.num) + \", denom: \" + str(num.imag.coef.denom) + \" }\"\n  \n  let result = \"algebraic: {\\n\"\n  result += \"  real: { coef: \" + real_coef + \", factors: \" + str(num.real.factors) + \" }\\n\"\n  result += \"  imag: { coef: \" + imag_coef + \", factors: \" + str(num.imag.factors) + \" }\\n\"\n  result += \"}\"\n  \n  return result\n}\n\n// Create the structure constants calculation function\n#let calculate-f(a, b, c, Cr) = {\n  let a_idx = a - 1\n  let b_idx = b - 1\n  let c_idx = c - 1\n  \n  // Calculate using base matrices (without prefactors)\n  let comm = mat-commutator(t_bases.at(a_idx), t_bases.at(b_idx))\n  let prod = mat-mul(comm, t_bases.at(c_idx))\n  let tr = mat-trace(prod)\n  \n  // Get prefactors for each matrix\n  let pa = prefactors.at(a_idx)\n  let pb = prefactors.at(b_idx)\n  let pc = prefactors.at(c_idx)\n  \n  // Combined prefactor (pa * pb * pc)\n  let combined_prefactor = alg-mul(pa, alg-mul(pb, pc))\n  \n  // Convert trace to algebraic number\n  let trace_alg = complex-to-alg(tr)\n  \n  // Structure constant formula: f^abc = -i/Cr * Tr([t_a, t_b] t_c) * combined_prefactor\n  let i_factor = alg-div(alg-mul(alg-int(-1), alg-i), alg-int(Cr))\n  \n  // Calculate each intermediate result for debugging\n  let trace_with_prefactor = alg-mul(trace_alg, combined_prefactor)\n  \n  // Final result with everything multiplied\n  let final_result = alg-mul(i_factor, trace_with_prefactor)\n  \n  return (\n    commutator: comm,\n    product: prod,\n    trace: tr,\n    trace_alg: trace_alg,\n    prefactor_a: pa,\n    prefactor_b: pb,\n    prefactor_c: pc,\n    combined_prefactor: combined_prefactor,\n    i_factor: i_factor,\n    trace_with_prefactor: trace_with_prefactor,\n    final_result: final_result\n  )\n}\n\n#let Cr = 1 // Normalization constant\n\n// ============ DISPLAY CALCULATIONS ============\n\n#let display-calculation(a, b, c) = {\n  let res = calculate-f(a, b, c, Cr)\n  \n  [\n    == Structure Constant $f^(#a #b #c)$\n    \n    *Step 1:* Calculate the commutator $[t_(#a), t_(#b)]$\n    \n    $ [t_(#a), t_(#b)] = #format-alg(res.prefactor_a) dot.c #format-alg(res.prefactor_b) (mat(delim: \"[\",\n      #format-complex(t_bases.at(a - 1).at(0).at(0)), #format-complex(t_bases.at(a - 1).at(0).at(1)), #format-complex(t_bases.at(a - 1).at(0).at(2)) ;\n      #format-complex(t_bases.at(a - 1).at(1).at(0)), #format-complex(t_bases.at(a - 1).at(1).at(1)), #format-complex(t_bases.at(a - 1).at(1).at(2)) ;\n      #format-complex(t_bases.at(a - 1).at(2).at(0)), #format-complex(t_bases.at(a - 1).at(2).at(1)), #format-complex(t_bases.at(a - 1).at(2).at(2))\n    ) mat(delim: \"[\",\n      #format-complex(t_bases.at(b - 1).at(0).at(0)), #format-complex(t_bases.at(b - 1).at(0).at(1)), #format-complex(t_bases.at(b - 1).at(0).at(2)) ;\n      #format-complex(t_bases.at(b - 1).at(1).at(0)), #format-complex(t_bases.at(b - 1).at(1).at(1)), #format-complex(t_bases.at(b - 1).at(1).at(2)) ;\n      #format-complex(t_bases.at(b - 1).at(2).at(0)), #format-complex(t_bases.at(b - 1).at(2).at(1)), #format-complex(t_bases.at(b - 1).at(2).at(2))\n    ) - mat(delim: \"[\",\n      #format-complex(t_bases.at(b - 1).at(0).at(0)), #format-complex(t_bases.at(b - 1).at(0).at(1)), #format-complex(t_bases.at(b - 1).at(0).at(2)) ;\n      #format-complex(t_bases.at(b - 1).at(1).at(0)), #format-complex(t_bases.at(b - 1).at(1).at(1)), #format-complex(t_bases.at(b - 1).at(1).at(2)) ;\n      #format-complex(t_bases.at(b - 1).at(2).at(0)), #format-complex(t_bases.at(b - 1).at(2).at(1)), #format-complex(t_bases.at(b - 1).at(2).at(2))\n    ) mat(delim: \"[\",\n      #format-complex(t_bases.at(a - 1).at(0).at(0)), #format-complex(t_bases.at(a - 1).at(0).at(1)), #format-complex(t_bases.at(a - 1).at(0).at(2)) ;\n      #format-complex(t_bases.at(a - 1).at(1).at(0)), #format-complex(t_bases.at(a - 1).at(1).at(1)), #format-complex(t_bases.at(a - 1).at(1).at(2)) ;\n      #format-complex(t_bases.at(a - 1).at(2).at(0)), #format-complex(t_bases.at(a - 1).at(2).at(1)), #format-complex(t_bases.at(a - 1).at(2).at(2))\n    )) = #format-alg(alg-mul(res.prefactor_a, res.prefactor_b)) mat(delim: \"[\",\n      #format-complex(res.commutator.at(0).at(0)), #format-complex(res.commutator.at(0).at(1)), #format-complex(res.commutator.at(0).at(2)) ;\n      #format-complex(res.commutator.at(1).at(0)), #format-complex(res.commutator.at(1).at(1)), #format-complex(res.commutator.at(1).at(2)) ;\n      #format-complex(res.commutator.at(2).at(0)), #format-complex(res.commutator.at(2).at(1)), #format-complex(res.commutator.at(2).at(2))\n    ) $\n    \n    *Step 2:* Multiply by $t_(#c)$ to get $[t_(#a), t_(#b)]t_(#c)$\n    \n    $ [t_(#a), t_(#b)]t_(#c) = #format-alg(res.prefactor_c) dot.c #format-alg(alg-mul(res.prefactor_a, res.prefactor_b)) mat(delim: \"[\",\n      #format-complex(res.commutator.at(0).at(0)), #format-complex(res.commutator.at(0).at(1)), #format-complex(res.commutator.at(0).at(2)) ;\n      #format-complex(res.commutator.at(1).at(0)), #format-complex(res.commutator.at(1).at(1)), #format-complex(res.commutator.at(1).at(2)) ;\n      #format-complex(res.commutator.at(2).at(0)), #format-complex(res.commutator.at(2).at(1)), #format-complex(res.commutator.at(2).at(2))\n    ) mat(delim: \"[\",\n      #format-complex(t_bases.at(c - 1).at(0).at(0)), #format-complex(t_bases.at(c - 1).at(0).at(1)), #format-complex(t_bases.at(c - 1).at(0).at(2)) ;\n      #format-complex(t_bases.at(c - 1).at(1).at(0)), #format-complex(t_bases.at(c - 1).at(1).at(1)), #format-complex(t_bases.at(c - 1).at(1).at(2)) ;\n      #format-complex(t_bases.at(c - 1).at(2).at(0)), #format-complex(t_bases.at(c - 1).at(2).at(1)), #format-complex(t_bases.at(c - 1).at(2).at(2))\n    ) = #format-alg(res.combined_prefactor) mat(delim: \"[\",\n      #format-complex(res.product.at(0).at(0)), #format-complex(res.product.at(0).at(1)), #format-complex(res.product.at(0).at(2)) ;\n      #format-complex(res.product.at(1).at(0)), #format-complex(res.product.at(1).at(1)), #format-complex(res.product.at(1).at(2)) ;\n      #format-complex(res.product.at(2).at(0)), #format-complex(res.product.at(2).at(1)), #format-complex(res.product.at(2).at(2))\n    ) $\n    \n    *Step 3:* Calculate the trace\n    \n    $ Tr([t_(#a), t_(#b)]t_(#c)) = #format-alg(res.combined_prefactor) dot.c Tr(mat(delim: \"[\",\n      #format-complex(res.product.at(0).at(0)), #format-complex(res.product.at(0).at(1)), #format-complex(res.product.at(0).at(2)) ;\n      #format-complex(res.product.at(1).at(0)), #format-complex(res.product.at(1).at(1)), #format-complex(res.product.at(1).at(2)) ;\n      #format-complex(res.product.at(2).at(0)), #format-complex(res.product.at(2).at(1)), #format-complex(res.product.at(2).at(2))\n    )) = #format-alg(res.combined_prefactor) dot.c #format-complex(res.trace) = #format-alg(res.trace_with_prefactor) $\n    \n    *Step 4:* Multiply by $-i/C_r$ to get the structure constant\n    \n    $ f^(#a #b #c) = -frac(i, C_r) dot.c #format-alg(res.trace_with_prefactor) = #format-alg(res.final_result) $\n  ]\n}\n\n// Calculate and display all structure constants where a != b != c\n#let display-all-distinct-constants() = [\n  = All SU(3) Structure Constants with Distinct Indices\n\n  #for a in range(1, 9) {\n    for b in range(1, 9) {\n      for c in range(1, 9) {\n        // Skip if any two indices are equal\n        if a != b and b != c and a != c {\n          display-calculation(a, b, c)\n          v(1em) // Add vertical space between calculations\n        }\n      }\n    }\n  }\n]\n\n// Add this to the end of your document\n#display-all-distinct-constants()\n</code></pre>\n<p>This works for any case where a != b != c, but as soon as one equality holds, some weird symbolic failures appear, and I cannot be bothered at this point getting something more robust working.</p>\n<p>At this point, beyond the symbolic issues, the one problem I have is that reducing fractions using the Euclidean algorithm is off the table, since I wasn’t sure how to handle fractions with radicals involved.</p>",
      "raw": "In case anyone is curious, this is what I eventually got working:\n\n```typ\n#let Tr = math.upright(\"Tr\")\n\n// ============ SYMBOLIC FRACTION IMPLEMENTATION ============\n\n// Basic symbolic fraction representation\n#let sym-frac(num, denom) = {\n  // Ensure we always have integer representations\n  if type(num) != int { num = calc.round(num) }\n  if type(denom) != int { denom = calc.round(denom) }\n  \n  // Handle special cases\n  if denom == 0 { panic(\"Division by zero\") }\n  if num == 0 { return (type: \"sym-frac\", num: 0, denom: 1, sign: 1) }\n  \n  // Normalize negative signs - always store them separately\n  let sign = 1\n  if (num < 0 and denom > 0) or (num > 0 and denom < 0) {\n    sign = -1 // Negative fraction\n  }\n  num = calc.abs(num)\n  denom = calc.abs(denom)\n  \n  // Create fraction with normalized sign\n  return (\n    type: \"sym-frac\",\n    num: num,     // Always positive\n    denom: denom, // Always positive\n    sign: sign    // -1 if fraction is negative, 1 if positive\n  )\n}\n\n// Fraction arithmetic operations\n#let frac-add(f1, f2) = {\n  if f1.type != \"sym-frac\" or f2.type != \"sym-frac\" {\n    panic(\"Expected symbolic fractions\")\n  }\n  \n  // a/b + c/d = (ad + bc)/bd\n  // With signs: (sign_a * a)/b + (sign_c * c)/d\n  let sign_a_val = if f1.sign < 0 { -f1.num } else { f1.num }\n  let sign_c_val = if f2.sign < 0 { -f2.num } else { f2.num }\n  \n  let num = sign_a_val * f2.denom + sign_c_val * f1.denom\n  let denom = f1.denom * f2.denom\n  \n  return sym-frac(num, denom)\n}\n\n#let frac-sub(f1, f2) = {\n  if f1.type != \"sym-frac\" or f2.type != \"sym-frac\" {\n    panic(\"Expected symbolic fractions\")\n  }\n  \n  // a/b - c/d = (ad - bc)/bd\n  // With signs: (sign_a * a)/b - (sign_c * c)/d\n  let sign_a_val = if f1.sign < 0 { -f1.num } else { f1.num }\n  let sign_c_val = if f2.sign < 0 { -f2.num } else { f2.num }\n  \n  let num = sign_a_val * f2.denom - sign_c_val * f1.denom\n  let denom = f1.denom * f2.denom\n  \n  return sym-frac(num, denom)\n}\n\n#let frac-mul(f1, f2) = {\n  if f1.type != \"sym-frac\" or f2.type != \"sym-frac\" {\n    panic(\"Expected symbolic fractions\")\n  }\n  \n  // (a/b) * (c/d) = (ac)/(bd)\n  // Sign: sign_a * sign_c\n  let num = f1.num * f2.num\n  let denom = f1.denom * f2.denom\n  let sign = f1.sign * f2.sign\n  \n  return (\n    type: \"sym-frac\",\n    num: num,\n    denom: denom,\n    sign: sign\n  )\n}\n\n#let frac-div(f1, f2) = {\n  if f1.type != \"sym-frac\" or f2.type != \"sym-frac\" {\n    panic(\"Expected symbolic fractions\")\n  }\n  \n  // (a/b) / (c/d) = (ad)/(bc)\n  // Sign: sign_a * sign_c\n  let num = f1.num * f2.denom\n  let denom = f1.denom * f2.num\n  let sign = f1.sign * f2.sign\n  \n  return (\n    type: \"sym-frac\",\n    num: num,\n    denom: denom,\n    sign: sign\n  )\n}\n\n#let frac-neg(f) = {\n  if f.type != \"sym-frac\" {\n    panic(\"Expected symbolic fraction\")\n  }\n  \n  // Negate the sign\n  return (\n    type: \"sym-frac\",\n    num: f.num,\n    denom: f.denom,\n    sign: -f.sign\n  )\n}\n\n#let frac-is-zero(f) = {\n  if f.type != \"sym-frac\" {\n    panic(\"Expected symbolic fraction\")\n  }\n  \n  return f.num == 0\n}\n\n#let frac-is-one(f) = {\n  if f.type != \"sym-frac\" {\n    panic(\"Expected symbolic fraction\")\n  }\n  \n  return f.num == f.denom and f.sign > 0\n}\n\n// Format a symbolic fraction\n#let format-frac(f) = {\n  if f.type != \"sym-frac\" {\n    panic(\"Expected symbolic fraction\")\n  }\n  \n  if f.denom == 1 {\n    if f.sign < 0 {\n      return [-#f.num]\n    } else {\n      return [#f.num]\n    }\n  } else {\n    let fraction = math.frac([#f.num], [#f.denom])\n    if f.sign < 0 {\n      return [-#fraction]\n    } else {\n      return fraction\n    }\n  }\n}\n\n// ============ ALGEBRAIC NUMBER SYSTEM ============\n\n// Clone a dictionary (since Typst dictionaries don't have a clone method)\n#let clone-dict(dict) = {\n  let result = (:)\n  for (key, value) in dict {\n    result.insert(key, value)\n  }\n  return result\n}\n\n// Represent an algebraic number with symbolic fractions for coefficients\n#let alg-num(\n  real-coef-num: 1, real-coef-denom: 1, real-factors: (:),\n  imag-coef-num: 0, imag-coef-denom: 1, imag-factors: (:)\n) = {\n  return (\n    type: \"algebraic\",\n    real: (\n      coef: sym-frac(real-coef-num, real-coef-denom),\n      factors: clone-dict(real-factors)\n    ),\n    imag: (\n      coef: sym-frac(imag-coef-num, imag-coef-denom),\n      factors: clone-dict(imag-factors)\n    )\n  )\n}\n\n// Convenience constructors\n#let alg-int(n) = alg-num(real-coef-num: n, real-coef-denom: 1)\n#let alg-i = alg-num(real-coef-num: 0, imag-coef-num: 1, imag-coef-denom: 1)\n\n// Create a proper fraction\n#let alg-frac(num, denom) = {\n  return alg-num(real-coef-num: num, real-coef-denom: denom)\n}\n\n// Create a square root\n#let alg-sqrt(n) = {\n  let factors = (:)\n  // Convert n to string if it's an integer\n  let base = if type(n) == int { str(n) } else { n }\n  factors.insert(base, decimal(\"0.5\"))\n  return alg-num(real-factors: factors)\n}\n\n// Create a reciprocal square root (1/√n)\n#let alg-rsqrt(n) = {\n  let factors = (:)\n  // Convert n to string if it's an integer\n  let base = if type(n) == int { str(n) } else { n }\n  factors.insert(base, decimal(\"-0.5\"))\n  return alg-num(real-factors: factors)\n}\n\n// Check if a decimal is approximately an integer\n#let is-integer(dec) = {\n  let int_value = calc.round(dec)\n  if type(dec) == decimal {\n    return calc.abs(dec - decimal(str(int_value))) < decimal(\"0.00001\")\n  } else {\n    return calc.abs(dec - int_value) < 0.00001\n  }\n}\n\n// Simplify one part (real or imaginary) of an algebraic number\n#let simplify-part(part) = {\n  let coef = part.coef\n  let factors = clone-dict(part.factors)\n  \n  // Handle zero coefficient\n  if frac-is-zero(coef) {\n    return (coef: sym-frac(0, 1), factors: (:))\n  }\n  \n  // Simplify factors with zero or integer exponents\n  let keys = factors.keys()\n  for base in keys {\n    let exp = factors.at(base)\n    \n    // Convert to decimal if not already\n    if type(exp) != decimal {\n      exp = decimal(str(exp))\n      factors.at(base) = exp\n    }\n    \n    // Remove factors with zero exponent\n    if exp == decimal(\"0\") {\n      factors.remove(base)\n    }\n  }\n  \n  return (coef: coef, factors: factors)\n}\n\n// Simplify an algebraic number\n#let simplify-alg(num) = {\n  if num.type != \"algebraic\" {\n    return alg-int(num)\n  }\n  \n  // Simplify both parts\n  let real-part = simplify-part(num.real)\n  let imag-part = simplify-part(num.imag)\n  \n  // Create the simplified number\n  return (\n    type: \"algebraic\",\n    real: real-part,\n    imag: imag-part\n  )\n}\n\n// Multiply a part (real or imaginary) by another part\n#let multiply-parts(a, b) = {\n  // If either coefficient is zero, result is zero\n  if frac-is-zero(a.coef) or frac-is-zero(b.coef) {\n    return (coef: sym-frac(0, 1), factors: (:))\n  }\n  \n  // Multiply coefficients\n  let coef = frac-mul(a.coef, b.coef)\n  \n  // Combine factors by adding exponents\n  let result_factors = clone-dict(a.factors)\n  for (base, exp) in b.factors {\n    if base in result_factors {\n      result_factors.at(base) = result_factors.at(base) + exp\n    } else {\n      result_factors.insert(base, exp)\n    }\n  }\n  \n  return (coef: coef, factors: result_factors)\n}\n\n// Multiply two algebraic numbers\n#let alg-mul(a, b) = {\n  if a.type != \"algebraic\" {\n    a = alg-int(a)\n  }\n  if b.type != \"algebraic\" {\n    b = alg-int(b)\n  }\n  \n  // (a + bi)(c + di) = (ac - bd) + (ad + bc)i\n  \n  // Real part: ac - bd\n  let real_ac = multiply-parts(a.real, b.real)\n  let real_bd = multiply-parts(a.imag, b.imag)\n  \n  // Imaginary part: ad + bc\n  let imag_ad = multiply-parts(a.real, b.imag)\n  let imag_bc = multiply-parts(a.imag, b.real)\n  \n  // For the real part, need to subtract bd from ac\n  let real_result\n  if frac-is-zero(real_bd.coef) {\n    // If bd is zero, real part is just ac\n    real_result = real_ac\n  } else if frac-is-zero(real_ac.coef) {\n    // If ac is zero, real part is -bd\n    real_result = (\n      coef: frac-neg(real_bd.coef),\n      factors: real_bd.factors\n    )\n  } else {\n    // Both non-zero, but we can only combine if they have identical factors\n    let factors_match = true\n    if real_ac.factors.keys().sorted() == real_bd.factors.keys().sorted() {\n      for (base, exp_ac) in real_ac.factors {\n        let exp_bd = real_bd.factors.at(base, default: none)\n        if exp_bd == none or exp_ac != exp_bd {\n          factors_match = false\n          break\n        }\n      }\n    } else {\n      factors_match = false\n    }\n    \n    if factors_match {\n      real_result = (\n        coef: frac-sub(real_ac.coef, real_bd.coef),\n        factors: real_ac.factors\n      )\n    } else {\n      // If we can't combine, just use ac for now\n      real_result = real_ac\n    }\n  }\n  \n  // For the imaginary part, need to add ad and bc\n  let imag_result\n  if frac-is-zero(imag_ad.coef) {\n    // If ad is zero, imaginary part is just bc\n    imag_result = imag_bc\n  } else if frac-is-zero(imag_bc.coef) {\n    // If bc is zero, imaginary part is just ad\n    imag_result = imag_ad\n  } else {\n    // Both non-zero, but we can only combine if they have identical factors\n    let factors_match = true\n    if imag_ad.factors.keys().sorted() == imag_bc.factors.keys().sorted() {\n      for (base, exp_ad) in imag_ad.factors {\n        let exp_bc = imag_bc.factors.at(base, default: none)\n        if exp_bc == none or exp_ad != exp_bc {\n          factors_match = false\n          break\n        }\n      }\n    } else {\n      factors_match = false\n    }\n    \n    if factors_match {\n      imag_result = (\n        coef: frac-add(imag_ad.coef, imag_bc.coef),\n        factors: imag_ad.factors\n      )\n    } else {\n      // If we can't combine, just use ad for now\n      imag_result = imag_ad\n    }\n  }\n\n  return simplify-alg((\n    type: \"algebraic\",\n    real: real_result,\n    imag: imag_result\n  ))\n}\n\n// Calculate the complex conjugate of an algebraic number\n#let alg-conjugate(a) = {\n  if a.type != \"algebraic\" {\n    a = alg-int(a)\n  }\n  \n  // Negate the imaginary part\n  return (\n    type: \"algebraic\",\n    real: a.real,\n    imag: (\n      coef: frac-neg(a.imag.coef),\n      factors: clone-dict(a.imag.factors)\n    )\n  )\n}\n\n// Divide two algebraic numbers using a/(b+ci) = a(b-ci)/(b²+c²)\n#let alg-div(a, b) = {\n  if a.type != \"algebraic\" {\n    a = alg-int(a)\n  }\n  if b.type != \"algebraic\" {\n    b = alg-int(b)\n  }\n  \n  // Special case: denominator is pure real\n  if frac-is-zero(b.imag.coef) {\n    // Create copies of a's factors\n    let real_factors = clone-dict(a.real.factors)\n    let imag_factors = clone-dict(a.imag.factors)\n    \n    // For each factor in the denominator, add it with negated exponent\n    for (base, exp) in b.real.factors {\n      if base in real_factors {\n        real_factors.at(base) = real_factors.at(base) - exp\n      } else {\n        real_factors.insert(base, -exp) // Add with negative exponent\n      }\n      \n      if base in imag_factors {\n        imag_factors.at(base) = imag_factors.at(base) - exp\n      } else {\n        imag_factors.insert(base, -exp) // Add with negative exponent\n      }\n    }\n    \n    return (\n      type: \"algebraic\",\n      real: (\n        coef: frac-div(a.real.coef, b.real.coef),\n        factors: real_factors  // Now contains correct combined factors\n      ),\n      imag: (\n        coef: frac-div(a.imag.coef, b.real.coef),\n        factors: imag_factors  // Now contains correct combined factors\n      )\n    )\n  }\n  \n  // For complex denominators, multiply by conjugate\n  // a/(b+ci) = a(b-ci)/((b+ci)(b-ci)) = a(b-ci)/(b²+c²)\n  let b_conj = alg-conjugate(b)\n  \n  // Multiply numerator by conjugate of denominator\n  let num = alg-mul(a, b_conj)\n  \n  // Calculate denominator: (b+ci)(b-ci) = b² + c²\n  let denom = alg-mul(b, b_conj)\n  \n  // Now denom should be real-only\n  if not frac-is-zero(denom.imag.coef) {\n    // This should not happen mathematically\n    return simplify-alg(num)\n  }\n  \n  // Divide by the real denominator\n  return alg-div(num, denom)\n}\n\n// Format an algebraic number for display\n#let format-alg(num) = {\n  if num.type != \"algebraic\" {\n    return str(num)\n  }\n  \n  num = simplify-alg(num)\n  \n  // Special case for zero\n  if frac-is-zero(num.real.coef) and frac-is-zero(num.imag.coef) {\n    return \"0\"\n  }\n  \n  // Function to format a single part (real or imaginary)\n  let format-part(part) = {\n    let coef = part.coef\n    let factors = part.factors\n    \n    // If coefficient is zero, return empty content\n    if frac-is-zero(coef) {\n      return []\n    }\n    \n    // Separate factors into positive and negative exponents\n    let pos_factors = (:)\n    let neg_factors = (:)\n    for (base, exp) in factors {\n      if exp > decimal(\"0\") {\n        pos_factors.insert(base, exp)\n      } else if exp < decimal(\"0\") {\n        neg_factors.insert(base, -exp) // Store positive value in neg_factors\n      }\n    }\n    \n    // Get the sign for the entire expression\n    let sign_content = []\n    if coef.sign < 0 {\n      sign_content = math.minus\n    }\n    \n    // Format the numerator (coefficient and positive exponent factors)\n    let num_content = []\n    \n    // Add coefficient absolute value if not 1 or if there are no positive factors\n    if coef.num != coef.denom or pos_factors.keys().len() == 0 {\n      if coef.num == coef.denom {\n        // Coefficient is 1, don't show it unless there are no factors\n        if pos_factors.keys().len() == 0 {\n          num_content = [1]\n        }\n      } else {\n        // Show the coefficient (always positive now)\n        num_content = [#coef.num]\n      }\n    }\n    \n    // Add positive exponent factors\n    let sorted_pos_factors = pos_factors.keys().sorted()\n    for base in sorted_pos_factors {\n      let exp = pos_factors.at(base)\n      if exp == decimal(\"0.5\") {\n        num_content = [#num_content #math.sqrt(base)]\n      } else if exp == decimal(\"1\") {\n        num_content = [#num_content #base]\n      } else {\n        num_content = [#num_content #base^(#exp)]\n      }\n    }\n    \n    // Check if we need a fraction\n    // If we have no negative factors and denominator is 1, no fraction needed\n    if neg_factors.keys().len() == 0 and coef.denom == 1 {\n      return [#sign_content #num_content]\n    }\n    \n    // Format the denominator (coefficient denominator and negative exponent factors)\n    let denom_content = []\n    \n    // Add coefficient denominator if not 1\n    if coef.denom != 1 {\n      denom_content = [#coef.denom]\n    }\n    \n    // Add negative exponent factors\n    let sorted_neg_factors = neg_factors.keys().sorted()\n    for base in sorted_neg_factors {\n      let exp = neg_factors.at(base)\n      if exp == decimal(\"0.5\") {\n        denom_content = [#denom_content #math.sqrt(base)]\n      } else if exp == decimal(\"1\") {\n        denom_content = [#denom_content #base]\n      } else {\n        denom_content = [#denom_content #base^(#exp)]\n      }\n    }\n    \n    // Return the fraction with sign outside\n    let fraction = math.frac([#num_content], [#denom_content])\n    return [#sign_content #fraction]\n  }\n  \n  // Format real and imaginary parts\n  let real_result = format-part(num.real)\n  let imag_result = format-part(num.imag)\n  \n  // If imaginary part has content, add 'i'\n  if not frac-is-zero(num.imag.coef) {\n    imag_result = [#imag_result i]\n  }\n  \n  // Combine real and imaginary parts\n  if frac-is-zero(num.real.coef) {\n    return imag_result\n  } else if frac-is-zero(num.imag.coef) {\n    return real_result\n  } else {\n    // Need + sign between real and imaginary parts (but only if imag is positive)\n    if num.imag.coef.sign > 0 {\n      return [#real_result + #imag_result]\n    } else {\n      // The minus sign is already included in imag_result\n      return [#real_result #imag_result]\n    }\n  }\n}\n\n// ============ COMPLEX NUMBER IMPLEMENTATION (FOR MATRICES) ============\n\n// Basic complex number operations (used for matrices)\n#let complex(a, b) = (a, b)\n#let complex-add(z1, z2) = (z1.at(0) + z2.at(0), z1.at(1) + z2.at(1))\n#let complex-sub(z1, z2) = (z1.at(0) - z2.at(0), z1.at(1) - z2.at(1))\n#let complex-mul(z1, z2) = (\n  z1.at(0) * z2.at(0) - z1.at(1) * z2.at(1),\n  z1.at(0) * z2.at(1) + z1.at(1) * z2.at(0)\n)\n#let complex-scale(z, s) = (z.at(0) * s, z.at(1) * s)\n\n// Convert complex to algebraic\n#let complex-to-alg(z) = {\n  let real = z.at(0)\n  let imag = z.at(1)\n  \n  return alg-num(\n    real-coef-num: real, real-coef-denom: 1,\n    imag-coef-num: imag, imag-coef-denom: 1\n  )\n}\n\n// Format a complex number for matrix display\n#let format-complex(z) = {\n  let real = z.at(0)\n  let imag = z.at(1)\n  \n  if imag == 0 {\n    return str(real)\n  } else if real == 0 {\n    if imag == 1 { return \"i\" }\n    else if imag == -1 { return \"-i\" }\n    else { return str(imag) + \"i\" }\n  } else {\n    let sign = if imag > 0 { \"+\" } else { \"-\" }\n    let abs-imag = calc.abs(imag)\n    if abs-imag == 1 {\n      return str(real) + sign + \"i\"\n    } else {\n      return str(real) + sign + str(abs-imag) + \"i\"\n    }\n  }\n}\n\n// ============ MATRIX OPERATIONS ============\n\n#let mat-add(A, B) = {\n  let rows = A.len()\n  let cols = A.at(0).len()\n  \n  let result = ()\n  for i in range(rows) {\n    let row = ()\n    for j in range(cols) {\n      row.push(complex-add(A.at(i).at(j), B.at(i).at(j)))\n    }\n    result.push(row)\n  }\n  \n  return result\n}\n\n#let mat-sub(A, B) = {\n  let rows = A.len()\n  let cols = A.at(0).len()\n  \n  let result = ()\n  for i in range(rows) {\n    let row = ()\n    for j in range(cols) {\n      row.push(complex-sub(A.at(i).at(j), B.at(i).at(j)))\n    }\n    result.push(row)\n  }\n  \n  return result\n}\n\n#let mat-mul(A, B) = {\n  let rows_A = A.len()\n  let cols_A = A.at(0).len()\n  let cols_B = B.at(0).len()\n  \n  let result = ()\n  for i in range(rows_A) {\n    let row = ()\n    for j in range(cols_B) {\n      let sum = complex(0, 0)\n      for k in range(cols_A) {\n        sum = complex-add(sum, complex-mul(A.at(i).at(k), B.at(k).at(j)))\n      }\n      row.push(sum)\n    }\n    result.push(row)\n  }\n  \n  return result\n}\n\n#let mat-commutator(A, B) = {\n  let AB = mat-mul(A, B)\n  let BA = mat-mul(B, A)\n  return mat-sub(AB, BA)\n}\n\n#let mat-trace(A) = {\n  let sum = complex(0, 0)\n  let n = A.len()\n  \n  for i in range(n) {\n    sum = complex-add(sum, A.at(i).at(i))\n  }\n  \n  return sum\n}\n\n// ============ GELL-MANN MATRICES ============\n\n// Define Gell-Mann matrices without prefactors\n#let t1_base = (\n  (complex(0, 0), complex(1, 0), complex(0, 0)),\n  (complex(1, 0), complex(0, 0), complex(0, 0)),\n  (complex(0, 0), complex(0, 0), complex(0, 0))\n)\n\n#let t2_base = (\n  (complex(0, 0), complex(0, -1), complex(0, 0)),\n  (complex(0, 1), complex(0, 0), complex(0, 0)),\n  (complex(0, 0), complex(0, 0), complex(0, 0))\n)\n\n#let t3_base = (\n  (complex(1, 0), complex(0, 0), complex(0, 0)),\n  (complex(0, 0), complex(-1, 0), complex(0, 0)),\n  (complex(0, 0), complex(0, 0), complex(0, 0))\n)\n\n#let t4_base = (\n  (complex(0, 0), complex(0, 0), complex(1, 0)),\n  (complex(0, 0), complex(0, 0), complex(0, 0)),\n  (complex(1, 0), complex(0, 0), complex(0, 0))\n)\n\n#let t5_base = (\n  (complex(0, 0), complex(0, 0), complex(0, -1)),\n  (complex(0, 0), complex(0, 0), complex(0, 0)),\n  (complex(0, 1), complex(0, 0), complex(0, 0))\n)\n\n#let t6_base = (\n  (complex(0, 0), complex(0, 0), complex(0, 0)),\n  (complex(0, 0), complex(0, 0), complex(1, 0)),\n  (complex(0, 0), complex(1, 0), complex(0, 0))\n)\n\n#let t7_base = (\n  (complex(0, 0), complex(0, 0), complex(0, 0)),\n  (complex(0, 0), complex(0, 0), complex(0, -1)),\n  (complex(0, 0), complex(0, 1), complex(0, 0))\n)\n\n#let t8_base = (\n  (complex(1, 0), complex(0, 0), complex(0, 0)),\n  (complex(0, 0), complex(1, 0), complex(0, 0)),\n  (complex(0, 0), complex(0, 0), complex(-2, 0))\n)\n\n// Create the algebraic prefactors with symbolic fractions\n#let half = alg-frac(1, 2)\n#let sqrt3 = alg-sqrt(3)\n#let half_sqrt3 = alg-div(half, sqrt3)\n\n// Define prefactors for each matrix\n#let prefactors = (\n  half,           // t1: 1/2\n  half,           // t2: 1/2\n  half,           // t3: 1/2\n  half,           // t4: 1/2\n  half,           // t5: 1/2\n  half,           // t6: 1/2\n  half,           // t7: 1/2\n  half_sqrt3      // t8: 1/(2√3)\n)\n\n// Scaled versions of the matrices for display\n#let t_bases = (t1_base, t2_base, t3_base, t4_base, t5_base, t6_base, t7_base, t8_base)\n\n// ============ STRUCTURE CONSTANT CALCULATION ============\n\n// Debug function to examine the structure of an algebraic number\n#let debug-alg(num) = {\n  if num.type != \"algebraic\" {\n    return \"not an algebraic number: \" + str(num)\n  }\n  \n  let real_coef = \"{ num: \" + str(num.real.coef.num) + \", denom: \" + str(num.real.coef.denom) + \" }\"\n  let imag_coef = \"{ num: \" + str(num.imag.coef.num) + \", denom: \" + str(num.imag.coef.denom) + \" }\"\n  \n  let result = \"algebraic: {\\n\"\n  result += \"  real: { coef: \" + real_coef + \", factors: \" + str(num.real.factors) + \" }\\n\"\n  result += \"  imag: { coef: \" + imag_coef + \", factors: \" + str(num.imag.factors) + \" }\\n\"\n  result += \"}\"\n  \n  return result\n}\n\n// Create the structure constants calculation function\n#let calculate-f(a, b, c, Cr) = {\n  let a_idx = a - 1\n  let b_idx = b - 1\n  let c_idx = c - 1\n  \n  // Calculate using base matrices (without prefactors)\n  let comm = mat-commutator(t_bases.at(a_idx), t_bases.at(b_idx))\n  let prod = mat-mul(comm, t_bases.at(c_idx))\n  let tr = mat-trace(prod)\n  \n  // Get prefactors for each matrix\n  let pa = prefactors.at(a_idx)\n  let pb = prefactors.at(b_idx)\n  let pc = prefactors.at(c_idx)\n  \n  // Combined prefactor (pa * pb * pc)\n  let combined_prefactor = alg-mul(pa, alg-mul(pb, pc))\n  \n  // Convert trace to algebraic number\n  let trace_alg = complex-to-alg(tr)\n  \n  // Structure constant formula: f^abc = -i/Cr * Tr([t_a, t_b] t_c) * combined_prefactor\n  let i_factor = alg-div(alg-mul(alg-int(-1), alg-i), alg-int(Cr))\n  \n  // Calculate each intermediate result for debugging\n  let trace_with_prefactor = alg-mul(trace_alg, combined_prefactor)\n  \n  // Final result with everything multiplied\n  let final_result = alg-mul(i_factor, trace_with_prefactor)\n  \n  return (\n    commutator: comm,\n    product: prod,\n    trace: tr,\n    trace_alg: trace_alg,\n    prefactor_a: pa,\n    prefactor_b: pb,\n    prefactor_c: pc,\n    combined_prefactor: combined_prefactor,\n    i_factor: i_factor,\n    trace_with_prefactor: trace_with_prefactor,\n    final_result: final_result\n  )\n}\n\n#let Cr = 1 // Normalization constant\n\n// ============ DISPLAY CALCULATIONS ============\n\n#let display-calculation(a, b, c) = {\n  let res = calculate-f(a, b, c, Cr)\n  \n  [\n    == Structure Constant $f^(#a #b #c)$\n    \n    *Step 1:* Calculate the commutator $[t_(#a), t_(#b)]$\n    \n    $ [t_(#a), t_(#b)] = #format-alg(res.prefactor_a) dot.c #format-alg(res.prefactor_b) (mat(delim: \"[\",\n      #format-complex(t_bases.at(a - 1).at(0).at(0)), #format-complex(t_bases.at(a - 1).at(0).at(1)), #format-complex(t_bases.at(a - 1).at(0).at(2)) ;\n      #format-complex(t_bases.at(a - 1).at(1).at(0)), #format-complex(t_bases.at(a - 1).at(1).at(1)), #format-complex(t_bases.at(a - 1).at(1).at(2)) ;\n      #format-complex(t_bases.at(a - 1).at(2).at(0)), #format-complex(t_bases.at(a - 1).at(2).at(1)), #format-complex(t_bases.at(a - 1).at(2).at(2))\n    ) mat(delim: \"[\",\n      #format-complex(t_bases.at(b - 1).at(0).at(0)), #format-complex(t_bases.at(b - 1).at(0).at(1)), #format-complex(t_bases.at(b - 1).at(0).at(2)) ;\n      #format-complex(t_bases.at(b - 1).at(1).at(0)), #format-complex(t_bases.at(b - 1).at(1).at(1)), #format-complex(t_bases.at(b - 1).at(1).at(2)) ;\n      #format-complex(t_bases.at(b - 1).at(2).at(0)), #format-complex(t_bases.at(b - 1).at(2).at(1)), #format-complex(t_bases.at(b - 1).at(2).at(2))\n    ) - mat(delim: \"[\",\n      #format-complex(t_bases.at(b - 1).at(0).at(0)), #format-complex(t_bases.at(b - 1).at(0).at(1)), #format-complex(t_bases.at(b - 1).at(0).at(2)) ;\n      #format-complex(t_bases.at(b - 1).at(1).at(0)), #format-complex(t_bases.at(b - 1).at(1).at(1)), #format-complex(t_bases.at(b - 1).at(1).at(2)) ;\n      #format-complex(t_bases.at(b - 1).at(2).at(0)), #format-complex(t_bases.at(b - 1).at(2).at(1)), #format-complex(t_bases.at(b - 1).at(2).at(2))\n    ) mat(delim: \"[\",\n      #format-complex(t_bases.at(a - 1).at(0).at(0)), #format-complex(t_bases.at(a - 1).at(0).at(1)), #format-complex(t_bases.at(a - 1).at(0).at(2)) ;\n      #format-complex(t_bases.at(a - 1).at(1).at(0)), #format-complex(t_bases.at(a - 1).at(1).at(1)), #format-complex(t_bases.at(a - 1).at(1).at(2)) ;\n      #format-complex(t_bases.at(a - 1).at(2).at(0)), #format-complex(t_bases.at(a - 1).at(2).at(1)), #format-complex(t_bases.at(a - 1).at(2).at(2))\n    )) = #format-alg(alg-mul(res.prefactor_a, res.prefactor_b)) mat(delim: \"[\",\n      #format-complex(res.commutator.at(0).at(0)), #format-complex(res.commutator.at(0).at(1)), #format-complex(res.commutator.at(0).at(2)) ;\n      #format-complex(res.commutator.at(1).at(0)), #format-complex(res.commutator.at(1).at(1)), #format-complex(res.commutator.at(1).at(2)) ;\n      #format-complex(res.commutator.at(2).at(0)), #format-complex(res.commutator.at(2).at(1)), #format-complex(res.commutator.at(2).at(2))\n    ) $\n    \n    *Step 2:* Multiply by $t_(#c)$ to get $[t_(#a), t_(#b)]t_(#c)$\n    \n    $ [t_(#a), t_(#b)]t_(#c) = #format-alg(res.prefactor_c) dot.c #format-alg(alg-mul(res.prefactor_a, res.prefactor_b)) mat(delim: \"[\",\n      #format-complex(res.commutator.at(0).at(0)), #format-complex(res.commutator.at(0).at(1)), #format-complex(res.commutator.at(0).at(2)) ;\n      #format-complex(res.commutator.at(1).at(0)), #format-complex(res.commutator.at(1).at(1)), #format-complex(res.commutator.at(1).at(2)) ;\n      #format-complex(res.commutator.at(2).at(0)), #format-complex(res.commutator.at(2).at(1)), #format-complex(res.commutator.at(2).at(2))\n    ) mat(delim: \"[\",\n      #format-complex(t_bases.at(c - 1).at(0).at(0)), #format-complex(t_bases.at(c - 1).at(0).at(1)), #format-complex(t_bases.at(c - 1).at(0).at(2)) ;\n      #format-complex(t_bases.at(c - 1).at(1).at(0)), #format-complex(t_bases.at(c - 1).at(1).at(1)), #format-complex(t_bases.at(c - 1).at(1).at(2)) ;\n      #format-complex(t_bases.at(c - 1).at(2).at(0)), #format-complex(t_bases.at(c - 1).at(2).at(1)), #format-complex(t_bases.at(c - 1).at(2).at(2))\n    ) = #format-alg(res.combined_prefactor) mat(delim: \"[\",\n      #format-complex(res.product.at(0).at(0)), #format-complex(res.product.at(0).at(1)), #format-complex(res.product.at(0).at(2)) ;\n      #format-complex(res.product.at(1).at(0)), #format-complex(res.product.at(1).at(1)), #format-complex(res.product.at(1).at(2)) ;\n      #format-complex(res.product.at(2).at(0)), #format-complex(res.product.at(2).at(1)), #format-complex(res.product.at(2).at(2))\n    ) $\n    \n    *Step 3:* Calculate the trace\n    \n    $ Tr([t_(#a), t_(#b)]t_(#c)) = #format-alg(res.combined_prefactor) dot.c Tr(mat(delim: \"[\",\n      #format-complex(res.product.at(0).at(0)), #format-complex(res.product.at(0).at(1)), #format-complex(res.product.at(0).at(2)) ;\n      #format-complex(res.product.at(1).at(0)), #format-complex(res.product.at(1).at(1)), #format-complex(res.product.at(1).at(2)) ;\n      #format-complex(res.product.at(2).at(0)), #format-complex(res.product.at(2).at(1)), #format-complex(res.product.at(2).at(2))\n    )) = #format-alg(res.combined_prefactor) dot.c #format-complex(res.trace) = #format-alg(res.trace_with_prefactor) $\n    \n    *Step 4:* Multiply by $-i/C_r$ to get the structure constant\n    \n    $ f^(#a #b #c) = -frac(i, C_r) dot.c #format-alg(res.trace_with_prefactor) = #format-alg(res.final_result) $\n  ]\n}\n\n// Calculate and display all structure constants where a != b != c\n#let display-all-distinct-constants() = [\n  = All SU(3) Structure Constants with Distinct Indices\n\n  #for a in range(1, 9) {\n    for b in range(1, 9) {\n      for c in range(1, 9) {\n        // Skip if any two indices are equal\n        if a != b and b != c and a != c {\n          display-calculation(a, b, c)\n          v(1em) // Add vertical space between calculations\n        }\n      }\n    }\n  }\n]\n\n// Add this to the end of your document\n#display-all-distinct-constants()\n```\nThis works for any case where a != b != c, but as soon as one equality holds, some weird symbolic failures appear, and I cannot be bothered at this point getting something more robust working.\n\nAt this point, beyond the symbolic issues, the one problem I have is that reducing fractions using the Euclidean algorithm is off the table, since I wasn't sure how to handle fractions with radicals involved.",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 20,
      "score": 4.0,
      "accepted_answer": false,
      "trust_level": 1,
      "user_id": 788
    }
  ],
  "scraped_at": "2025-06-10T09:48:58.466863"
}