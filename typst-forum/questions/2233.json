{
  "topic_metadata": {
    "id": 2233,
    "title": "Is there a way to convert content to bytes for use in plugins?",
    "slug": "is-there-a-way-to-convert-content-to-bytes-for-use-in-plugins",
    "posts_count": 4,
    "created_at": "2024-12-28T23:55:53.944Z",
    "last_posted_at": "2024-12-31T00:31:24.720Z",
    "views": 128,
    "like_count": 2,
    "reply_count": 0,
    "has_accepted_answer": true,
    "accepted_answer_post_number": 2,
    "accepted_answer_username": "SillyFreak",
    "tags": [
      "scripting"
    ],
    "category_id": 5,
    "participant_count": 2,
    "word_count": 927
  },
  "posts": [
    {
      "id": 7021,
      "post_number": 1,
      "username": "frisbro",
      "name": "",
      "created_at": "2024-12-28T23:55:54.074Z",
      "updated_at": "2024-12-29T10:13:08.317Z",
      "cooked": "<p>Hi all,</p>\n<p>It would be nice to have the option to convert content to bytes using bytes(…). This would be useful when developing plugins. For instance, if one develops a plugin using Rust, I imagine that one could use the Typst libarary and then deserialize the bytes. It would open up a lot of possibilities for future plugins.</p>\n<p>For now, is there a better way to convert content to a string than using repr(…)?</p>\n<p>Best regards, F</p>",
      "raw": "Hi all,\n\nIt would be nice to have the option to convert content to bytes using bytes(...). This would be useful when developing plugins. For instance, if one develops a plugin using Rust, I imagine that one could use the Typst libarary and then deserialize the bytes. It would open up a lot of possibilities for future plugins. \n\nFor now, is there a better way to convert content to a string than using repr(...)?\n\nBest regards, F",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 38,
      "score": 217.6,
      "accepted_answer": false,
      "trust_level": 1,
      "user_id": 986
    },
    {
      "id": 7024,
      "post_number": 2,
      "username": "SillyFreak",
      "name": "SillyFreak",
      "created_at": "2024-12-29T10:08:14.658Z",
      "updated_at": "2024-12-31T09:20:41.663Z",
      "cooked": "<p>There is no built-in way, but it’s not too hard to build one yourself (with limitations). There’s been this post on handling content, which I think is at least somewhat relevant:</p>\n<aside class=\"quote quote-modified\" data-post=\"1\" data-topic=\"1099\">\n  <div class=\"title\">\n    <div class=\"quote-controls\"></div>\n    <img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/letter_avatar_proxy/v4/letter/s/5C0B42/48.png\" class=\"avatar\">\n    <a href=\"https://forum.typst.app/t/how-can-i-manipulate-content-values/1099\">How can I manipulate content values?</a> <a class=\"badge-category__wrapper \" href=\"/c/questions/5\"><span data-category-id=\"5\" style=\"--category-badge-color: #F7C000; --category-badge-text-color: #fdfdfd;\" data-drop-close=\"true\" class=\"badge-category \" title=\"Your questions about using Typst and the web app go in this category.\"><span class=\"badge-category__name\">Questions</span></span></a>\n  </div>\n  <blockquote>\n    Currently, manipulating content is very involved. This is mainly caused by the content functions \n\ntaking different amount of positional arguments\nfields() not distinguishing between positional and keyword arguments\nnot all content functions being accessible (e.g. sequence can as far as I know only obtained by hacks like [].func())\n\nFor example, I’d like to recursively update all strings in a content, which currently requires a lot of special casing and hard to know if you caught all edge cases.…\n  </blockquote>\n</aside>\n\n<p>A main takeaway here is that, whenever you can, you should strive to <em>not</em> have content as the basis of your computation. Use structured data as long as possible and then format it.</p>\n<p>In your case, you want to specifically create bytes to communicate arbitrary content to a plugin. The approach will be similar to what is presented in that post, and is based on <a href=\"https://sitandr.github.io/typst-examples-book/book/typstonomicon/extract_plain_text.html\" class=\"inline-onebox\">Extracting plain text - Typst Examples Book</a> (which is in the section “Typstonomicon, or The Code You Should Not Write” – be warned!)</p>\n<p>You don’t actually need to go all the way to bytes, since once you have converted content into plain data, you can just use <a href=\"https://typst.app/docs/reference/data-loading/cbor/\">CBOR</a>. To convert content into a data structure (I’m calling it AST because it at least resembles an abstract syntax tree and naming is hard) you can recursively go through content:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let content-to-ast(it) = {\n  // function (as string representation) and fields is what makes some content\n  let func = repr(it.func())\n  let fields = it.fields()\n\n  // children (for content containing many things)\n  // and body (for stuff containing a single thing)\n  // are the ones we need to recursively transform\n  if \"children\" in fields {\n    fields.children = fields.children.map(content-to-ast)\n  } else if \"body\" in fields {\n    fields.body = content-to-ast(fields.body)\n  }\n\n  // return a dictionary, which should no longer contain content\n  (function: func, ..fields)\n}\n\n#let ast-to-content(it) = {\n  // separate function and fields\n  let (function: func, ..fields) = it\n\n  // recursively un-transform\n  if \"children\" in fields {\n    fields.children = fields.children.map(ast-to-content)\n  } else if \"body\" in fields {\n    fields.body = ast-to-content(fields.body)\n  }\n\n  // convert to content according to the function\n  // TODO other types\n  if func == \"sequence\" {\n    fields.children.join()\n  } else if func == \"linebreak\" {\n    linebreak()\n  } else if func == \"space\" {\n    [ ]\n  } else if func == \"text\" {\n    [#fields.text]\n  } else if func == \"box\" {\n    let (body, ..fields) = fields\n    box(body, ..fields)\n  } else if func == \"smartquote\" {\n    smartquote(..fields)\n  }\n}\n</code></pre>\n<p>and you can now translate content to bytes and back — at least the few things I chose to support here:</p>\n<details>\n<summary>\nExample</summary>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let example = [Hello\\ #box[\"World\"]]\n// serialize\n#let example-ast = content-to-ast(example)\n#let example-bytes = cbor.encode(example-ast)\n// deserialize\n#let example-ast = cbor.decode(example-bytes)\n#let example-roundtrip = ast-to-content(example-ast)\n\n#table(\n  columns: 2,\n  [\n    #example\n    \n    #repr(example)\n  ],\n  [\n    #example-roundtrip\n    \n    #repr(example-roundtrip)\n  ],\n)\n</code></pre>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://forum.typst.app/uploads/default/original/2X/9/979798b664d247d68300457c26fce4c07679a2d0.png\" data-download-href=\"https://forum.typst.app/uploads/default/979798b664d247d68300457c26fce4c07679a2d0\" title=\"image\"><img src=\"https://forum.typst.app/uploads/default/optimized/2X/9/979798b664d247d68300457c26fce4c07679a2d0_2_489x375.png\" alt=\"image\" data-base62-sha1=\"lD2TjhhwYmqJ9hAai96umtXPl6g\" width=\"489\" height=\"375\" srcset=\"https://forum.typst.app/uploads/default/optimized/2X/9/979798b664d247d68300457c26fce4c07679a2d0_2_489x375.png, https://forum.typst.app/uploads/default/original/2X/9/979798b664d247d68300457c26fce4c07679a2d0.png 1.5x, https://forum.typst.app/uploads/default/original/2X/9/979798b664d247d68300457c26fce4c07679a2d0.png 2x\" data-dominant-color=\"F3F3F3\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">image</span><span class=\"informations\">668×512 55.8 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n</details>\n<hr>\n<p><strong>However…</strong></p>\n<p>Of course it would be nice if things were that easy, but in general they are not:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let example2 = {\n  set text(1em)\n  [Hello]\n}\n\n#repr(example2)\n// styled(child: [Hello], ..)\n#example2.styles\n// ..\n</code></pre>\n<p>The <code>styled</code> element (for example) which is generated by using rules contains a <code>styles</code> field, which is opaque, so we can’t convert it. I’m not an expert on Typst intrinsics, but I’m pretty sure there is simply no way these elements could be represented that doesn’t rely on also referencing some part of Typst’s Rust runtime – we’re simply out of luck. Even if we could represent set rules, a show rule can can contain user-written Typst code, so we’d need to convert <em>any kind of Typst code</em> into a plain Typst value.</p>\n<hr>\n<p>So to recap:</p>\n<ul>\n<li>Regular content (the kind of content you could also write in e.g. Markdown or HTML (excluding CSS)) can be recursively converted into Typst dictionaries.</li>\n<li>This is necessarily limited and lossy, which is why the basic technique is part of the Typstonomicon.</li>\n<li>You should generally prefer to work on structured data, and only convert that to content after everything is done.</li>\n<li>Nonetheless, I think this (ideally coupled with a Rust library that handles the other side of the conversion) could be fairly useful in general. In <a href=\"https://forum.typst.app/t/parsing-dsls-with-a-wasm-plugin-using-rust-lalrpop/1376\">one of my showcases</a> I used Serde to convert Rust structs and enums to Typst values, so that they can be formatted on the Typst side. This would be very similar, except that the values passed <em>to</em> Rust wouldn’t be strings to parse, but already prepared data that can simly be deserialized.</li>\n</ul>",
      "raw": "There is no built-in way, but it's not too hard to build one yourself (with limitations). There's been this post on handling content, which I think is at least somewhat relevant:\n\nhttps://forum.typst.app/t/how-can-i-manipulate-content-values/1099?u=sillyfreak\n\nA main takeaway here is that, whenever you can, you should strive to _not_ have content as the basis of your computation. Use structured data as long as possible and then format it.\n\nIn your case, you want to specifically create bytes to communicate arbitrary content to a plugin. The approach will be similar to what is presented in that post, and is based on https://sitandr.github.io/typst-examples-book/book/typstonomicon/extract_plain_text.html (which is in the section \"Typstonomicon, or The Code You Should Not Write\" -- be warned!)\n\nYou don't actually need to go all the way to bytes, since once you have converted content into plain data, you can just use [CBOR](https://typst.app/docs/reference/data-loading/cbor/). To convert content into a data structure (I'm calling it AST because it at least resembles an abstract syntax tree and naming is hard) you can recursively go through content:\n\n```typ\n#let content-to-ast(it) = {\n  // function (as string representation) and fields is what makes some content\n  let func = repr(it.func())\n  let fields = it.fields()\n\n  // children (for content containing many things)\n  // and body (for stuff containing a single thing)\n  // are the ones we need to recursively transform\n  if \"children\" in fields {\n    fields.children = fields.children.map(content-to-ast)\n  } else if \"body\" in fields {\n    fields.body = content-to-ast(fields.body)\n  }\n\n  // return a dictionary, which should no longer contain content\n  (function: func, ..fields)\n}\n\n#let ast-to-content(it) = {\n  // separate function and fields\n  let (function: func, ..fields) = it\n\n  // recursively un-transform\n  if \"children\" in fields {\n    fields.children = fields.children.map(ast-to-content)\n  } else if \"body\" in fields {\n    fields.body = ast-to-content(fields.body)\n  }\n\n  // convert to content according to the function\n  // TODO other types\n  if func == \"sequence\" {\n    fields.children.join()\n  } else if func == \"linebreak\" {\n    linebreak()\n  } else if func == \"space\" {\n    [ ]\n  } else if func == \"text\" {\n    [#fields.text]\n  } else if func == \"box\" {\n    let (body, ..fields) = fields\n    box(body, ..fields)\n  } else if func == \"smartquote\" {\n    smartquote(..fields)\n  }\n}\n```\n\nand you can now translate content to bytes and back --- at least the few things I chose to support here:\n\n[details=\"Example\"]\n```typ\n#let example = [Hello\\ #box[\"World\"]]\n// serialize\n#let example-ast = content-to-ast(example)\n#let example-bytes = cbor.encode(example-ast)\n// deserialize\n#let example-ast = cbor.decode(example-bytes)\n#let example-roundtrip = ast-to-content(example-ast)\n\n#table(\n  columns: 2,\n  [\n    #example\n    \n    #repr(example)\n  ],\n  [\n    #example-roundtrip\n    \n    #repr(example-roundtrip)\n  ],\n)\n```\n![image|652x500, 75%](upload://lD2TjhhwYmqJ9hAai96umtXPl6g.png)\n[/details]\n\n----\n\n**However...**\n\nOf course it would be nice if things were that easy, but in general they are not:\n\n```typ\n#let example2 = {\n  set text(1em)\n  [Hello]\n}\n\n#repr(example2)\n// styled(child: [Hello], ..)\n#example2.styles\n// ..\n```\n\nThe `styled` element (for example) which is generated by using rules contains a `styles` field, which is opaque, so we can't convert it. I'm not an expert on Typst intrinsics, but I'm pretty sure there is simply no way these elements could be represented that doesn't rely on also referencing some part of Typst's Rust runtime -- we're simply out of luck. Even if we could represent set rules, a show rule can can contain user-written Typst code, so we'd need to convert _any kind of Typst code_ into a plain Typst value.\n\n---\n\nSo to recap:\n- Regular content (the kind of content you could also write in e.g. Markdown or HTML (excluding CSS)) can be recursively converted into Typst dictionaries.\n- This is necessarily limited and lossy, which is why the basic technique is part of the Typstonomicon.\n- You should generally prefer to work on structured data, and only convert that to content after everything is done.\n- Nonetheless, I think this (ideally coupled with a Rust library that handles the other side of the conversion) could be fairly useful in general. In [one of my showcases](https://forum.typst.app/t/parsing-dsls-with-a-wasm-plugin-using-rust-lalrpop/1376?u=sillyfreak) I used Serde to convert Rust structs and enums to Typst values, so that they can be formatted on the Typst side. This would be very similar, except that the values passed _to_ Rust wouldn't be strings to parse, but already prepared data that can simly be deserialized.",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 1,
      "reads": 35,
      "score": 82.0,
      "accepted_answer": true,
      "trust_level": 3,
      "user_id": 32
    },
    {
      "id": 7025,
      "post_number": 3,
      "username": "SillyFreak",
      "name": "SillyFreak",
      "created_at": "2024-12-29T10:12:07.992Z",
      "updated_at": "2024-12-29T10:12:07.992Z",
      "cooked": "<p>btw <a class=\"mention\" href=\"/u/frisbro\">@frisbro</a>, I will move this post to <a class=\"hashtag-cooked\" href=\"/c/questions/5\" data-type=\"category\" data-slug=\"questions\" data-id=\"5\"><span class=\"hashtag-icon-placeholder\"><svg class=\"fa d-icon d-icon-square-full svg-icon svg-node\"><use href=\"#square-full\"></use></svg></span><span>Questions</span></a> (and give it tags and <a href=\"https://forum.typst.app/t/how-to-post-in-the-questions-category/11\">a title that is a question you’d ask a friend</a>). I know you wrote about Typst providing this and only asking for a workaround as a last resort, but for the limitations I described and because stabilizing a more complex Plugin protocol is very unlikely in the near future, I think it’s more likely that we handle this in userspace for the time being.</p>",
      "raw": "btw @frisbro, I will move this post to #questions (and give it tags and [a title that is a question you’d ask a friend](https://forum.typst.app/t/how-to-post-in-the-questions-category/11)). I know you wrote about Typst providing this and only asking for a workaround as a last resort, but for the limitations I described and because stabilizing a more complex Plugin protocol is very unlikely in the near future, I think it's more likely that we handle this in userspace for the time being.",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 1,
      "reads": 30,
      "score": 31.0,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 32
    },
    {
      "id": 7081,
      "post_number": 4,
      "username": "frisbro",
      "name": "",
      "created_at": "2024-12-31T00:31:24.720Z",
      "updated_at": "2024-12-31T00:31:24.720Z",
      "cooked": "<p>Thank-you very much for the detailed reply. This helped me enormously.</p>",
      "raw": "Thank-you very much for the detailed reply. This helped me enormously.",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 22,
      "score": 9.4,
      "accepted_answer": false,
      "trust_level": 1,
      "user_id": 986
    }
  ],
  "scraped_at": "2025-06-10T09:53:22.738946"
}