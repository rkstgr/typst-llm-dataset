{
  "topic_metadata": {
    "id": 3281,
    "title": "How can I create an \"actions\" function and table of actions?",
    "slug": "how-can-i-create-an-actions-function-and-table-of-actions",
    "posts_count": 5,
    "created_at": "2025-03-16T10:25:24.971Z",
    "last_posted_at": "2025-04-14T18:03:10.385Z",
    "views": 85,
    "like_count": 2,
    "reply_count": 1,
    "has_accepted_answer": true,
    "accepted_answer_post_number": 2,
    "accepted_answer_username": "Adrian_Weitkemper",
    "tags": [
      "scripting",
      "outline"
    ],
    "category_id": 5,
    "participant_count": 3,
    "word_count": 1090
  },
  "posts": [
    {
      "id": 9856,
      "post_number": 1,
      "username": "Beno",
      "name": "",
      "created_at": "2025-03-16T10:25:25.234Z",
      "updated_at": "2025-04-14T17:47:04.659Z",
      "cooked": "<p>I’m trying to create a function to be mark inline actions in a run of text which indicate the assignee in a margin note (via the drafting module) and then add them to a global dictionary to be able to render a table later at the end of the document.</p>\n<p>This was my attempt:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">// Create a dictionary to store actions for each assignee.  \n// The key will be the assignee and the value will be array of actions\n// Due to scoping constraints, use the \"state\" function\n#let actions = state(\"actions\", (\"\": ()))\n\n// Define a helper function to add an action to the global dictionary\n#let _add_action(assignee, action) = {\n  let actions_for_assignee = actions.at(assignee, ())\n  actions_for_assignee.append(action)\n  actions.update(assignee, actions_for_assignee)\n}\n\n// Define an action for use in the body text\n#let action(body, assignee: \"\", side: left) = {\n    // Add action to the global state to be able to render a table later\n    _add_action(assignee, body)\n    // Display the action text inline as usual\n    body\n    // Mark the presence of an action in a sidenote with the assignee\n    margin-note(side: side)[#strong(\"Action:\") #assignee]\n}\n\nHere's an example of text with an #action(assignee: \"Ben\")[action for Ben to do].\n</code></pre>\n<p>This won’t compile, complaining at line</p>\n<pre data-code-wrap=\"typc\"><code class=\"lang-typc\">  let actions_for_assignee = actions.at(assignee, ())\n</code></pre>\n<p>“text is not locatable”</p>\n<p>I suspect I’m misunderstanding how dictionaries and/or state variables should working.  Any suggestions would be very welcome!</p>",
      "raw": "I'm trying to create a function to be mark inline actions in a run of text which indicate the assignee in a margin note (via the drafting module) and then add them to a global dictionary to be able to render a table later at the end of the document.\n\nThis was my attempt:\n\n```typ\n// Create a dictionary to store actions for each assignee.  \n// The key will be the assignee and the value will be array of actions\n// Due to scoping constraints, use the \"state\" function\n#let actions = state(\"actions\", (\"\": ()))\n\n// Define a helper function to add an action to the global dictionary\n#let _add_action(assignee, action) = {\n  let actions_for_assignee = actions.at(assignee, ())\n  actions_for_assignee.append(action)\n  actions.update(assignee, actions_for_assignee)\n}\n\n// Define an action for use in the body text\n#let action(body, assignee: \"\", side: left) = {\n    // Add action to the global state to be able to render a table later\n    _add_action(assignee, body)\n    // Display the action text inline as usual\n    body\n    // Mark the presence of an action in a sidenote with the assignee\n    margin-note(side: side)[#strong(\"Action:\") #assignee]\n}\n\nHere's an example of text with an #action(assignee: \"Ben\")[action for Ben to do].\n```\n\nThis won't compile, complaining at line\n```typc\n  let actions_for_assignee = actions.at(assignee, ())\n```\n\"text is not locatable\"\n\nI suspect I'm misunderstanding how dictionaries and/or state variables should working.  Any suggestions would be very welcome!",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 26,
      "score": 80.2,
      "accepted_answer": false,
      "trust_level": 1,
      "user_id": 1355
    },
    {
      "id": 9866,
      "post_number": 2,
      "username": "Adrian_Weitkemper",
      "name": "Adron",
      "created_at": "2025-03-16T12:34:35.471Z",
      "updated_at": "2025-03-21T08:45:11.312Z",
      "cooked": "<p>Hi there! Welcome to the Forum.<br>\nThe actions.at() doesn’t work, because it references the at method of the state element itself, not the dictionary (see the <a href=\"https://typst.app/docs/reference/introspection/state#time-travel\">typst doc</a>). The at function of the state expects a location in the document or something like that (label etc.), so that’s what the error is about. Here is:</p>\n<pre data-code-wrap=\"typst\"><code class=\"lang-typst\">// Create a dictionary to store actions for each assignee.  \n// The key will be the assignee and the value will be array of actions\n// Due to scoping constraints, use the \"state\" function\n#let actions = state(\"actions\", (:))\n\n// Define a helper function to add an action to the global dictionary\n#let _add_action(actions, assignee, action) = {\n  if not assignee in actions {\n    actions.insert(assignee, (action,))\n  }\n  else {\n  actions.at(assignee).push(action)\n  }\n  return actions\n}\n\n// Define an action for use in the body text\n#let action(body, assignee: \"\", side: left) = {\n    // Add action to the global state to be able to render a table later\n    actions.update(x =&gt; _add_action(x, assignee, body))\n    // Display the action text inline as usual\n    body\n    // Mark the presence of an action in a sidenote with the assignee\n    // margin-note(side: side)[#strong(\"Action:\") #assignee]\n}\n\nHere's an example of text with an #action(assignee: \"Ben\")[action for Ben to do]\n\n#action(assignee: \"Ben\")[new action for Ben to do].\n\nThe current content of actions: \n\n#context actions.get()\n\n#action(assignee: \"Steven\")[a new person with some action].\n\n#action(assignee: \"Steven\")[steven action].\n\nThe current content of actions: \n\n#context actions.get()\n</code></pre>\n<p>Note that I commented the “margin-note” out, because you didn’t provide the function, so it wouldn’t compile otherwise.<br>\nI mainly changed the update function to “actions.update(x =&gt; _add_action(x, assignee, body))”. I also changed the helper function so it adds the actions to the array in the dictionary entry if it is present and add a dictionary entry otherwise. The x in the “actions.update” is the old value of the state and the content behind the “=&gt;” is the new value of the state. The helper function _add_action now changes the x (which is the first parameter of the function) and returns the new value.</p>\n<p>If there are any questions left or I misunderstood something, don’t hesitate to ask again <img src=\"https://forum.typst.app/images/emoji/apple/slight_smile.png?v=12\" title=\":slight_smile:\" class=\"emoji\" alt=\":slight_smile:\" loading=\"lazy\" width=\"20\" height=\"20\">. If this answer solves your problem, please mark it as the solution.</p>\n<p>PS: when initializing the state, you can use “state(“actions”, (:))” to initialze an empty dictionary.</p>",
      "raw": "Hi there! Welcome to the Forum. \nThe actions.at() doesn't work, because it references the at method of the state element itself, not the dictionary (see the [typst doc](https://typst.app/docs/reference/introspection/state#time-travel)). The at function of the state expects a location in the document or something like that (label etc.), so that's what the error is about. Here is:\n\n```typst\n// Create a dictionary to store actions for each assignee.  \n// The key will be the assignee and the value will be array of actions\n// Due to scoping constraints, use the \"state\" function\n#let actions = state(\"actions\", (:))\n\n// Define a helper function to add an action to the global dictionary\n#let _add_action(actions, assignee, action) = {\n  if not assignee in actions {\n    actions.insert(assignee, (action,))\n  }\n  else {\n  actions.at(assignee).push(action)\n  }\n  return actions\n}\n\n// Define an action for use in the body text\n#let action(body, assignee: \"\", side: left) = {\n    // Add action to the global state to be able to render a table later\n    actions.update(x => _add_action(x, assignee, body))\n    // Display the action text inline as usual\n    body\n    // Mark the presence of an action in a sidenote with the assignee\n    // margin-note(side: side)[#strong(\"Action:\") #assignee]\n}\n\nHere's an example of text with an #action(assignee: \"Ben\")[action for Ben to do]\n\n#action(assignee: \"Ben\")[new action for Ben to do].\n\nThe current content of actions: \n\n#context actions.get()\n\n#action(assignee: \"Steven\")[a new person with some action].\n\n#action(assignee: \"Steven\")[steven action].\n\nThe current content of actions: \n\n#context actions.get()\n```\n Note that I commented the \"margin-note\" out, because you didn't provide the function, so it wouldn't compile otherwise. \nI mainly changed the update function to \"actions.update(x => _add_action(x, assignee, body))\". I also changed the helper function so it adds the actions to the array in the dictionary entry if it is present and add a dictionary entry otherwise. The x in the \"actions.update\" is the old value of the state and the content behind the \"=>\" is the new value of the state. The helper function _add_action now changes the x (which is the first parameter of the function) and returns the new value. \n\nIf there are any questions left or I misunderstood something, don't hesitate to ask again :slight_smile:. If this answer solves your problem, please mark it as the solution. \n\nPS: when initializing the state, you can use \"state(\"actions\", (:))\" to initialze an empty dictionary.",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 2,
      "reads": 23,
      "score": 34.6,
      "accepted_answer": true,
      "trust_level": 2,
      "user_id": 277
    },
    {
      "id": 9878,
      "post_number": 3,
      "username": "Beno",
      "name": "",
      "created_at": "2025-03-16T21:14:16.749Z",
      "updated_at": "2025-03-16T21:14:16.749Z",
      "cooked": "<p><a class=\"mention\" href=\"/u/adrian_weitkemper\">@Adrian_Weitkemper</a> - thank you so much - this is really helpful and works for me perfectly.</p>",
      "raw": "@Adrian_Weitkemper - thank you so much - this is really helpful and works for me perfectly.",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 19,
      "score": 3.8,
      "accepted_answer": false,
      "trust_level": 1,
      "user_id": 1355
    },
    {
      "id": 9919,
      "post_number": 4,
      "username": "Beno",
      "name": "",
      "created_at": "2025-03-17T13:01:46.110Z",
      "updated_at": "2025-03-17T13:02:36.507Z",
      "cooked": "<p>For anyone following along at home, here’s where I got to with my code (including a function to output the table of actions), thanks to help from <a class=\"mention\" href=\"/u/adrian_weitkemper\">@Adrian_Weitkemper</a>.</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#import \"@preview/drafting:0.2.2\": margin-note\n\n// Create a dictionary to store actions for each assignee.  \n// The key will be the assignee and the value will be array of actions\n// Due to scoping constraints, use the \"state\" function\n#let actions = state(\"actions\", (:))\n\n// Define a helper function to add an action to the global dictionary\n#let _add_action(actions, assignee, action, timeframe, pos) = {\n\n  let action_and_timeframe = (action, timeframe, pos)\n\n  if not assignee in actions {\n    actions.insert(assignee, ( action_and_timeframe,))\n  }\n  else {\n    actions.at(assignee).push(action_and_timeframe)\n  }\n  return actions\n}\n\n// Define an action for use in the body text\n#let action(body, assignee: \"\", timeframe: \"ASAP\", side: right) = {\n    // Add action to the global state to be able to render a table later\n    context {\n      let pos = here().position()\n      actions.update(x =&gt; _add_action(x, assignee, body, timeframe, pos))\n    }\n    // Display the action text inline as usual\n    body\n    // Mark the presence of an action in a sidenote with the assignee\n    margin-note(side: side, stroke: red)[#strong(\"Action:\") #assignee]\n}\n\n// Define a function to render a table of actions\n#let table_of_actions() = {\n  context {\n\n    // Get the dictionary of actions\n    let actions_dict = actions.get()\n\n    // Custom styling for the table    \n    show table.cell: it =&gt; {\n      if it.y == 0 {\n        strong(it)\n      } else {\n        it\n      }\n    }\n    set table.hline(stroke: .6pt)\n\n    // Render the table\n    table(\n      columns: (4fr, 1fr, 1fr),\n      stroke: none,\n      [Action], [Assignee], [Due],\n      table.hline(),\n      // Iterate over the dictionary and render each assignees' actions\n      ..for pair in actions_dict.pairs() {\n\n        let (assignee, actions) = pair\n        // Iterate over the actions for each assignee\n        for action_timeframe_and_pos in actions {\n          // Unpack the action, timeframe, and position\n          let (action, timeframe, pos) = action_timeframe_and_pos\n          // Render the action in the table, linking back to the original text\n          (link(pos, action), assignee, timeframe, table.hline())\n        }\n      }\n    )\n  }\n}\n</code></pre>\n<p>Please do let me know if I missed a neater way of doing anything, or any other code improvements!</p>",
      "raw": "For anyone following along at home, here's where I got to with my code (including a function to output the table of actions), thanks to help from @Adrian_Weitkemper.\n\n```typ\n#import \"@preview/drafting:0.2.2\": margin-note\n\n// Create a dictionary to store actions for each assignee.  \n// The key will be the assignee and the value will be array of actions\n// Due to scoping constraints, use the \"state\" function\n#let actions = state(\"actions\", (:))\n\n// Define a helper function to add an action to the global dictionary\n#let _add_action(actions, assignee, action, timeframe, pos) = {\n\n  let action_and_timeframe = (action, timeframe, pos)\n\n  if not assignee in actions {\n    actions.insert(assignee, ( action_and_timeframe,))\n  }\n  else {\n    actions.at(assignee).push(action_and_timeframe)\n  }\n  return actions\n}\n\n// Define an action for use in the body text\n#let action(body, assignee: \"\", timeframe: \"ASAP\", side: right) = {\n    // Add action to the global state to be able to render a table later\n    context {\n      let pos = here().position()\n      actions.update(x => _add_action(x, assignee, body, timeframe, pos))\n    }\n    // Display the action text inline as usual\n    body\n    // Mark the presence of an action in a sidenote with the assignee\n    margin-note(side: side, stroke: red)[#strong(\"Action:\") #assignee]\n}\n\n// Define a function to render a table of actions\n#let table_of_actions() = {\n  context {\n\n    // Get the dictionary of actions\n    let actions_dict = actions.get()\n\n    // Custom styling for the table    \n    show table.cell: it => {\n      if it.y == 0 {\n        strong(it)\n      } else {\n        it\n      }\n    }\n    set table.hline(stroke: .6pt)\n\n    // Render the table\n    table(\n      columns: (4fr, 1fr, 1fr),\n      stroke: none,\n      [Action], [Assignee], [Due],\n      table.hline(),\n      // Iterate over the dictionary and render each assignees' actions\n      ..for pair in actions_dict.pairs() {\n\n        let (assignee, actions) = pair\n        // Iterate over the actions for each assignee\n        for action_timeframe_and_pos in actions {\n          // Unpack the action, timeframe, and position\n          let (action, timeframe, pos) = action_timeframe_and_pos\n          // Render the action in the table, linking back to the original text\n          (link(pos, action), assignee, timeframe, table.hline())\n        }\n      }\n    )\n  }\n}\n```\n\nPlease do let me know if I missed a neater way of doing anything, or any other code improvements!",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 0,
      "reads": 19,
      "score": 8.8,
      "accepted_answer": false,
      "trust_level": 1,
      "user_id": 1355
    },
    {
      "id": 11078,
      "post_number": 5,
      "username": "SillyFreak",
      "name": "SillyFreak",
      "created_at": "2025-04-14T18:03:10.385Z",
      "updated_at": "2025-04-14T18:03:10.385Z",
      "cooked": "<p>fwiw, since you want to have a list of actions, you may be interested in how packages add outlines for custom elements. Usually they do that by producing figures with custom kinds, e.g. <a href=\"https://typst.app/universe/package/theorion\">theorion</a>:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#import \"@preview/theorion:0.3.3\": *\n\n...\n\n#theorem(title: \"Euclid's Theorem\")[\n  There are infinitely many prime numbers.\n] &lt;thm:euclid&gt;\n\n#outline(title: none, target: figure.where(kind: \"theorem\"))\n</code></pre>\n<p>The code to implement this is not trivial, but from a quick look it seems like the relevant parts are here, maybe you can use some of it: <a href=\"https://github.com/OrangeX4/typst-theorion/blob/main/core.typ#L259-L400\" class=\"inline-onebox\">typst-theorion/core.typ at main · OrangeX4/typst-theorion · GitHub</a> (the code is MIT licensed)</p>",
      "raw": "fwiw, since you want to have a list of actions, you may be interested in how packages add outlines for custom elements. Usually they do that by producing figures with custom kinds, e.g. [theorion](https://typst.app/universe/package/theorion):\n\n```typ\n#import \"@preview/theorion:0.3.3\": *\n\n...\n\n#theorem(title: \"Euclid's Theorem\")[\n  There are infinitely many prime numbers.\n] <thm:euclid>\n\n#outline(title: none, target: figure.where(kind: \"theorem\"))\n```\n\nThe code to implement this is not trivial, but from a quick look it seems like the relevant parts are here, maybe you can use some of it: https://github.com/OrangeX4/typst-theorion/blob/main/core.typ#L259-L400 (the code is MIT licensed)",
      "reply_to_post_number": 4,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 13,
      "score": 2.6,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 32
    }
  ],
  "scraped_at": "2025-06-10T09:50:19.398006"
}