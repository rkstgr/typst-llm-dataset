{
  "topic_metadata": {
    "id": 2018,
    "title": "How to generate a multilevel list from a data structure?",
    "slug": "how-to-generate-a-multilevel-list-from-a-data-structure",
    "posts_count": 3,
    "created_at": "2024-12-07T16:46:33.112Z",
    "last_posted_at": "2024-12-07T22:25:20.846Z",
    "views": 295,
    "like_count": 4,
    "reply_count": 0,
    "has_accepted_answer": true,
    "accepted_answer_post_number": 3,
    "accepted_answer_username": "Eric",
    "tags": [
      "scripting",
      "layout",
      "lists",
      "data-loading"
    ],
    "category_id": 5,
    "participant_count": 3,
    "word_count": 659
  },
  "posts": [
    {
      "id": 6404,
      "post_number": 1,
      "username": "wnhrt",
      "name": "Niklas",
      "created_at": "2024-12-07T16:46:33.600Z",
      "updated_at": "2024-12-09T07:44:24.947Z",
      "cooked": "<p>Is there a method to create a multilevel list from a data structure, e.g. a JSON file?</p>\n<p>If I got this JSON file</p>\n<pre data-code-wrap=\"json\"><code class=\"lang-json\">{\n\t\"information\": [\n\t\t\"First point\",\n\t\t\"Second point\",\n\t\t[\n\t\t\t\"First subpoint\"\n\t\t],\n\t\t\"Third point\",\n\t\t[\n\t\t\t\"Second subpoint\",\n\t\t\t[\n\t\t\t\t\"First subsubpoint\"\n\t\t\t],\n\t\t]\n\t]\n}\n</code></pre>\n<p>I want it to be formated like this</p>\n<ul>\n<li>First point</li>\n<li>Second point\n<ul>\n<li>First subpoint</li>\n</ul>\n</li>\n<li>Third point\n<ul>\n<li>Second subpoint\n<ul>\n<li>First subsubpoint</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>The closest I got was with this</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let list_recursive(data, level: 0pt) = {\n\tfor item in data {\n\t\tif type(item) == array {\n\t\t\tlist_recursive(item, level: level+10pt)\n\t\t} else {\n\t\t\tlist(item, indent: level)\n\t\t}\n\t}\n}\n\n#let data = json(\"file.json\")\n#list_recursive(data.information)\n</code></pre>\n<p>but then all bullet points are separate lists with a single first level bullet point.</p>\n<p>Apparently there is a hidden <code>depth</code> field, which is not accessible to users: <a href=\"https://github.com/typst/typst/issues/4520#issuecomment-2221403490\" class=\"inline-onebox\" rel=\"noopener nofollow ugc\">Add level field to bullet list items for easier format and style minipulation · Issue #4520 · typst/typst · GitHub</a></p>",
      "raw": "Is there a method to create a multilevel list from a data structure, e.g. a JSON file?\n\nIf I got this JSON file\n\n```json\n{\n\t\"information\": [\n\t\t\"First point\",\n\t\t\"Second point\",\n\t\t[\n\t\t\t\"First subpoint\"\n\t\t],\n\t\t\"Third point\",\n\t\t[\n\t\t\t\"Second subpoint\",\n\t\t\t[\n\t\t\t\t\"First subsubpoint\"\n\t\t\t],\n\t\t]\n\t]\n}\n```\n\nI want it to be formated like this\n\n* First point\n* Second point\n  * First subpoint\n* Third point\n  * Second subpoint\n    * First subsubpoint\n\nThe closest I got was with this\n\n\n```typ\n#let list_recursive(data, level: 0pt) = {\n\tfor item in data {\n\t\tif type(item) == array {\n\t\t\tlist_recursive(item, level: level+10pt)\n\t\t} else {\n\t\t\tlist(item, indent: level)\n\t\t}\n\t}\n}\n\n#let data = json(\"file.json\")\n#list_recursive(data.information)\n```\n\nbut then all bullet points are separate lists with a single first level bullet point.\n\nApparently there is a hidden `depth` field, which is not accessible to users: https://github.com/typst/typst/issues/4520#issuecomment-2221403490",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 1,
      "reads": 35,
      "score": 1121.8,
      "accepted_answer": false,
      "trust_level": 0,
      "user_id": 901
    },
    {
      "id": 6412,
      "post_number": 2,
      "username": "miles-1",
      "name": "miles",
      "created_at": "2024-12-07T18:26:30.721Z",
      "updated_at": "2024-12-07T18:26:30.721Z",
      "cooked": "<p>TMI below, sorry. This is a fun puzzle (for my simple mind at least) and a worthwhile question. There’s a few things upfront that could be hindering your approach: (1) the elements of lists are <code>item</code>s (accessed with <code>list.item</code>), so if you want just one list, that will be the way to go. (2) Making a single list with indentations requires nesting of <code>item</code>s, and doing so will take care of indentation automatically.</p>\n<p>One issue that I didn’t see coming when thinking about this comes from the structure of <code>list</code>s in Typst. For example, this code…</p>\n<pre data-code-wrap=\"typst\"><code class=\"lang-typst\">#repr[\n- First point\n- Second point\n    - First subpoint\n]\n</code></pre>\n<p>… shows the underlying structure of lists:</p>\n<pre data-code-wrap=\"txt\"><code class=\"lang-txt\">sequence(\n  [ ],\n  item(body: [First point]), \n  [ ],\n  item(body: sequence(\n    [Second point],\n    [ ], \n    item(body: [First subpoint])\n  ),),\n  [ ],\n)\n</code></pre>\n<p>As seen here, when a list item is followed by an increase in indentation (aka a sublist), its <code>item</code> object is the parent to the sublist as well (see <code>[Second point]</code>). Therefore, in order to code this correctly, one needs to check if the item in the <code>json</code> data structure is followed by an array. This means that simple element-wise iteration with a recursive function is not an option here.</p>\n<p>To work around this, you might be interested in using only objects, not arrays, in your <code>json</code> file, like this:</p>\n<pre data-code-wrap=\"json\"><code class=\"lang-json\">{\n\t\"information\": {\n\t\t\"First point\": null,\n\t\t\"Second point\": {\"First subpoint\": null},\n\t\t\"Third point\": {\"Second subpoint\": {\"First subsubpoint\": null}}\n}\n</code></pre>\n<p>… then pure recursion could be used. But this format is somewhat ugly and tedius, with the <code>null</code>s required when there are no children. So, I came up with the approach below to work with your original json file instead, which starts by converting the data to a dictionary, and then using recursion.</p>\n<pre data-code-wrap=\"typst\"><code class=\"lang-typst\">#let data = json(\"file.json\").at(\"information\")\n\n#let array_to_dict(data) = {\n  let dict = (:)\n  let final_indx = data.len() - 1\n  for (indx, item) in data.enumerate() {\n    if type(item) == array {continue}\n    if indx == final_indx or type(data.at(indx + 1)) != array {\n      dict.insert(item, none)\n    } else {\n      dict.insert(item, array_to_dict(data.at(indx + 1)))\n    }\n  }\n  return dict\n}\n\n#let list_recursive(dict_data) = {\n  for (key, val) in dict_data.pairs() {\n    if val == none {\n      list.item(key)\n    } else {\n      list.item[#key #list_recursive(val)]\n    }\n  }\n}\n\n#let data_to_list(array_data) = {\n  let dict_data = array_to_dict(array_data)\n  list_recursive(dict_data)\n}\n\n\n= Original array data\n#data\n= Original array data to dict data\n#array_to_dict(data)\n= Original array data to list\n#data_to_list(data)\n</code></pre>",
      "raw": "TMI below, sorry. This is a fun puzzle (for my simple mind at least) and a worthwhile question. There's a few things upfront that could be hindering your approach: (1) the elements of lists are `item`s (accessed with `list.item`), so if you want just one list, that will be the way to go. (2) Making a single list with indentations requires nesting of `item`s, and doing so will take care of indentation automatically.\n\nOne issue that I didn't see coming when thinking about this comes from the structure of `list`s in Typst. For example, this code...\n```typst\n#repr[\n- First point\n- Second point\n    - First subpoint\n]\n```\n... shows the underlying structure of lists:\n```txt\nsequence(\n  [ ],\n  item(body: [First point]), \n  [ ],\n  item(body: sequence(\n    [Second point],\n    [ ], \n    item(body: [First subpoint])\n  ),),\n  [ ],\n)\n```\n\nAs seen here, when a list item is followed by an increase in indentation (aka a sublist), its `item` object is the parent to the sublist as well (see `[Second point]`). Therefore, in order to code this correctly, one needs to check if the item in the `json` data structure is followed by an array. This means that simple element-wise iteration with a recursive function is not an option here. \n\nTo work around this, you might be interested in using only objects, not arrays, in your `json` file, like this: \n```json\n{\n\t\"information\": {\n\t\t\"First point\": null,\n\t\t\"Second point\": {\"First subpoint\": null},\n\t\t\"Third point\": {\"Second subpoint\": {\"First subsubpoint\": null}}\n}\n```\n... then pure recursion could be used. But this format is somewhat ugly and tedius, with the `null`s required when there are no children. So, I came up with the approach below to work with your original json file instead, which starts by converting the data to a dictionary, and then using recursion.\n\n```typst\n#let data = json(\"file.json\").at(\"information\")\n\n#let array_to_dict(data) = {\n  let dict = (:)\n  let final_indx = data.len() - 1\n  for (indx, item) in data.enumerate() {\n    if type(item) == array {continue}\n    if indx == final_indx or type(data.at(indx + 1)) != array {\n      dict.insert(item, none)\n    } else {\n      dict.insert(item, array_to_dict(data.at(indx + 1)))\n    }\n  }\n  return dict\n}\n\n#let list_recursive(dict_data) = {\n  for (key, val) in dict_data.pairs() {\n    if val == none {\n      list.item(key)\n    } else {\n      list.item[#key #list_recursive(val)]\n    }\n  }\n}\n\n#let data_to_list(array_data) = {\n  let dict_data = array_to_dict(array_data)\n  list_recursive(dict_data)\n}\n\n\n= Original array data\n#data\n= Original array data to dict data\n#array_to_dict(data)\n= Original array data to list\n#data_to_list(data)\n```",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 32,
      "score": 31.2,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 177
    },
    {
      "id": 6414,
      "post_number": 3,
      "username": "Eric",
      "name": "Eric Biedert",
      "created_at": "2024-12-07T22:25:20.846Z",
      "updated_at": "2024-12-07T22:26:22.851Z",
      "cooked": "<p>A simple recursive solution is still possible. As you can see in the structure shown in <a class=\"mention\" href=\"/u/miles-1\">@miles-1</a>’s reply, sublists are attached to the previous list item. Therefore, you just need to append the sublist to the previous item’s body instead of creating a new one. You also don’t need to explicitly construct a list, as it is created implicitly from the list items.</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let to-list(arr) = {\n  arr.fold((), (items, curr) =&gt; {\n    // If the current entry is an array, append a new sublist to\n    // the last item. Otherwise, create a new list item.\n    if type(curr) == array { items.at(-1) += to-list(curr) }\n    else { items.push(curr) }\n    items\n  }).map(list.item).join()\n}\n\n#let data = json(\"file.json\")\n#to-list(data.information)\n</code></pre>\n<p><img src=\"https://forum.typst.app/uploads/default/original/2X/b/bb05b757e0a66c254b0031843a48833c1fb9c59a.png\" alt=\"image\" data-base62-sha1=\"qGtx65LdNuMetsznzBLuuEtua0i\" width=\"199\" height=\"142\"></p>",
      "raw": "A simple recursive solution is still possible. As you can see in the structure shown in @miles-1's reply, sublists are attached to the previous list item. Therefore, you just need to append the sublist to the previous item's body instead of creating a new one. You also don't need to explicitly construct a list, as it is created implicitly from the list items.\n\n```typ\n#let to-list(arr) = {\n  arr.fold((), (items, curr) => {\n    // If the current entry is an array, append a new sublist to\n    // the last item. Otherwise, create a new list item.\n    if type(curr) == array { items.at(-1) += to-list(curr) }\n    else { items.push(curr) }\n    items\n  }).map(list.item).join()\n}\n\n#let data = json(\"file.json\")\n#to-list(data.information)\n```\n\n![image|199x142](upload://qGtx65LdNuMetsznzBLuuEtua0i.png)",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 3,
      "reads": 27,
      "score": 115.2,
      "accepted_answer": true,
      "trust_level": 2,
      "user_id": 88
    }
  ],
  "scraped_at": "2025-06-10T09:53:49.911330"
}