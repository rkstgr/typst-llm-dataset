{
  "topic_metadata": {
    "id": 3585,
    "title": "How to optimize a `query` that leads to severe performance problems?",
    "slug": "how-to-optimize-a-query-that-leads-to-severe-performance-problems",
    "posts_count": 17,
    "created_at": "2025-04-09T12:30:33.478Z",
    "last_posted_at": "2025-04-24T17:45:05.054Z",
    "views": 249,
    "like_count": 18,
    "reply_count": 11,
    "has_accepted_answer": true,
    "accepted_answer_post_number": 7,
    "accepted_answer_username": "bluss",
    "tags": [
      "scripting",
      "query"
    ],
    "category_id": 5,
    "participant_count": 5,
    "word_count": 4218
  },
  "posts": [
    {
      "id": 10846,
      "post_number": 1,
      "username": "a_w",
      "name": "Alex",
      "created_at": "2025-04-09T12:30:33.574Z",
      "updated_at": "2025-04-09T19:20:50.295Z",
      "cooked": "<p>Hey <img src=\"https://forum.typst.app/images/emoji/apple/smiling_face.png?v=12\" title=\":smiling_face:\" class=\"emoji\" alt=\":smiling_face:\" loading=\"lazy\" width=\"20\" height=\"20\"> I‚Äôm working with some fairly large documents (up to 1000 pages) where the headers must guide through the readers the sections, chapters and paragraphs.</p>\n<p>(Example: <code>Section 3 ¬∑ Chap. F ¬∑ Par. 25 ‚Äî Section 3 ¬∑ Chapter G ¬∑ Par. 2</code>)</p>\n<p>Thanks to the support of three very helpful members here, I was able to implement a solution with <code>query</code> like so: <a href=\"https://forum.typst.app/t/3456/\" class=\"inline-onebox\">How to get the number of the first and last paragraph on a page and show the result in the header?</a></p>\n<p>The main part to get the paragraph numbers for the header looks like this (full code at the end):</p>\n<pre data-code-wrap=\"typc\"><code class=\"lang-typc\">// Helper Functions\n#let get-short(label, x) = {\n  let shorts = query(selector(label).before(x.location()))\n  return shorts.at(-1, default: none)\n}\n#let shorts-and-id(x) = {\n  let h1 = get-short(&lt;h1-short&gt;, x)\n  let h2 = get-short(&lt;h2-short&gt;, x)\n  return (h1: h1.value, h2: h2.value, id: x.value)\n}\n\n// Chunk of the query code\nlet pars = query(selector.or(&lt;h4-start&gt;, &lt;h4-end&gt;))\n  .filter(x =&gt; x.location().page() == here().page())\n  .map(shorts-and-id)\n  .dedup()\nif pars.len() == 0 {\n  // No paragraph starting or ending on this page\n  // -&gt; check if a paragraph starts before and ends after this page\n  let prevs = query(selector(&lt;h4-start&gt;).before(here()))\n  let nexts = query(selector(&lt;h4-end&gt;).after(here()))\n  if prevs.len() == 0 or nexts.len() == 0 {\n    return\n  }\n</code></pre>\n<p>The problem with the solution is, that <strong>compilation times grow so extensively (cubic or even higher)</strong>, that the documents quickly become uncompileable.</p>\n<p>I didn‚Äôt notice that at first, because I worked only with draft parts. When I tried to compile one of the actual documents, it didn‚Äôt finish in +5 hours and I had to cancel the compilation process.</p>\n<p>The minimal example code (you‚Äôll find a copy at the end) generates the following results on my M1 MacBook (measured with <code>time</code> for <code>typst compile</code> in zsh):</p>\n<pre data-code-wrap=\"txt\"><code class=\"lang-txt\">1 Section:    0,64s user  0,07s system  95% cpu 0,743 total\n2 Sections:   4,99s user  0,46s system 127% cpu 4,264 total\n3 Sections:  27,57s user  3,39s system 141% cpu 21,922 total\n4 Sections:  72,40s user  7,25s system 145% cpu 54,725 total\n5 Sections: 151,57s user 24,86s system 135% cpu 2:09,92 total\n6 Sections: 257,02s user 60,35s system 133% cpu 3:57,47 total\n</code></pre>\n<p><strong>So while the amount of content went up 6x, the CPU user time went up 400x.</strong> Showing a bottleneck that scales cubic or even higher, quickly leading to unworkable compile times for the actual documents‚Ä¶ <img src=\"https://forum.typst.app/images/emoji/apple/snail.png?v=12\" title=\":snail:\" class=\"emoji\" alt=\":snail:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>\n<ul>\n<li>Is there maybe an error or ineffieciency in my code that leads to this (maybe parts like <code>.before(here()</code> are to open ended)?</li>\n<li>How can I optimize the <code>query</code> code to display the Section/Chapter/Paraphs with compile times that don‚Äôt feel like I‚Äôm mining Bitcoin on my poor laptop? <img src=\"https://forum.typst.app/images/emoji/apple/smile.png?v=12\" title=\":smile:\" class=\"emoji\" alt=\":smile:\" loading=\"lazy\" width=\"20\" height=\"20\"></li>\n</ul>\n<p>You can quickly test/reproduce this with the <strong>following MWE</strong> <img src=\"https://forum.typst.app/images/emoji/apple/arrow_down.png?v=12\" title=\":arrow_down:\" class=\"emoji\" alt=\":arrow_down:\" loading=\"lazy\" width=\"20\" height=\"20\">:</p>\n<details>\n<summary>\nFull Code Example üìã</summary>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">// Helper Functions\n#let get-short(label, x) = {\n  let shorts = query(selector(label).before(x.location()))\n  return shorts.at(-1, default: none)\n}\n#let shorts-and-id(x) = {\n  let h1 = get-short(&lt;h1-short&gt;, x)\n  let h2 = get-short(&lt;h2-short&gt;, x)\n  return (h1: h1.value, h2: h2.value, id: x.value)\n}\n// Output assembly\n#let header-content(a, b) = {\n  return [#a.h1, #a.h2, Par. #a.id --- #b.h1, #b.h2, Par. #b.id]\n}\n\n// Actual Query\n#set page(\n  width: 120mm,\n  height: 100mm,\n  header: context {\n    let pars = query(selector.or(&lt;h4-start&gt;, &lt;h4-end&gt;))\n      .filter(x =&gt; x.location().page() == here().page())\n      .map(shorts-and-id)\n      .dedup()\n    if pars.len() == 0 {\n      // No paragraph starting or ending on this page\n      // -&gt; check if a paragraph starts before and ends after this page\n      let prevs = query(selector(&lt;h4-start&gt;).before(here()))\n      let nexts = query(selector(&lt;h4-end&gt;).after(here()))\n      if prevs.len() == 0 or nexts.len() == 0 {\n        return\n      }\n      let prev = shorts-and-id(prevs.last())\n      let next = shorts-and-id(nexts.first())\n      if prev != next {\n        return\n      }\n      return header-content(prev, next)\n    }\n    return header-content(pars.first(), pars.at(-1, default: none))\n  },\n)\n\n// The Elements\n#let my-h1(short: none, ..args) = {\n  heading(level: 1, ..args)\n  [#metadata(short)&lt;h1-short&gt;]\n}\n#show heading.where(level: 1): it =&gt; {\n  pagebreak(weak: true)\n  it\n}\n#let my-h2(short: none, ..args) = {\n  heading(level: 2, ..args)\n  [#metadata(short)&lt;h2-short&gt;]\n}\n#let my-par(id: none, body) = text({\n  [#metadata([#id])&lt;h4-start&gt;]\n  if id != none {\n    heading(level: 4, id)\n  }\n  body\n  [#metadata([#id])&lt;h4-end&gt;]\n  hide(\"‚Äã\")\n})\n#show heading.where(level: 4): it =&gt; it.body + \" \"\n\n// ‚¨áÔ∏è Test Content (setting num-sections below to 1,2,3‚Ä¶6 should roughly lead to the results in my post)\n#let num-sections = 1\n// Used chapter letters just for better overview in the example output\n// ABCDEFGHIJKLMNOPQRSTUVWXYZ\n#let chapter-letters = \"ABCDEFGH\"\n#let num-paragraphs-per-chapter = 25\n\n#let s = 1\n#while s &lt;= num-sections {\n  my-h1(short: \"Section \" + [#s])[This is Section #s]\n  let c = 1\n  for letter in chapter-letters {\n    my-h2(short: \"Chap. \" + [#letter])[This is Chapter #letter]\n    let p = 1\n    while p &lt;= num-paragraphs-per-chapter {\n      my-par(id: [#p], lorem(50))\n      p = p + 1\n    }\n  }\n  s = s + 1\n}\n\n</code></pre>\n</details>\n<p>(Note: It is set to output 1 section by default, so it doesn‚Äôt crash anyones tinymist. You can flexibly set the amount of test output is at the end to reproduce.)</p>",
      "raw": "Hey ‚ò∫Ô∏è I'm working with some fairly large documents (up to 1000 pages) where the headers must guide through the readers the sections, chapters and paragraphs.\n\n(Example: `Section 3 ¬∑ Chap. F ¬∑ Par. 25 ‚Äî Section 3 ¬∑ Chapter G ¬∑ Par. 2`)\n\nThanks to the support of three very helpful members here, I was able to implement a solution with `query` like so: https://forum.typst.app/t/3456/\n\nThe main part to get the paragraph numbers for the header looks like this (full code at the end):\n```typc\n// Helper Functions\n#let get-short(label, x) = {\n  let shorts = query(selector(label).before(x.location()))\n  return shorts.at(-1, default: none)\n}\n#let shorts-and-id(x) = {\n  let h1 = get-short(<h1-short>, x)\n  let h2 = get-short(<h2-short>, x)\n  return (h1: h1.value, h2: h2.value, id: x.value)\n}\n\n// Chunk of the query code\nlet pars = query(selector.or(<h4-start>, <h4-end>))\n  .filter(x => x.location().page() == here().page())\n  .map(shorts-and-id)\n  .dedup()\nif pars.len() == 0 {\n  // No paragraph starting or ending on this page\n  // -> check if a paragraph starts before and ends after this page\n  let prevs = query(selector(<h4-start>).before(here()))\n  let nexts = query(selector(<h4-end>).after(here()))\n  if prevs.len() == 0 or nexts.len() == 0 {\n    return\n  }\n```\n\nThe problem with the solution is, that **compilation times grow so extensively (cubic or even higher)**, that the documents quickly become uncompileable.\n\nI didn't notice that at first, because I worked only with draft parts. When I tried to compile one of the actual documents, it didn't finish in +5 hours and I had to cancel the compilation process.\n\nThe minimal example code (you'll find a copy at the end) generates the following results on my M1 MacBook (measured with `time` for `typst compile` in zsh):\n\n```txt\n1 Section:    0,64s user  0,07s system  95% cpu 0,743 total\n2 Sections:   4,99s user  0,46s system 127% cpu 4,264 total\n3 Sections:  27,57s user  3,39s system 141% cpu 21,922 total\n4 Sections:  72,40s user  7,25s system 145% cpu 54,725 total\n5 Sections: 151,57s user 24,86s system 135% cpu 2:09,92 total\n6 Sections: 257,02s user 60,35s system 133% cpu 3:57,47 total\n```\n\n**So while the amount of content went up 6x, the CPU user time went up 400x.** Showing a bottleneck that scales cubic or even higher, quickly leading to unworkable compile times for the actual documents‚Ä¶ üêå\n\n- Is there maybe an error or ineffieciency in my code that leads to this (maybe parts like `.before(here()` are to open ended)?\n- How can I optimize the `query` code to display the Section/Chapter/Paraphs with compile times that don't feel like I'm mining Bitcoin on my poor laptop? üòÑ\n\nYou can quickly test/reproduce this with the **following MWE** ‚¨áÔ∏è:\n\n[details=\"Full Code Example üìã\"]\n```typ\n// Helper Functions\n#let get-short(label, x) = {\n  let shorts = query(selector(label).before(x.location()))\n  return shorts.at(-1, default: none)\n}\n#let shorts-and-id(x) = {\n  let h1 = get-short(<h1-short>, x)\n  let h2 = get-short(<h2-short>, x)\n  return (h1: h1.value, h2: h2.value, id: x.value)\n}\n// Output assembly\n#let header-content(a, b) = {\n  return [#a.h1, #a.h2, Par. #a.id --- #b.h1, #b.h2, Par. #b.id]\n}\n\n// Actual Query\n#set page(\n  width: 120mm,\n  height: 100mm,\n  header: context {\n    let pars = query(selector.or(<h4-start>, <h4-end>))\n      .filter(x => x.location().page() == here().page())\n      .map(shorts-and-id)\n      .dedup()\n    if pars.len() == 0 {\n      // No paragraph starting or ending on this page\n      // -> check if a paragraph starts before and ends after this page\n      let prevs = query(selector(<h4-start>).before(here()))\n      let nexts = query(selector(<h4-end>).after(here()))\n      if prevs.len() == 0 or nexts.len() == 0 {\n        return\n      }\n      let prev = shorts-and-id(prevs.last())\n      let next = shorts-and-id(nexts.first())\n      if prev != next {\n        return\n      }\n      return header-content(prev, next)\n    }\n    return header-content(pars.first(), pars.at(-1, default: none))\n  },\n)\n\n// The Elements\n#let my-h1(short: none, ..args) = {\n  heading(level: 1, ..args)\n  [#metadata(short)<h1-short>]\n}\n#show heading.where(level: 1): it => {\n  pagebreak(weak: true)\n  it\n}\n#let my-h2(short: none, ..args) = {\n  heading(level: 2, ..args)\n  [#metadata(short)<h2-short>]\n}\n#let my-par(id: none, body) = text({\n  [#metadata([#id])<h4-start>]\n  if id != none {\n    heading(level: 4, id)\n  }\n  body\n  [#metadata([#id])<h4-end>]\n  hide(\"‚Äã\")\n})\n#show heading.where(level: 4): it => it.body + \" \"\n\n// ‚¨áÔ∏è Test Content (setting num-sections below to 1,2,3‚Ä¶6 should roughly lead to the results in my post)\n#let num-sections = 1\n// Used chapter letters just for better overview in the example output\n// ABCDEFGHIJKLMNOPQRSTUVWXYZ\n#let chapter-letters = \"ABCDEFGH\"\n#let num-paragraphs-per-chapter = 25\n\n#let s = 1\n#while s <= num-sections {\n  my-h1(short: \"Section \" + [#s])[This is Section #s]\n  let c = 1\n  for letter in chapter-letters {\n    my-h2(short: \"Chap. \" + [#letter])[This is Chapter #letter]\n    let p = 1\n    while p <= num-paragraphs-per-chapter {\n      my-par(id: [#p], lorem(50))\n      p = p + 1\n    }\n  }\n  s = s + 1\n}\n\n```\n[/details]\n\n(Note: It is set to output 1 section by default, so it doesn't crash anyones tinymist. You can flexibly set the amount of test output is at the end to reproduce.)",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 1,
      "reads": 44,
      "score": 93.8,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 566
    },
    {
      "id": 10856,
      "post_number": 2,
      "username": "bluss",
      "name": "Ulrik",
      "created_at": "2025-04-09T16:18:01.282Z",
      "updated_at": "2025-04-09T16:22:40.532Z",
      "cooked": "<p>If it‚Äôs possible maybe you could share a project with the complete code (not necessarily the complete document) and then it would be easier to work with in practice.</p>\n<p>It‚Äôs clear that the paragraph scan is at least O(n¬≤) when performed once per page. I wonder now if it could be written like this:</p>\n<pre data-code-wrap=\"typc\"><code class=\"lang-typc\">let thispage = here().page()\nlet pagestart = label(\"page-begin-\" + str(thispage))\nlet pageend = label(\"page-end-\" + str(thispage))\nlet pars = query(selector.or(&lt;h4-start&gt;, &lt;h4-end&gt;).after(pagestart).before(pageend))\n</code></pre>\n<p>Where you use labels that delimit each page (you place them in header/footer so that they do). That is assuming of course that query before/after benefits from this.</p>\n<p>If that works, it could be an improvement. Then the ‚Äúno paragraph on this page‚Äù case needs the same kind of care too. Maybe you could disable that case and see if it contributes to the slowdown or not.</p>\n<p>I wonder if none of that works, maybe it‚Äôs possible to yourself optimize by performing certain queries only once (and storing in state) instead of repeating variants of them each page.</p>\n<hr>\n<p>Based on code from the previous thread, I mean that you can query certain information only once or once per chapter, and then you refer back to it later.</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#context {\n  query(selector.or(&lt;h4-start&gt;, &lt;h4-end&gt;)).map(x =&gt; (x.location().page(), shorts-and-id(x))).dedup()\n}\n</code></pre>\n<p>Once you have that data in a dictionary, it should be efficient to use.</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://forum.typst.app/uploads/default/original/2X/9/90b500f41726c1dd18aea1df80c7cf90646c813b.png\" data-download-href=\"https://forum.typst.app/uploads/default/90b500f41726c1dd18aea1df80c7cf90646c813b\" title=\"image\"><img src=\"https://forum.typst.app/uploads/default/optimized/2X/9/90b500f41726c1dd18aea1df80c7cf90646c813b_2_535x500.png\" alt=\"image\" data-base62-sha1=\"kE8ynfBS1PulVI6Kiwrg93x2ftp\" width=\"535\" height=\"500\" srcset=\"https://forum.typst.app/uploads/default/optimized/2X/9/90b500f41726c1dd18aea1df80c7cf90646c813b_2_535x500.png, https://forum.typst.app/uploads/default/original/2X/9/90b500f41726c1dd18aea1df80c7cf90646c813b.png 1.5x, https://forum.typst.app/uploads/default/original/2X/9/90b500f41726c1dd18aea1df80c7cf90646c813b.png 2x\" data-dominant-color=\"F1F4F0\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">image</span><span class=\"informations\">558√ó521 119 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>",
      "raw": "If it's possible maybe you could share a project with the complete code (not necessarily the complete document) and then it would be easier to work with in practice.\n\nIt's clear that the paragraph scan is at least O(n¬≤) when performed once per page. I wonder now if it could be written like this:\n\n```typc\nlet thispage = here().page()\nlet pagestart = label(\"page-begin-\" + str(thispage))\nlet pageend = label(\"page-end-\" + str(thispage))\nlet pars = query(selector.or(<h4-start>, <h4-end>).after(pagestart).before(pageend))\n```\n\nWhere you use labels that delimit each page (you place them in header/footer so that they do). That is assuming of course that query before/after benefits from this.\n\nIf that works, it could be an improvement. Then the \"no paragraph on this page\" case needs the same kind of care too. Maybe you could disable that case and see if it contributes to the slowdown or not.\n\nI wonder if none of that works, maybe it's possible to yourself optimize by performing certain queries only once (and storing in state) instead of repeating variants of them each page.\n\n----\n\nBased on code from the previous thread, I mean that you can query certain information only once or once per chapter, and then you refer back to it later.\n\n```typ\n#context {\n  query(selector.or(<h4-start>, <h4-end>)).map(x => (x.location().page(), shorts-and-id(x))).dedup()\n}\n```\n\nOnce you have that data in a dictionary, it should be efficient to use.\n\n![image|535x500](upload://kE8ynfBS1PulVI6Kiwrg93x2ftp.png)",
      "reply_to_post_number": null,
      "reply_count": 2,
      "quote_count": 0,
      "like_count": 0,
      "reads": 41,
      "score": 18.2,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 1272
    },
    {
      "id": 10857,
      "post_number": 3,
      "username": "a_w",
      "name": "Alex",
      "created_at": "2025-04-09T16:46:42.967Z",
      "updated_at": "2025-04-09T16:50:59.554Z",
      "cooked": "<aside class=\"quote no-group\" data-username=\"bluss\" data-post=\"2\" data-topic=\"3585\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/letter_avatar_proxy/v4/letter/b/441A5E/48.png\" class=\"avatar\"> bluss:</div>\n<blockquote>\n<p>If it‚Äôs possible maybe you could share a project with the complete code (not necessarily the complete document) and then it would be easier to work with in practice.</p>\n</blockquote>\n</aside>\n<p>You mean in addition to the full code example at the end (Update: I‚Äôve tried to make it more visible in case it was too easy to overlook)? I thought it would be easier for anyone willing to help if the example was abstracted to the problem (thinking SSCCE) and flexibly scalable for trying different approaches, rather than having to deal with a huge file containing a large chunk of static (test) content? What form should I provide that would be easier to work with? <img src=\"https://forum.typst.app/images/emoji/apple/blush.png?v=12\" title=\":blush:\" class=\"emoji\" alt=\":blush:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>\n<aside class=\"quote no-group\" data-username=\"bluss\" data-post=\"2\" data-topic=\"3585\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/letter_avatar_proxy/v4/letter/b/441A5E/48.png\" class=\"avatar\"> bluss:</div>\n<blockquote>\n<p>I wonder if none of that works, maybe it‚Äôs possible to yourself optimize by performing certain queries only once (and storing in state) instead of repeating variants of them each page.</p>\n</blockquote>\n</aside>\n<p>That would be the ideal case I guess, but combining <code>state</code> and <code>query</code> in a way that doesn‚Äôt make things worse is currently still a bit above my Typst skill level <img src=\"https://forum.typst.app/images/emoji/apple/joy.png?v=12\" title=\":joy:\" class=\"emoji\" alt=\":joy:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>\n<p>But as you say (or rather as I was hoping), and from my limited understanding of how Typst works internally, if the scope of the <code>query</code> were as narrow as it can be (which I don‚Äôt know: Can an element that didn‚Äôt start, but instead only reaches to a given page can be still queried there?), it would likely speed up the processing considerably.</p>",
      "raw": "[quote=\"bluss, post:2, topic:3585\"]\nIf it‚Äôs possible maybe you could share a project with the complete code (not necessarily the complete document) and then it would be easier to work with in practice.\n[/quote]\n\nYou mean in addition to the full code example at the end (Update: I've tried to make it more visible in case it was too easy to overlook)? I thought it would be easier for anyone willing to help if the example was abstracted to the problem (thinking SSCCE) and flexibly scalable for trying different approaches, rather than having to deal with a huge file containing a large chunk of static (test) content? What form should I provide that would be easier to work with? üòä\n\n[quote=\"bluss, post:2, topic:3585\"]\nI wonder if none of that works, maybe it‚Äôs possible to yourself optimize by performing certain queries only once (and storing in state) instead of repeating variants of them each page.\n[/quote]\n\nThat would be the ideal case I guess, but combining `state` and `query` in a way that doesn't make things worse is currently still a bit above my Typst skill level üòÇ\n\nBut as you say (or rather as I was hoping), and from my limited understanding of how Typst works internally, if the scope of the `query` were as narrow as it can be (which I don't know: Can an element that didn't start, but instead only reaches to a given page can be still queried there?), it would likely speed up the processing considerably.",
      "reply_to_post_number": 2,
      "reply_count": 1,
      "quote_count": 1,
      "like_count": 0,
      "reads": 37,
      "score": 17.4,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 566
    },
    {
      "id": 10858,
      "post_number": 4,
      "username": "bluss",
      "name": "Ulrik",
      "created_at": "2025-04-09T17:02:33.548Z",
      "updated_at": "2025-04-09T17:02:33.548Z",
      "cooked": "<aside class=\"quote no-group\" data-username=\"a_w\" data-post=\"3\" data-topic=\"3585\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/user_avatar/forum.typst.app/a_w/48/1206_2.png\" class=\"avatar\"> a_w:</div>\n<blockquote>\n<p>(Update: I‚Äôve tried to make it more visible in case it was too easy to overlook)</p>\n</blockquote>\n</aside>\n<p>I‚Äôm sorry, I missed that <img src=\"https://forum.typst.app/images/emoji/apple/blush.png?v=12\" title=\":blush:\" class=\"emoji\" alt=\":blush:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>",
      "raw": "[quote=\"a_w, post:3, topic:3585\"]\n(Update: I‚Äôve tried to make it more visible in case it was too easy to overlook)\n[/quote]\nI'm sorry, I missed that :blush:",
      "reply_to_post_number": 3,
      "reply_count": 0,
      "quote_count": 1,
      "like_count": 1,
      "reads": 36,
      "score": 22.2,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 1272
    },
    {
      "id": 10859,
      "post_number": 5,
      "username": "laurmaedje",
      "name": "Laurenz M√§dje",
      "created_at": "2025-04-09T17:21:30.376Z",
      "updated_at": "2025-04-09T17:21:30.376Z",
      "cooked": "<p>I haven‚Äôt looked at the details here, but this <em>could</em> be relevant: <a href=\"https://github.com/typst/typst/issues/5220\" class=\"inline-onebox\">Quadratic runtime of cache validation ¬∑ Issue #5220 ¬∑ typst/typst ¬∑ GitHub</a></p>",
      "raw": "I haven't looked at the details here, but this _could_ be relevant: https://github.com/typst/typst/issues/5220",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 1,
      "reads": 36,
      "score": 27.2,
      "accepted_answer": false,
      "trust_level": 4,
      "user_id": 2
    },
    {
      "id": 10878,
      "post_number": 6,
      "username": "a_w",
      "name": "Alex",
      "created_at": "2025-04-10T12:16:37.003Z",
      "updated_at": "2025-04-10T12:16:37.003Z",
      "cooked": "<p>Thank you, that‚Äôs good to know. Unfortunately, I can‚Äôt verify if that applies here, since I don‚Äôt know what the (temporary?) solution would look like in this case for comparison ‚Äî kind of like a cache buster for the query?</p>",
      "raw": "Thank you, that‚Äôs good to know. Unfortunately, I can‚Äôt verify if that applies here, since I don‚Äôt know what the (temporary?) solution would look like in this case for comparison ‚Äî kind of like a cache buster for the query?",
      "reply_to_post_number": 5,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 32,
      "score": 6.4,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 566
    },
    {
      "id": 10918,
      "post_number": 7,
      "username": "bluss",
      "name": "Ulrik",
      "created_at": "2025-04-10T20:48:52.379Z",
      "updated_at": "2025-04-10T23:35:31.282Z",
      "cooked": "<aside class=\"quote no-group\" data-username=\"bluss\" data-post=\"2\" data-topic=\"3585\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/letter_avatar_proxy/v4/letter/b/441A5E/48.png\" class=\"avatar\"> bluss:</div>\n<blockquote>\n<p>Where you use labels that delimit each page (you place them in header/footer so that they do). That is assuming of course that query before/after benefits from this.</p>\n</blockquote>\n</aside>\n<p>This page-start/end idea helps in the example, but only by increasing performance by 30% or so. It doesn‚Äôt change the scaling of the issue I think so it‚Äôs not a solution at all.</p>\n<p>I have some success now with the cache strategy. I think this 1) speeds it up massively, 2) changes scaling to be better(?). It‚Äôs not blazingly fast, but it‚Äôs much better.</p>\n<p>The pars.len() == 0 case is unimplemented, it doesn‚Äôt affect the example. But it needs to use the same cached datastructure too.</p>\n<details>\n<summary>Code</summary>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">// Helper Functions\n#let get-short(label, x) = {\n  let shorts = query(selector(label).before(x.location()))\n  return shorts.at(-1, default: none)\n}\n#let shorts-and-id(x) = {\n  let h1 = get-short(&lt;h1-short&gt;, x)\n  let h2 = get-short(&lt;h2-short&gt;, x)\n  return (h1: h1.value, h2: h2.value, id: x.value)\n}\n// Output assembly\n#let header-content(a, b) = {\n  return [#a.h1, #a.h2, Par. #a.id --- #b.h1, #b.h2, Par. #b.id]\n}\n\n// Return array. Index: page number. Value: Array of paragraph info on that page.\n#let shorts-per-page() = {\n    let pars = query(selector.or(&lt;h4-start&gt;, &lt;h4-end&gt;))\n    let d = ()\n    for par in pars {\n      let pg = par.location().page()\n      while d.len() &lt;= pg { d.push(()) }\n      d.at(pg).push(shorts-and-id(par))\n    }\n    return d\n}\n\n#let cache = state(\"parscache\", none)\n\n\n// Actual Query\n#set page(\n  width: 120mm,\n  height: 100mm,\n  header: context {\n    let pg = here().page()\n    let cachedpars = cache.get()\n    if cachedpars == none {\n      cachedpars = shorts-per-page()\n      cache.update(_ =&gt; cachedpars)\n    }\n    let pars = cachedpars.at(pg, default: none)\n    if pars == none {\n      return\n    }\n    if pars.len() == 0 {\n      return\n    }\n    header-content(pars.first(), pars.at(-1, default: none))\n  }\n)\n\n// The Elements\n#let my-h1(short: none, ..args) = {\n  heading(level: 1, ..args)\n  [#metadata(short)&lt;h1-short&gt;]\n}\n#show heading.where(level: 1): it =&gt; {\n  pagebreak(weak: true)\n  it\n}\n#let my-h2(short: none, ..args) = {\n  heading(level: 2, ..args)\n  [#metadata(short)&lt;h2-short&gt;]\n}\n#let my-par(id: none, body) = text({\n  [#metadata([#id])&lt;h4-start&gt;]\n  if id != none {\n    heading(level: 4, id)\n  }\n  body\n  [#metadata([#id])&lt;h4-end&gt;]\n  hide(\"‚Äã\")\n})\n#show heading.where(level: 4): it =&gt; it.body + \" \"\n\n// ‚¨áÔ∏è Test Content (setting num-sections below to 1,2,3‚Ä¶6 should roughly lead to the results in my post)\n// Used chapter letters just for better overview in the example output\n// ABCDEFGHIJKLMNOPQRSTUVWXYZ\n#let chapter-letters = \"ABCDEFGH\"\n#let num-paragraphs-per-chapter = 25\n\n// use sys.inputs for command line parametrization\n#let s = 1\n#let num-sections = int(sys.inputs.at(\"N\", default: \"1\"))\n#while s &lt;= num-sections {\n  my-h1(short: \"Section \" + [#s])[This is Section #s]\n  let c = 1\n  for letter in chapter-letters {\n    my-h2(short: \"Chap. \" + [#letter])[This is Chapter #letter]\n    let p = 1\n    while p &lt;= num-paragraphs-per-chapter {\n      my-par(id: [#p], lorem(50))\n      p = p + 1\n    }\n  }\n  s = s + 1\n}\n</code></pre>\n</details>\n<br>\n<br>\n<pre data-code-wrap=\"shell\"><code class=\"lang-shell\">time typst compile patho.typ  --input N=1\n0.20user 0.07system 0:00.27elapsed 105%CPU (0avgtext+0avgdata 54300maxresident)k\ntime typst compile patho.typ  --input N=2\n0.41user 0.10system 0:00.39elapsed 130%CPU (0avgtext+0avgdata 78108maxresident)k\ntime typst compile patho.typ  --input N=3\n0.77user 0.14system 0:00.58elapsed 156%CPU (0avgtext+0avgdata 107572maxresident)k\ntime typst compile patho.typ  --input N=4\n1.34user 0.19system 0:00.83elapsed 184%CPU (0avgtext+0avgdata 129604maxresident)k\ntime typst compile patho.typ  --input N=5\n2.05user 0.24system 0:01.11elapsed 207%CPU (0avgtext+0avgdata 150760maxresident)k\ntime typst compile patho.typ  --input N=6\n3.35user 0.34system 0:01.64elapsed 225%CPU (0avgtext+0avgdata 185552maxresident)k                                                     \n</code></pre>\n<p>Time is still scaling nonlinearlly.</p>",
      "raw": "[quote=\"bluss, post:2, topic:3585\"]\nWhere you use labels that delimit each page (you place them in header/footer so that they do). That is assuming of course that query before/after benefits from this.\n[/quote]\n\nThis page-start/end idea helps in the example, but only by increasing performance by 30% or so. It doesn't change the scaling of the issue I think so it's not a solution at all.\n\n\n\nI have some success now with the cache strategy. I think this 1) speeds it up massively, 2) changes scaling to be better(?). It's not blazingly fast, but it's much better.\n\nThe pars.len() == 0 case is unimplemented, it doesn't affect the example. But it needs to use the same cached datastructure too.\n\n\n<details>\n<summary>Code</summary>\n\n```typ\n// Helper Functions\n#let get-short(label, x) = {\n  let shorts = query(selector(label).before(x.location()))\n  return shorts.at(-1, default: none)\n}\n#let shorts-and-id(x) = {\n  let h1 = get-short(<h1-short>, x)\n  let h2 = get-short(<h2-short>, x)\n  return (h1: h1.value, h2: h2.value, id: x.value)\n}\n// Output assembly\n#let header-content(a, b) = {\n  return [#a.h1, #a.h2, Par. #a.id --- #b.h1, #b.h2, Par. #b.id]\n}\n\n// Return array. Index: page number. Value: Array of paragraph info on that page.\n#let shorts-per-page() = {\n    let pars = query(selector.or(<h4-start>, <h4-end>))\n    let d = ()\n    for par in pars {\n      let pg = par.location().page()\n      while d.len() <= pg { d.push(()) }\n      d.at(pg).push(shorts-and-id(par))\n    }\n    return d\n}\n\n#let cache = state(\"parscache\", none)\n\n\n// Actual Query\n#set page(\n  width: 120mm,\n  height: 100mm,\n  header: context {\n    let pg = here().page()\n    let cachedpars = cache.get()\n    if cachedpars == none {\n      cachedpars = shorts-per-page()\n      cache.update(_ => cachedpars)\n    }\n    let pars = cachedpars.at(pg, default: none)\n    if pars == none {\n      return\n    }\n    if pars.len() == 0 {\n      return\n    }\n    header-content(pars.first(), pars.at(-1, default: none))\n  }\n)\n\n// The Elements\n#let my-h1(short: none, ..args) = {\n  heading(level: 1, ..args)\n  [#metadata(short)<h1-short>]\n}\n#show heading.where(level: 1): it => {\n  pagebreak(weak: true)\n  it\n}\n#let my-h2(short: none, ..args) = {\n  heading(level: 2, ..args)\n  [#metadata(short)<h2-short>]\n}\n#let my-par(id: none, body) = text({\n  [#metadata([#id])<h4-start>]\n  if id != none {\n    heading(level: 4, id)\n  }\n  body\n  [#metadata([#id])<h4-end>]\n  hide(\"‚Äã\")\n})\n#show heading.where(level: 4): it => it.body + \" \"\n\n// ‚¨áÔ∏è Test Content (setting num-sections below to 1,2,3‚Ä¶6 should roughly lead to the results in my post)\n// Used chapter letters just for better overview in the example output\n// ABCDEFGHIJKLMNOPQRSTUVWXYZ\n#let chapter-letters = \"ABCDEFGH\"\n#let num-paragraphs-per-chapter = 25\n\n// use sys.inputs for command line parametrization\n#let s = 1\n#let num-sections = int(sys.inputs.at(\"N\", default: \"1\"))\n#while s <= num-sections {\n  my-h1(short: \"Section \" + [#s])[This is Section #s]\n  let c = 1\n  for letter in chapter-letters {\n    my-h2(short: \"Chap. \" + [#letter])[This is Chapter #letter]\n    let p = 1\n    while p <= num-paragraphs-per-chapter {\n      my-par(id: [#p], lorem(50))\n      p = p + 1\n    }\n  }\n  s = s + 1\n}\n```\n\n</details>\n\n\n<br>\n<br>\n\n\n```shell\ntime typst compile patho.typ  --input N=1\n0.20user 0.07system 0:00.27elapsed 105%CPU (0avgtext+0avgdata 54300maxresident)k\ntime typst compile patho.typ  --input N=2\n0.41user 0.10system 0:00.39elapsed 130%CPU (0avgtext+0avgdata 78108maxresident)k\ntime typst compile patho.typ  --input N=3\n0.77user 0.14system 0:00.58elapsed 156%CPU (0avgtext+0avgdata 107572maxresident)k\ntime typst compile patho.typ  --input N=4\n1.34user 0.19system 0:00.83elapsed 184%CPU (0avgtext+0avgdata 129604maxresident)k\ntime typst compile patho.typ  --input N=5\n2.05user 0.24system 0:01.11elapsed 207%CPU (0avgtext+0avgdata 150760maxresident)k\ntime typst compile patho.typ  --input N=6\n3.35user 0.34system 0:01.64elapsed 225%CPU (0avgtext+0avgdata 185552maxresident)k                                                     \n```\n\nTime is still scaling nonlinearlly.",
      "reply_to_post_number": 2,
      "reply_count": 1,
      "quote_count": 1,
      "like_count": 2,
      "reads": 33,
      "score": 46.6,
      "accepted_answer": true,
      "trust_level": 3,
      "user_id": 1272
    },
    {
      "id": 10930,
      "post_number": 8,
      "username": "a_w",
      "name": "Alex",
      "created_at": "2025-04-11T10:10:46.200Z",
      "updated_at": "2025-04-11T10:14:25.346Z",
      "cooked": "<p>I think you are not giving yourself enough credit, so I will: You‚Äôve just sped up the processing time by a couple of thousand percent <img src=\"https://forum.typst.app/images/emoji/apple/face_holding_back_tears.png?v=12\" title=\":face_holding_back_tears:\" class=\"emoji\" alt=\":face_holding_back_tears:\" loading=\"lazy\" width=\"20\" height=\"20\"> thanks so much! <img src=\"https://forum.typst.app/images/emoji/apple/pray.png?v=12\" title=\":pray:\" class=\"emoji\" alt=\":pray:\" loading=\"lazy\" width=\"20\" height=\"20\"> As you mention, it still scales nonlinearly, but it is WAY faster than before and actually compileable. Out of curiosity‚Ä¶ in <a href=\"https://github.com/typst/typst/issues/5220#issuecomment-2417525288\" rel=\"noopener nofollow ugc\">the issue</a> <a class=\"mention\" href=\"/u/laurmaedje\">@laurmaedje</a> mentioned‚Ä¶</p>\n<blockquote>\n<p>What you are most likely observing is a problem with incremental compilation where validating a cache hit is much more expensive than recomputing from scratch in some cases.</p>\n</blockquote>\n<p>Would this mean it could get even faster when switching the‚Ä¶</p>\n<pre data-code-wrap=\"typc\"><code class=\"lang-typc\">// Out of your code\nlet cachedpars = cache.get()\n\n// As in his example (slow)\n#for _ in range(n) {\n  context bar()\n}\n// vs. (faster)\n#for i in range(n) {\n  context bar(i)\n}\n</code></pre>\n<p>‚Ä¶for example every 10 or 20 pages?</p>",
      "raw": "I think you are not giving yourself enough credit, so I will: You've just sped up the processing time by a couple of thousand percent ü•π thanks so much! üôè As you mention, it still scales nonlinearly, but it is WAY faster than before and actually compileable. Out of curiosity‚Ä¶ in [the issue](https://github.com/typst/typst/issues/5220#issuecomment-2417525288) @laurmaedje mentioned‚Ä¶\n\n> What you are most likely observing is a problem with incremental compilation where validating a cache hit is much more expensive than recomputing from scratch in some cases.\n\nWould this mean it could get even faster when switching the‚Ä¶\n```typc\n// Out of your code\nlet cachedpars = cache.get()\n\n// As in his example (slow)\n#for _ in range(n) {\n  context bar()\n}\n// vs. (faster)\n#for i in range(n) {\n  context bar(i)\n}\n```\n‚Ä¶for example every 10 or 20 pages?",
      "reply_to_post_number": 7,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 1,
      "reads": 30,
      "score": 26.0,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 566
    },
    {
      "id": 10958,
      "post_number": 9,
      "username": "Andrew",
      "name": "",
      "created_at": "2025-04-12T11:52:10.330Z",
      "updated_at": "2025-04-12T12:01:48.780Z",
      "cooked": "<p>The syntax, especially for the loops, can be simplified to be more readable:</p>\n<details><summary>code</summary>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">// Helper Functions\n#let get-short(label, x) = {\n  query(selector(label).before(x.location())).at(-1, default: none)\n}\n#let shorts-and-id(x) = {\n  let h1 = get-short(&lt;h1-short&gt;, x)\n  let h2 = get-short(&lt;h2-short&gt;, x)\n  (h1: h1.value, h2: h2.value, id: x.value)\n}\n// Output assembly\n#let header-content(a, b) = {\n  [#a.h1, #a.h2, Par. #a.id --- #b.h1, #b.h2, Par. #b.id]\n}\n\n// Actual Query\n#let header = context {\n  let pars = query(selector.or(&lt;h4-start&gt;, &lt;h4-end&gt;))\n    .filter(x =&gt; x.location().page() == here().page())\n    .map(shorts-and-id)\n    .dedup()\n  if pars.len() != 0 {\n    return header-content(pars.first(), pars.at(-1, default: none))\n  }\n  // No paragraph starting or ending on this page\n  // -&gt; check if a paragraph starts before and ends after this page\n  let prevs = query(selector(&lt;h4-start&gt;).before(here()))\n  let nexts = query(selector(&lt;h4-end&gt;).after(here()))\n  if prevs.len() == 0 or nexts.len() == 0 { return }\n  let prev = shorts-and-id(prevs.last())\n  let next = shorts-and-id(nexts.first())\n  if prev != next { return }\n  header-content(prev, next)\n}\n\n#set page(width: 120mm, height: 100mm, header: header)\n\n// The Elements\n#let my-h1(short: none, ..args) = {\n  heading(level: 1, ..args)\n  [#metadata(short)&lt;h1-short&gt;]\n}\n#show heading.where(level: 1): it =&gt; pagebreak(weak: true) + it\n\n#let my-h2(short: none, ..args) = {\n  heading(level: 2, ..args)\n  [#metadata(short)&lt;h2-short&gt;]\n}\n\n#let my-par(id: none, body) = {\n  [#metadata[#id]&lt;h4-start&gt;]\n  if id != none { heading(level: 4, id) }\n  body\n  [#metadata[#id]&lt;h4-end&gt;]\n  hide(\"‚Äã\")\n}\n#show heading.where(level: 4): it =&gt; it.body + \" \"\n\n// ‚¨áÔ∏è Test Content (setting num-sections below to 1,2,3‚Ä¶6 should roughly lead to the results in my post)\n#let num-sections = 1\n// Used chapter letters just for better overview in the example output\n// ABCDEFGHIJKLMNOPQRSTUVWXYZ\n#let chapter-letters = \"ABCDEFGH\"\n#let num-paragraphs-per-chapter = 25\n\n#for s in range(1, num-sections + 1) {\n  my-h1(short: [Section #s])[This is Section #s]\n  for letter in chapter-letters {\n    my-h2(short: [Chap. #letter])[This is Chapter #letter]\n    for p in range(1, num-paragraphs-per-chapter + 1) {\n      my-par(id: [#p], lorem(50))\n    }\n  }\n}\n</code></pre>\n</details>\n<p>And for the last solution:</p>\n<details><summary>code</summary>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">// Helper Functions\n#let get-short(label, x) = {\n  query(selector(label).before(x.location())).at(-1, default: none)\n}\n#let shorts-and-id(x) = {\n  let h1 = get-short(&lt;h1-short&gt;, x)\n  let h2 = get-short(&lt;h2-short&gt;, x)\n  (h1: h1.value, h2: h2.value, id: x.value)\n}\n// Output assembly\n#let header-content(a, b) = {\n  [#a.h1, #a.h2, Par. #a.id --- #b.h1, #b.h2, Par. #b.id]\n}\n\n// Return array. Index: page number. Value: Array of paragraph info on that page.\n#let shorts-per-page() = {\n  let pars = query(selector.or(&lt;h4-start&gt;, &lt;h4-end&gt;))\n  let page-pars-array = ((),) * (counter(page).final().first() + 1)\n  for par in pars {\n    page-pars-array.at(par.location().page()).push(shorts-and-id(par))\n  }\n  page-pars-array\n}\n\n#let cache = state(\"parscache\", none)\n\n// Actual Query\n#let header = context {\n  let page = here().page()\n  let cachedpars = cache.get()\n  if cachedpars == none {\n    cachedpars = shorts-per-page()\n    cache.update(_ =&gt; cachedpars)\n  }\n  let pars = cachedpars.at(page, default: none)\n  if pars == none or pars.len() == 0 { return }\n  header-content(pars.first(), pars.at(-1, default: none))\n}\n\n#set page(width: 120mm, height: 100mm, header: header)\n\n// The Elements\n#let my-h1(short: none, ..args) = {\n  heading(level: 1, ..args)\n  [#metadata(short)&lt;h1-short&gt;]\n}\n#show heading.where(level: 1): it =&gt; pagebreak(weak: true) + it\n\n#let my-h2(short: none, ..args) = {\n  heading(level: 2, ..args)\n  [#metadata(short)&lt;h2-short&gt;]\n}\n\n#let my-par(id: none, body) = {\n  [#metadata[#id]&lt;h4-start&gt;]\n  if id != none { heading(level: 4, id) }\n  body\n  [#metadata[#id]&lt;h4-end&gt;]\n  hide(\"‚Äã\")\n}\n#show heading.where(level: 4): it =&gt; it.body + \" \"\n\n// ‚¨áÔ∏è Test Content (setting num-sections below to 1,2,3‚Ä¶6 should roughly lead to the results in my post)\n// Used chapter letters just for better overview in the example output\n// ABCDEFGHIJKLMNOPQRSTUVWXYZ\n#let chapter-letters = \"ABCDEFGH\"\n#let num-paragraphs-per-chapter = 25\n\n// Use sys.inputs for command line parametrization.\n#let num-sections = int(sys.inputs.at(\"N\", default: \"1\"))\n#for s in range(1, num-sections + 1) {\n  my-h1(short: [Section #s])[This is Section #s]\n  for letter in chapter-letters {\n    my-h2(short: [Chap. #letter])[This is Chapter #letter]\n    for p in range(1, num-paragraphs-per-chapter + 1) {\n      my-par(id: [#p], lorem(50))\n    }\n  }\n}\n</code></pre>\n</details>\n<p>However, from limited testing, this doesn‚Äôt affect performance.</p>\n<aside class=\"quote no-group quote-modified\" data-username=\"a_w\" data-post=\"8\" data-topic=\"3585\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/user_avatar/forum.typst.app/a_w/48/1206_2.png\" class=\"avatar\"> a_w:</div>\n<blockquote>\n<p>Would this mean it could get even faster when switching the‚Ä¶</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">// Out of your code\n#let cachedpars = cache.get()\n\n// As in his example (slow)\n#for _ in range(n) {\n  context bar()\n}\n// vs. (faster)\n#for i in range(n) {\n  context bar(i)\n}\n</code></pre>\n<p>‚Ä¶for example every 10 or 20 pages?</p>\n</blockquote>\n</aside>\n<p>Using a <code>bar(page)</code> for <code>cache.get()</code> doesn‚Äôt seem to make a difference, at least for 1 s runs.</p>\n<p>By the way, you should check out <a href=\"https://github.com/sharkdp/hyperfine\" rel=\"noopener nofollow ugc\"><code>hyperfine</code></a> for benchmarking and <code>--timings</code> <code>typst compile</code> flag.</p>\n<pre data-code-wrap=\"sh\"><code class=\"lang-sh\">hyperfine --warmup 1 'typst c file.typ'\n</code></pre>",
      "raw": "The syntax, especially for the loops, can be simplified to be more readable:\n\n<details><summary>code</summary>\n\n```typ\n// Helper Functions\n#let get-short(label, x) = {\n  query(selector(label).before(x.location())).at(-1, default: none)\n}\n#let shorts-and-id(x) = {\n  let h1 = get-short(<h1-short>, x)\n  let h2 = get-short(<h2-short>, x)\n  (h1: h1.value, h2: h2.value, id: x.value)\n}\n// Output assembly\n#let header-content(a, b) = {\n  [#a.h1, #a.h2, Par. #a.id --- #b.h1, #b.h2, Par. #b.id]\n}\n\n// Actual Query\n#let header = context {\n  let pars = query(selector.or(<h4-start>, <h4-end>))\n    .filter(x => x.location().page() == here().page())\n    .map(shorts-and-id)\n    .dedup()\n  if pars.len() != 0 {\n    return header-content(pars.first(), pars.at(-1, default: none))\n  }\n  // No paragraph starting or ending on this page\n  // -> check if a paragraph starts before and ends after this page\n  let prevs = query(selector(<h4-start>).before(here()))\n  let nexts = query(selector(<h4-end>).after(here()))\n  if prevs.len() == 0 or nexts.len() == 0 { return }\n  let prev = shorts-and-id(prevs.last())\n  let next = shorts-and-id(nexts.first())\n  if prev != next { return }\n  header-content(prev, next)\n}\n\n#set page(width: 120mm, height: 100mm, header: header)\n\n// The Elements\n#let my-h1(short: none, ..args) = {\n  heading(level: 1, ..args)\n  [#metadata(short)<h1-short>]\n}\n#show heading.where(level: 1): it => pagebreak(weak: true) + it\n\n#let my-h2(short: none, ..args) = {\n  heading(level: 2, ..args)\n  [#metadata(short)<h2-short>]\n}\n\n#let my-par(id: none, body) = {\n  [#metadata[#id]<h4-start>]\n  if id != none { heading(level: 4, id) }\n  body\n  [#metadata[#id]<h4-end>]\n  hide(\"‚Äã\")\n}\n#show heading.where(level: 4): it => it.body + \" \"\n\n// ‚¨áÔ∏è Test Content (setting num-sections below to 1,2,3‚Ä¶6 should roughly lead to the results in my post)\n#let num-sections = 1\n// Used chapter letters just for better overview in the example output\n// ABCDEFGHIJKLMNOPQRSTUVWXYZ\n#let chapter-letters = \"ABCDEFGH\"\n#let num-paragraphs-per-chapter = 25\n\n#for s in range(1, num-sections + 1) {\n  my-h1(short: [Section #s])[This is Section #s]\n  for letter in chapter-letters {\n    my-h2(short: [Chap. #letter])[This is Chapter #letter]\n    for p in range(1, num-paragraphs-per-chapter + 1) {\n      my-par(id: [#p], lorem(50))\n    }\n  }\n}\n```\n\n</details>\n\nAnd for the last solution:\n\n<details><summary>code</summary>\n\n```typ\n// Helper Functions\n#let get-short(label, x) = {\n  query(selector(label).before(x.location())).at(-1, default: none)\n}\n#let shorts-and-id(x) = {\n  let h1 = get-short(<h1-short>, x)\n  let h2 = get-short(<h2-short>, x)\n  (h1: h1.value, h2: h2.value, id: x.value)\n}\n// Output assembly\n#let header-content(a, b) = {\n  [#a.h1, #a.h2, Par. #a.id --- #b.h1, #b.h2, Par. #b.id]\n}\n\n// Return array. Index: page number. Value: Array of paragraph info on that page.\n#let shorts-per-page() = {\n  let pars = query(selector.or(<h4-start>, <h4-end>))\n  let page-pars-array = ((),) * (counter(page).final().first() + 1)\n  for par in pars {\n    page-pars-array.at(par.location().page()).push(shorts-and-id(par))\n  }\n  page-pars-array\n}\n\n#let cache = state(\"parscache\", none)\n\n// Actual Query\n#let header = context {\n  let page = here().page()\n  let cachedpars = cache.get()\n  if cachedpars == none {\n    cachedpars = shorts-per-page()\n    cache.update(_ => cachedpars)\n  }\n  let pars = cachedpars.at(page, default: none)\n  if pars == none or pars.len() == 0 { return }\n  header-content(pars.first(), pars.at(-1, default: none))\n}\n\n#set page(width: 120mm, height: 100mm, header: header)\n\n// The Elements\n#let my-h1(short: none, ..args) = {\n  heading(level: 1, ..args)\n  [#metadata(short)<h1-short>]\n}\n#show heading.where(level: 1): it => pagebreak(weak: true) + it\n\n#let my-h2(short: none, ..args) = {\n  heading(level: 2, ..args)\n  [#metadata(short)<h2-short>]\n}\n\n#let my-par(id: none, body) = {\n  [#metadata[#id]<h4-start>]\n  if id != none { heading(level: 4, id) }\n  body\n  [#metadata[#id]<h4-end>]\n  hide(\"‚Äã\")\n}\n#show heading.where(level: 4): it => it.body + \" \"\n\n// ‚¨áÔ∏è Test Content (setting num-sections below to 1,2,3‚Ä¶6 should roughly lead to the results in my post)\n// Used chapter letters just for better overview in the example output\n// ABCDEFGHIJKLMNOPQRSTUVWXYZ\n#let chapter-letters = \"ABCDEFGH\"\n#let num-paragraphs-per-chapter = 25\n\n// Use sys.inputs for command line parametrization.\n#let num-sections = int(sys.inputs.at(\"N\", default: \"1\"))\n#for s in range(1, num-sections + 1) {\n  my-h1(short: [Section #s])[This is Section #s]\n  for letter in chapter-letters {\n    my-h2(short: [Chap. #letter])[This is Chapter #letter]\n    for p in range(1, num-paragraphs-per-chapter + 1) {\n      my-par(id: [#p], lorem(50))\n    }\n  }\n}\n```\n\n</details>\n\nHowever, from limited testing, this doesn't affect performance.\n\n[quote=\"a_w, post:8, topic:3585\"]\nWould this mean it could get even faster when switching the‚Ä¶\n\n```typ\n// Out of your code\n#let cachedpars = cache.get()\n\n// As in his example (slow)\n#for _ in range(n) {\n  context bar()\n}\n// vs. (faster)\n#for i in range(n) {\n  context bar(i)\n}\n```\n\n‚Ä¶for example every 10 or 20 pages?\n[/quote]\n\nUsing a `bar(page)` for `cache.get()` doesn't seem to make a difference, at least for 1 s runs.\n\nBy the way, you should check out [`hyperfine`](https://github.com/sharkdp/hyperfine) for benchmarking and `--timings` `typst compile` flag.\n\n```sh\nhyperfine --warmup 1 'typst c file.typ'\n```",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 1,
      "like_count": 1,
      "reads": 29,
      "score": 25.8,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 51
    },
    {
      "id": 11049,
      "post_number": 10,
      "username": "a_w",
      "name": "Alex",
      "created_at": "2025-04-14T06:30:57.850Z",
      "updated_at": "2025-04-14T06:30:57.850Z",
      "cooked": "<p>Thank you for the refactoring, <a class=\"mention\" href=\"/u/andrew\">@Andrew</a>; I‚Äôve learned a couple of random shortcuts there too. I‚Äôve marked the answer of <a class=\"mention\" href=\"/u/bluss\">@bluss</a> as a solution, as everything else builds upon his cache strategy. Which I want to thank him for again; I can now compile the actual documents. It is still somewhat slow, but ~10 minutes is MUCH better than +5 hours (without finishing).</p>\n<p>And also thanks for the tip with hyperfine, <a class=\"mention\" href=\"/u/andrew\">@Andrew</a>, I‚Äôve checked it out. About the‚Ä¶</p>\n<aside class=\"quote no-group\" data-username=\"Andrew\" data-post=\"9\" data-topic=\"3585\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/user_avatar/forum.typst.app/andrew/48/62_2.png\" class=\"avatar\"> Andrew:</div>\n<blockquote>\n<p>Using a <code>bar(page)</code> for <code>cache.get()</code> doesn‚Äôt seem to make a difference, at least for 1 s runs.</p>\n</blockquote>\n</aside>\n<p>Can you show me how you tested it? I would like to try to fiddle with <code>--jobs</code> and the ‚Äúbusted‚Äù cache for the longer runs. My ‚Äúidea‚Äù (rather my understanding of what Laurenz said in the issue) would have been to try ‚Äúrecomputing from scratch‚Äù every couple of pages, but I don‚Äôt know WHEN validating the cache hit becomes more taxing than recomputing (so e.g. if it makes sense to recompute everytime or just after x pages).</p>",
      "raw": "Thank you for the refactoring, @Andrew; I've learned a couple of random shortcuts there too. I've marked the answer of @bluss as a solution, as everything else builds upon his cache strategy. Which I want to thank him for again; I can now compile the actual documents. It is still somewhat slow, but ~10 minutes is MUCH better than +5 hours (without finishing).\n\nAnd also thanks for the tip with hyperfine, @Andrew, I've checked it out. About the‚Ä¶\n\n[quote=\"Andrew, post:9, topic:3585\"]\nUsing a `bar(page)` for `cache.get()` doesn‚Äôt seem to make a difference, at least for 1 s runs.\n[/quote]\n\nCan you show me how you tested it? I would like to try to fiddle with `--jobs` and the \"busted\" cache for the longer runs. My \"idea\" (rather my understanding of what Laurenz said in the issue) would have been to try \"recomputing from scratch\" every couple of pages, but I don't know WHEN validating the cache hit becomes more taxing than recomputing (so e.g. if it makes sense to recompute everytime or just after x pages).",
      "reply_to_post_number": null,
      "reply_count": 3,
      "quote_count": 1,
      "like_count": 1,
      "reads": 27,
      "score": 35.4,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 566
    },
    {
      "id": 11056,
      "post_number": 11,
      "username": "bluss",
      "name": "Ulrik",
      "created_at": "2025-04-14T07:51:15.276Z",
      "updated_at": "2025-04-14T07:51:15.276Z",
      "cooked": "<aside class=\"quote no-group\" data-username=\"a_w\" data-post=\"10\" data-topic=\"3585\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/user_avatar/forum.typst.app/a_w/48/1206_2.png\" class=\"avatar\"> a_w:</div>\n<blockquote>\n<p>Which I want to thank him for again; I can now compile the actual documents.</p>\n</blockquote>\n</aside>\n<p>I‚Äôm happy that it helps! I didn‚Äôt realize you had documents that were even bigger than these examples, 10 minutes of compile time is still an insane scale of document <img src=\"https://forum.typst.app/images/emoji/apple/smile.png?v=12\" title=\":smile:\" class=\"emoji\" alt=\":smile:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>\n<p>I did some experiments in the direction of - what if you use different label names in different chapters of the document <code>&lt;h4-start-chapter1&gt;</code> and so on, but from early testing it seems like the count of each label type doesn‚Äôt matter, only the total number of labels or total count of pages where the query is used. (But maybe there is some kind of improvement that can be found?)</p>\n<p>I think that at this scale, every label and locatable element has some overhead, so it‚Äôs worth thinking about and testing every little detail.</p>",
      "raw": "[quote=\"a_w, post:10, topic:3585\"]\nWhich I want to thank him for again; I can now compile the actual documents.\n[/quote]\nI'm happy that it helps! I didn't realize you had documents that were even bigger than these examples, 10 minutes of compile time is still an insane scale of document :smile: \n\nI did some experiments in the direction of - what if you use different label names in different chapters of the document `<h4-start-chapter1>` and so on, but from early testing it seems like the count of each label type doesn't matter, only the total number of labels or total count of pages where the query is used. (But maybe there is some kind of improvement that can be found?)\n\nI think that at this scale, every label and locatable element has some overhead, so it's worth thinking about and testing every little detail.",
      "reply_to_post_number": 10,
      "reply_count": 0,
      "quote_count": 1,
      "like_count": 0,
      "reads": 27,
      "score": 5.4,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 1272
    },
    {
      "id": 11057,
      "post_number": 12,
      "username": "bluss",
      "name": "Ulrik",
      "created_at": "2025-04-14T07:54:36.586Z",
      "updated_at": "2025-04-14T07:54:36.586Z",
      "cooked": "<p>There might have been a small win if you - using Andrew‚Äôs code and function name - call it like <code>header(here().page())</code> and remove the here().page() lookup from the inside header function. I saw in timings that there was a small improvement that way. I would expect that the caching in a state variable we did solves most of the cache validation problem, but I don‚Äôt know.</p>",
      "raw": "There might have been a small win if you - using Andrew's code and function name - call it like `header(here().page())` and remove the here().page() lookup from the inside header function. I saw in timings that there was a small improvement that way. I would expect that the caching in a state variable we did solves most of the cache validation problem, but I don't know.",
      "reply_to_post_number": 10,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 1,
      "reads": 28,
      "score": 25.6,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 1272
    },
    {
      "id": 11178,
      "post_number": 13,
      "username": "Andrew",
      "name": "",
      "created_at": "2025-04-16T18:12:03.520Z",
      "updated_at": "2025-04-16T18:12:03.520Z",
      "cooked": "<aside class=\"quote no-group\" data-username=\"a_w\" data-post=\"10\" data-topic=\"3585\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/user_avatar/forum.typst.app/a_w/48/1206_2.png\" class=\"avatar\"> a_w:</div>\n<blockquote>\n<p>Can you show me how you tested it?</p>\n</blockquote>\n</aside>\n<p>I changed <code>let cachedpars = cache.get()</code> to <code>let cachedpars = bar(page)</code> with <code>let bar(_) = cache.get()</code> and run <code>hyperfine</code>.</p>",
      "raw": "[quote=\"a_w, post:10, topic:3585\"]\nCan you show me how you tested it?\n[/quote]\n\nI changed `let cachedpars = cache.get()` to `let cachedpars = bar(page)` with `let bar(_) = cache.get()` and run `hyperfine`.",
      "reply_to_post_number": 10,
      "reply_count": 1,
      "quote_count": 1,
      "like_count": 1,
      "reads": 23,
      "score": 24.6,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 51
    },
    {
      "id": 11204,
      "post_number": 14,
      "username": "a_w",
      "name": "Alex",
      "created_at": "2025-04-17T06:14:05.414Z",
      "updated_at": "2025-04-17T06:14:05.414Z",
      "cooked": "<aside class=\"quote no-group\" data-username=\"bluss\" data-post=\"12\" data-topic=\"3585\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/letter_avatar_proxy/v4/letter/b/441A5E/48.png\" class=\"avatar\"> bluss:</div>\n<blockquote>\n<p>I saw in timings that there was a small improvement that way.</p>\n</blockquote>\n</aside>\n<aside class=\"quote no-group\" data-username=\"Andrew\" data-post=\"13\" data-topic=\"3585\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/user_avatar/forum.typst.app/andrew/48/62_2.png\" class=\"avatar\"> Andrew:</div>\n<blockquote>\n<p>I changed <code>let cachedpars = cache.get()</code> to <code>let cachedpars = bar(page)</code> with <code>let bar(_) = cache.get()</code> and run <code>hyperfine</code>.</p>\n</blockquote>\n</aside>\n<p>Thank you <img src=\"https://forum.typst.app/images/emoji/apple/pray.png?v=12\" title=\":pray:\" class=\"emoji\" alt=\":pray:\" loading=\"lazy\" width=\"20\" height=\"20\"> I will test everything mentioned and report back.</p>",
      "raw": "[quote=\"bluss, post:12, topic:3585\"]\nI saw in timings that there was a small improvement that way.\n[/quote]\n\n[quote=\"Andrew, post:13, topic:3585\"]\nI changed `let cachedpars = cache.get()` to `let cachedpars = bar(page)` with `let bar(_) = cache.get()` and run `hyperfine`.\n[/quote]\n\nThank you üôè I will test everything mentioned and report back.",
      "reply_to_post_number": 13,
      "reply_count": 0,
      "quote_count": 2,
      "like_count": 0,
      "reads": 23,
      "score": 4.6,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 566
    },
    {
      "id": 11302,
      "post_number": 15,
      "username": "SillyFreak",
      "name": "SillyFreak",
      "created_at": "2025-04-18T20:19:47.691Z",
      "updated_at": "2025-04-18T20:19:47.691Z",
      "cooked": "<p>I played with this a bit as well, and <a class=\"mention\" href=\"/u/bluss\">@bluss</a>‚Äôs solution basically adds two big improvements: the caching, and removing the two queries</p>\n<aside class=\"quote no-group\" data-username=\"a_w\" data-post=\"1\" data-topic=\"3585\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/user_avatar/forum.typst.app/a_w/48/1206_2.png\" class=\"avatar\"> a_w:</div>\n<blockquote>\n<pre data-code-wrap=\"typc\"><code class=\"lang-typc\">      let prevs = query(selector(&lt;h4-start&gt;).before(here()))\n      let nexts = query(selector(&lt;h4-end&gt;).after(here()))\n</code></pre>\n</blockquote>\n</aside>\n<p>For me the runtime (real, N=3) goes from ~25.6s with the original code to ~10.7s without caching, only the additional queries removed, to ~0.5s with bluss‚Äôs code.</p>\n<p>This makes sense: even without caching, not performing these two queries per page (which are distinct due to the <code>before(here())</code> filter) will add up.</p>\n<p>So I tried to also get rid of the queries in <code>get-short</code>; that‚Äôs four queries per paragraph (<code>shorts-and-id()</code> performs two queries, and it‚Äôs called for both paragraph start and end). I ended up with the following <code>shorts-per-page()</code>:</p>\n<pre data-code-wrap=\"typc\"><code class=\"lang-typc\">// Return array. Index: page number. Value: Array of paragraph info on that page.\n#let shorts-per-page() = {\n    let elems = query(selector.or(&lt;h1-short&gt;, &lt;h2-short&gt;, &lt;h4-start&gt;, &lt;h4-end&gt;))\n\n    let h1 = none\n    let h2 = none\n    let d = ()\n    for elem in elems {\n      let lbl = elem.label\n      if lbl == &lt;h1-short&gt; { h1 = elem }\n      else if lbl == &lt;h2-short&gt; { h2 = elem }\n      else {\n        let pg = elem.location().page()\n        while d.len() &lt;= pg { d.push(()) }\n        d.at(pg).push((h1: h1.value, h2: h2.value, id: elem.value))\n      }\n    }\n\n    return d\n}\n</code></pre>\n<p>(The helpers are no longer needed.) Overall this means that Typst is now only running a single query per layout iteration ‚Äì just that that query has more results.</p>\n<p>This brought the runtime (real, N=10) from ~3.1s to ~2.1s. So the speedup is not as extreme as what bluss was already able to achieve, but it probably will still add up. <img src=\"https://forum.typst.app/images/emoji/apple/slight_smile.png?v=12\" title=\":slight_smile:\" class=\"emoji\" alt=\":slight_smile:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>",
      "raw": "I played with this a bit as well, and @bluss's solution basically adds two big improvements: the caching, and removing the two queries\n\n[quote=\"a_w, post:1, topic:3585\"]\n```typc\n      let prevs = query(selector(<h4-start>).before(here()))\n      let nexts = query(selector(<h4-end>).after(here()))\n```\n[/quote]\n\nFor me the runtime (real, N=3) goes from ~25.6s with the original code to ~10.7s without caching, only the additional queries removed, to ~0.5s with bluss's code.\n\nThis makes sense: even without caching, not performing these two queries per page (which are distinct due to the `before(here())` filter) will add up.\n\nSo I tried to also get rid of the queries in `get-short`; that's four queries per paragraph (`shorts-and-id()` performs two queries, and it's called for both paragraph start and end). I ended up with the following `shorts-per-page()`:\n\n```typc\n// Return array. Index: page number. Value: Array of paragraph info on that page.\n#let shorts-per-page() = {\n    let elems = query(selector.or(<h1-short>, <h2-short>, <h4-start>, <h4-end>))\n\n    let h1 = none\n    let h2 = none\n    let d = ()\n    for elem in elems {\n      let lbl = elem.label\n      if lbl == <h1-short> { h1 = elem }\n      else if lbl == <h2-short> { h2 = elem }\n      else {\n        let pg = elem.location().page()\n        while d.len() <= pg { d.push(()) }\n        d.at(pg).push((h1: h1.value, h2: h2.value, id: elem.value))\n      }\n    }\n\n    return d\n}\n```\n(The helpers are no longer needed.) Overall this means that Typst is now only running a single query per layout iteration -- just that that query has more results.\n\nThis brought the runtime (real, N=10) from ~3.1s to ~2.1s. So the speedup is not as extreme as what bluss was already able to achieve, but it probably will still add up. :slight_smile:",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 1,
      "like_count": 6,
      "reads": 20,
      "score": 99.0,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 32
    },
    {
      "id": 11561,
      "post_number": 16,
      "username": "a_w",
      "name": "Alex",
      "created_at": "2025-04-24T15:23:46.137Z",
      "updated_at": "2025-04-24T15:27:42.809Z",
      "cooked": "<p>The easter holidays delayed my tests a bit, but I want to begin with thanking <a class=\"mention\" href=\"/u/sillyfreak\">@SillyFreak</a> for his effort on top of the work of Andrew and bluss, thank you very much! <img src=\"https://forum.typst.app/images/emoji/apple/face_holding_back_tears.png?v=12\" title=\":face_holding_back_tears:\" class=\"emoji\" alt=\":face_holding_back_tears:\" loading=\"lazy\" width=\"20\" height=\"20\"><img src=\"https://forum.typst.app/images/emoji/apple/pray.png?v=12\" title=\":pray:\" class=\"emoji\" alt=\":pray:\" loading=\"lazy\" width=\"20\" height=\"20\"> Your solution cuts the rendering time almost in half again.</p>\n<p>Here is an overview of what I get in terms of real rendering time for one of my documents. I didn‚Äôt use <code>hyperfine</code> as I only did 1-2 runs each, because it still takes 1,5-2 Min. to render. So the following timings are the <code>total</code> time given by the <code>time</code> command on a M1 Max Mac.</p>\n<p><strong>1. Original version</strong><br>\nNot compilable (5h+)</p>\n<p><strong>2. Optimized version of Bluss</strong><br>\n2:34,80 total</p>\n<p><strong>3. Optimized version of SillyFreak</strong><br>\n1:21,97 total</p>\n<p><strong>4. Cache busting attempt</strong></p>\n<pre data-code-wrap=\"typc\"><code class=\"lang-typc\">let bar(_) = cache.get()\nlet cachedpars = bar(page)\n</code></pre>\n<p> ‚Üí No change</p>\n<p><strong>5. Moving Code to header() function</strong><br>\n ‚Üí Made it 5-6 seconds slower in my tests (probably ‚ÄúNo change‚Äù)</p>\n<p><strong>6. Removing heading page break</strong></p>\n<pre data-code-wrap=\"typc\"><code class=\"lang-typc\">#show heading.where(level: 1): it =&gt; {\n  pagebreak(weak: true)\n  it\n}\n</code></pre>\n<p> ‚Üí 1:13,24 total</p>\n<p><strong>7. Running on M2 instead of M1 Max</strong><br>\n ‚Üí 1:08,04 total</p>\n<p><strong>8. Rendering without any paragraph count</strong><br>\n ‚Üí 20,644 total</p>\n<p><strong>9. Removing ToC as well</strong><br>\n ‚Üí 19,830 total</p>\n<p><strong>10. Removing page numbers as well</strong><br>\n ‚Üí 9,683 total</p>\n<p><strong>11. --jobs=2 vs. --jobs=10</strong><br>\n ‚Üí No Change</p>\n<p>The biggest remaining levers were throwing more single-core performance on the problem and removing the default page break for level 1 headings. But we probably can‚Äôt expect more speed ups even if the memoization in comemo improves as the cache busting didn‚Äôt affect the compilation times. The query, page numbers and headline page break add about ~1:10 of overhead in total.</p>\n<p>But I can now render the documents! <img src=\"https://forum.typst.app/images/emoji/apple/partying_face.png?v=12\" title=\":partying_face:\" class=\"emoji\" alt=\":partying_face:\" loading=\"lazy\" width=\"20\" height=\"20\"> Thanks so much again to everyone involved.</p>",
      "raw": "The easter holidays delayed my tests a bit, but I want to begin with thanking @SillyFreak for his effort on top of the work of Andrew and bluss, thank you very much! ü•πüôè Your solution cuts the rendering time almost in half again.\n\nHere is an overview of what I get in terms of real rendering time for one of my documents. I didn't use `hyperfine` as I only did 1-2 runs each, because it still takes 1,5-2 Min. to render. So the following timings are the `total` time given by the `time` command on a M1 Max Mac.\n\n**1. Original version**\nNot compilable (5h+)\n\n**2. Optimized version of Bluss**\n2:34,80 total\n\n**3. Optimized version of SillyFreak**\n1:21,97 total\n\n**4. Cache busting attempt**\n```typc\nlet bar(_) = cache.get()\nlet cachedpars = bar(page)\n```\n-> No change\n\n**5. Moving Code to header() function**\n-> Made it 5-6 seconds slower in my tests (probably \"No change\")\n\n**6. Removing heading page break**\n```typc\n#show heading.where(level: 1): it => {\n  pagebreak(weak: true)\n  it\n}\n```\n-> 1:13,24 total\n\n**7. Running on M2 instead of M1 Max**\n-> 1:08,04 total\n\n**8. Rendering without any paragraph count**\n-> 20,644 total\n\n**9. Removing ToC as well**\n-> 19,830 total\n\n**10. Removing page numbers as well**\n-> 9,683 total\n\n**11. --jobs=2 vs. --jobs=10**\n-> No Change\n\nThe biggest remaining levers were throwing more single-core performance on the problem and removing the default page break for level 1 headings. But we probably can't expect more speed ups even if the memoization in comemo improves as the cache busting didn't affect the compilation times. The query, page numbers and headline page break add about ~1:10 of overhead in total.\n\nBut I can now render the documents! ü•≥ Thanks so much again to everyone involved.",
      "reply_to_post_number": 15,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 2,
      "reads": 17,
      "score": 68.4,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 566
    },
    {
      "id": 11569,
      "post_number": 17,
      "username": "Andrew",
      "name": "",
      "created_at": "2025-04-24T17:45:05.054Z",
      "updated_at": "2025-04-24T17:45:05.054Z",
      "cooked": "<pre data-code-wrap=\"sh\"><code class=\"lang-sh\">hyperfine --runs 2\n</code></pre>",
      "raw": "```sh\nhyperfine --runs 2\n```",
      "reply_to_post_number": 16,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 17,
      "score": 3.4,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 51
    }
  ],
  "scraped_at": "2025-06-10T09:49:28.399196"
}