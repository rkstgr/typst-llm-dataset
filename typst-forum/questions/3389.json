{
  "topic_metadata": {
    "id": 3389,
    "title": "How to text wrap inside a table cell?",
    "slug": "how-to-text-wrap-inside-a-table-cell",
    "posts_count": 11,
    "created_at": "2025-03-25T02:34:11.871Z",
    "last_posted_at": "2025-03-25T09:47:41.012Z",
    "views": 137,
    "like_count": 2,
    "reply_count": 5,
    "has_accepted_answer": true,
    "accepted_answer_post_number": 7,
    "accepted_answer_username": "Marius",
    "tags": [
      "tables"
    ],
    "category_id": 5,
    "participant_count": 4,
    "word_count": 1711
  },
  "posts": [
    {
      "id": 10202,
      "post_number": 1,
      "username": "Marius",
      "name": "Marius",
      "created_at": "2025-03-25T02:34:11.963Z",
      "updated_at": "2025-03-25T07:40:24.766Z",
      "cooked": "<p>I am struggling since several hours when trying to let words within a table cell wrap so that they don’t overlap the table cell’s width. I would appreciate any hint in the right direction.</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#set page(\n  width: 297mm,   // A4 landscape width\n  height: 210mm,  // A4 landscape height\n  margin: 10mm    // 10mm margin on all sides\n)\n\n#set text(size: 6pt)\n\n#let results = csv(\"example.csv\")\n\n// Filter to match the exact 14 columns\n#let expected-headers = (\n  \"id\", \"volume\", \"asset_group\", \"asset_id\", \"date\", \"source_type\", \n  \"gain_loss\", \"gain_loss_within_1_year\", \"gain_loss_ge_1_year\", \n  \"consumed_volumes\", \"years_passed_list\", \"consumed_ledger_ids\", \n  \"gain_loss_list\", \"source_reference\"\n)\n#let headers = results.at(0)  // Extract the first row as headers\n#let header-indices = headers.enumerate().filter(((i, h)) =&gt; expected-headers.contains(h)).map(((i, _)) =&gt; i)\n#let filtered-headers = expected-headers  // Use exact headers\n#let data = results.slice(1)  // Remaining rows as data\n#let filtered-data = data.map(row =&gt; header-indices.map(i =&gt; row.at(i)))\n\n// Adjusted table-columns for 14 columns, summing to ~277mm (297mm - 20mm margins)\n#let table-columns = (\n  15mm,  // id\n  20mm,  // volume\n  20mm,  // asset_group\n  20mm,  // asset_id\n  25mm,  // date\n  18mm,  // source_type\n  18mm,  // gain_loss\n  23mm,  // gain_loss_within_1_year\n  23mm,  // gain_loss_ge_1_year\n  20mm,  // consumed_volumes\n  20mm,  // years_passed_list\n  20mm,  // consumed_ledger_ids\n  20mm,  // gain_loss_list\n  15mm   // source_reference\n)  // Total: 277mm\n\n#let wrap-long-content(content) = {\n  // Debug: Log the type and raw content\n  let debug-prefix = \"TYPE: \" + type(content) + \" | \"\n  if type(content) == str {\n    // Debug: Confirm function is processing strings\n    let result = debug-prefix\n    // Handle timestamp-like strings\n    if content.match(regex(\"\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\+\\d{2}\")) != none {\n      let parts = content.split(\" \")\n      if parts.len() == 2 {\n        result += parts.at(0) + \"\\n\" + parts.at(1)\n        return result\n      }\n    }\n    // Handle empty or NULL arrays\n    if content == \"{}\" or content == \"{NULL}\" {\n      return result + \"\"\n    }\n    // Handle arrays (split on commas)\n    if content.starts-with(\"{\") and content.ends-with(\"}\") {\n      let trimmed = content.trim(\"{\", \"}\")\n      if trimmed.len() == 0 { return result + \"\" }\n      let parts = trimmed.split(\",\")\n      result += parts.join(\"\\n\")\n      return result\n    }\n    // Handle long strings with no spaces\n    if content.len() &gt; 10 and content.match(regex(\"\\s\")) == none {\n      let chars = content.clusters()\n      let broken = \"\"\n      for (i, c) in chars.enumerate() {\n        broken += c\n        if i &gt; 0 and calc.rem(i, 10) == 0 { broken += sym.zws }\n      }\n      result += broken\n      return result\n    }\n    return result + content\n  } else if type(content) == content {\n    if content.has(\"text\") {\n      return wrap-long-content(content.text)\n    }\n  }\n  // Fallback for non-string/non-text content\n  return debug-prefix + repr(content)\n}\n\n// General cell styling with wrapping\n#show table.cell: it =&gt; block(\n  width: 100%,\n  breakable: true,\n  inset: 2pt\n)[\n  #set text(hyphenate: true)\n  #box(width: 100%, wrap-long-content(it))\n]\n\n// Specific header row styling with forced breaking on underscores\n#show table.cell.where(y: 0): it =&gt; block(\n  width: 100%,\n  breakable: true,\n  inset: 2pt\n)[\n  #set text(hyphenate: true, size: 7pt, weight: \"bold\")\n  #let header-text = if type(it.body) == str { it.body } else if it.body.has(\"text\") { it.body.text } else { repr(it.body).trim(\"[]\") }\n  #box(width: 100%, header-text.replace(\"_\", \"_\\n\"))\n]\n\n#table(\n  columns: table-columns,\n  table.header(\n    ..filtered-headers.map(h =&gt; [#h]),  // Convert headers to content\n    repeat: true  // Ensure the header repeats on every page\n  ),\n  ..filtered-data.flatten()  // Flatten the filtered data rows\n)\n</code></pre>",
      "raw": "I am struggling since several hours when trying to let words within a table cell wrap so that they don't overlap the table cell's width. I would appreciate any hint in the right direction.\n\n```typ\n#set page(\n  width: 297mm,   // A4 landscape width\n  height: 210mm,  // A4 landscape height\n  margin: 10mm    // 10mm margin on all sides\n)\n\n#set text(size: 6pt)\n\n#let results = csv(\"example.csv\")\n\n// Filter to match the exact 14 columns\n#let expected-headers = (\n  \"id\", \"volume\", \"asset_group\", \"asset_id\", \"date\", \"source_type\", \n  \"gain_loss\", \"gain_loss_within_1_year\", \"gain_loss_ge_1_year\", \n  \"consumed_volumes\", \"years_passed_list\", \"consumed_ledger_ids\", \n  \"gain_loss_list\", \"source_reference\"\n)\n#let headers = results.at(0)  // Extract the first row as headers\n#let header-indices = headers.enumerate().filter(((i, h)) => expected-headers.contains(h)).map(((i, _)) => i)\n#let filtered-headers = expected-headers  // Use exact headers\n#let data = results.slice(1)  // Remaining rows as data\n#let filtered-data = data.map(row => header-indices.map(i => row.at(i)))\n\n// Adjusted table-columns for 14 columns, summing to ~277mm (297mm - 20mm margins)\n#let table-columns = (\n  15mm,  // id\n  20mm,  // volume\n  20mm,  // asset_group\n  20mm,  // asset_id\n  25mm,  // date\n  18mm,  // source_type\n  18mm,  // gain_loss\n  23mm,  // gain_loss_within_1_year\n  23mm,  // gain_loss_ge_1_year\n  20mm,  // consumed_volumes\n  20mm,  // years_passed_list\n  20mm,  // consumed_ledger_ids\n  20mm,  // gain_loss_list\n  15mm   // source_reference\n)  // Total: 277mm\n\n#let wrap-long-content(content) = {\n  // Debug: Log the type and raw content\n  let debug-prefix = \"TYPE: \" + type(content) + \" | \"\n  if type(content) == str {\n    // Debug: Confirm function is processing strings\n    let result = debug-prefix\n    // Handle timestamp-like strings\n    if content.match(regex(\"\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\+\\d{2}\")) != none {\n      let parts = content.split(\" \")\n      if parts.len() == 2 {\n        result += parts.at(0) + \"\\n\" + parts.at(1)\n        return result\n      }\n    }\n    // Handle empty or NULL arrays\n    if content == \"{}\" or content == \"{NULL}\" {\n      return result + \"\"\n    }\n    // Handle arrays (split on commas)\n    if content.starts-with(\"{\") and content.ends-with(\"}\") {\n      let trimmed = content.trim(\"{\", \"}\")\n      if trimmed.len() == 0 { return result + \"\" }\n      let parts = trimmed.split(\",\")\n      result += parts.join(\"\\n\")\n      return result\n    }\n    // Handle long strings with no spaces\n    if content.len() > 10 and content.match(regex(\"\\s\")) == none {\n      let chars = content.clusters()\n      let broken = \"\"\n      for (i, c) in chars.enumerate() {\n        broken += c\n        if i > 0 and calc.rem(i, 10) == 0 { broken += sym.zws }\n      }\n      result += broken\n      return result\n    }\n    return result + content\n  } else if type(content) == content {\n    if content.has(\"text\") {\n      return wrap-long-content(content.text)\n    }\n  }\n  // Fallback for non-string/non-text content\n  return debug-prefix + repr(content)\n}\n\n// General cell styling with wrapping\n#show table.cell: it => block(\n  width: 100%,\n  breakable: true,\n  inset: 2pt\n)[\n  #set text(hyphenate: true)\n  #box(width: 100%, wrap-long-content(it))\n]\n\n// Specific header row styling with forced breaking on underscores\n#show table.cell.where(y: 0): it => block(\n  width: 100%,\n  breakable: true,\n  inset: 2pt\n)[\n  #set text(hyphenate: true, size: 7pt, weight: \"bold\")\n  #let header-text = if type(it.body) == str { it.body } else if it.body.has(\"text\") { it.body.text } else { repr(it.body).trim(\"[]\") }\n  #box(width: 100%, header-text.replace(\"_\", \"_\\n\"))\n]\n\n#table(\n  columns: table-columns,\n  table.header(\n    ..filtered-headers.map(h => [#h]),  // Convert headers to content\n    repeat: true  // Ensure the header repeats on every page\n  ),\n  ..filtered-data.flatten()  // Flatten the filtered data rows\n)\n```",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 1,
      "reads": 29,
      "score": 455.8,
      "accepted_answer": false,
      "trust_level": 0,
      "user_id": 1384
    },
    {
      "id": 10209,
      "post_number": 2,
      "username": "gezepi",
      "name": "",
      "created_at": "2025-03-25T06:38:34.568Z",
      "updated_at": "2025-03-25T06:38:34.568Z",
      "cooked": "<p>Could you provide some data that exhibits the behavior you are running into?  It’s much easier to answer questions with a minimum working example (MWE).  Currently I can’t recreate your problem because compilation fails on the line <code>FILENAME</code> because the variable isn’t defined anywhere (plus I don’t have any data to display in the table).</p>",
      "raw": "Could you provide some data that exhibits the behavior you are running into?  It's much easier to answer questions with a minimum working example (MWE).  Currently I can't recreate your problem because compilation fails on the line `FILENAME` because the variable isn't defined anywhere (plus I don't have any data to display in the table).",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 26,
      "score": 25.2,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 326
    },
    {
      "id": 10210,
      "post_number": 3,
      "username": "Andrew",
      "name": "",
      "created_at": "2025-03-25T06:53:06.886Z",
      "updated_at": "2025-03-25T07:00:59.202Z",
      "cooked": "<p>A website that can be helpful: <a href=\"https://sscce.org\" rel=\"noopener nofollow ugc\">https://sscce.org</a>.</p>\n<hr>\n<p>The set page rule can be simplified like this:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#set page(flipped: true, margin: 1cm)\n</code></pre>\n<p>I suspect that you just need to use these:</p>\n<ul>\n<li><a href=\"https://typst.app/docs/reference/model/table/#parameters-inset\"><code>table.inset</code></a> or <a href=\"https://typst.app/docs/reference/model/table/#definitions-cell-inset\"><code>table.cell.inset</code></a></li>\n<li><a href=\"https://typst.app/docs/reference/model/par/#parameters-justify\"><code>par.justify</code></a></li>\n<li><a href=\"https://typst.app/docs/reference/text/text/#parameters-hyphenate\"><code>text.hyphenate</code></a></li>\n<li><a href=\"https://typst.app/docs/reference/text/text/#parameters-size\"><code>text.size</code></a></li>\n<li><a href=\"https://typst.app/docs/reference/text/text/#parameters-costs\"><code>text.costs</code></a></li>\n</ul>\n<p>The problem the way it’s phrased should be very trivial and the fact that there is so much code is very surprising.</p>",
      "raw": "A website that can be helpful: https://sscce.org.\n\n---\n\nThe set page rule can be simplified like this:\n\n```typ\n#set page(flipped: true, margin: 1cm)\n```\n\nI suspect that you just need to use these:\n- [`table.inset`](https://typst.app/docs/reference/model/table/#parameters-inset) or [`table.cell.inset`](https://typst.app/docs/reference/model/table/#definitions-cell-inset)\n- [`par.justify`](https://typst.app/docs/reference/model/par/#parameters-justify)\n- [`text.hyphenate`](https://typst.app/docs/reference/text/text/#parameters-hyphenate)\n- [`text.size`](https://typst.app/docs/reference/text/text/#parameters-size)\n- [`text.costs`](https://typst.app/docs/reference/text/text/#parameters-costs)\n\nThe problem the way it's phrased should be very trivial and the fact that there is so much code is very surprising.",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 0,
      "reads": 25,
      "score": 30.0,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 51
    },
    {
      "id": 10211,
      "post_number": 4,
      "username": "Marius",
      "name": "Marius",
      "created_at": "2025-03-25T07:25:13.455Z",
      "updated_at": "2025-03-25T07:35:16.134Z",
      "cooked": "<p>Thanks for your replies. My template code reflects multiple iterations with the Groke AI because I thought that would be the easiest to get quick results. For instance I would prefer to let the header rows auto-break on underscore but only got it working with the custom code for that. While I can live with that the cell overlapping is a real issue.</p>\n<p>I simplied the “<span class=\"hashtag-raw\">#set</span> page” part as suggested and adapted my filename placeholder so you can more easily reproduce.</p>\n<aside class=\"quote no-group quote-modified\" data-username=\"Andrew\" data-post=\"3\" data-topic=\"3389\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/user_avatar/forum.typst.app/andrew/48/62_2.png\" class=\"avatar\"> Andrew:</div>\n<blockquote>\n<p>I suspect that you just need to use these:</p>\n<ul>\n<li>[<code>table.inset</code> ] or [<code>table.cell.inset</code>]</li>\n<li>[<code>par.justify</code> ]</li>\n<li>[<code>text.hyphenate</code> ]</li>\n<li>[<code>text.size</code>]</li>\n<li>[<code>text.costs</code> ]</li>\n</ul>\n</blockquote>\n</aside>\n<p>I am afraid this only works well for natural words but not for identifiers like 3ddGwdKkUuUzcxwbMTXXooHMBMDKUieSmb69sRiZzdsVez7xfr2aJhopWk5fV3UvebuZ7vwhheCwzFB2Yx24S7hi.</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#set page(flipped: true, margin: 1cm)\n\n#set text(size: 6pt)\n\n#let results = csv(\"example.csv\")\n\n// Filter to match the exact 14 columns\n#let expected-headers = (\n  \"id\", \"volume\", \"asset_group\", \"asset_id\", \"date\", \"source_type\", \n  \"gain_loss\", \"gain_loss_within_1_year\", \"gain_loss_ge_1_year\", \n  \"consumed_volumes\", \"years_passed_list\", \"consumed_ledger_ids\", \n  \"gain_loss_list\", \"source_reference\"\n)\n#let headers = results.at(0)  // Extract the first row as headers\n#let header-indices = headers.enumerate().filter(((i, h)) =&gt; expected-headers.contains(h)).map(((i, _)) =&gt; i)\n#let filtered-headers = expected-headers  // Use exact headers\n#let data = results.slice(1)  // Remaining rows as data\n#let filtered-data = data.map(row =&gt; header-indices.map(i =&gt; row.at(i)))\n\n// Adjusted table-columns for 14 columns, summing to ~277mm (297mm - 20mm margins)\n#let table-columns = (\n  15mm,  // id\n  20mm,  // volume\n  20mm,  // asset_group\n  20mm,  // asset_id\n  25mm,  // date\n  18mm,  // source_type\n  18mm,  // gain_loss\n  23mm,  // gain_loss_within_1_year\n  23mm,  // gain_loss_ge_1_year\n  20mm,  // consumed_volumes\n  20mm,  // years_passed_list\n  20mm,  // consumed_ledger_ids\n  20mm,  // gain_loss_list\n  15mm   // source_reference\n)  // Total: 277mm\n\n#let wrap-long-content(content) = {\n  if type(content) == str {\n    // Handle timestamp-like strings\n    if content.match(regex(\"\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\+\\d{2}\")) != none {\n      let parts = content.split(\" \")\n      if parts.len() == 2 {\n        return parts.at(0) + \"\\n\" + parts.at(1)\n      }\n    }\n    // Handle empty or NULL arrays\n    if content == \"{}\" or content == \"{NULL}\" {\n      return \"\"\n    }\n    // Handle arrays (split on commas)\n    if content.starts-with(\"{\") and content.ends-with(\"}\") {\n      let trimmed = content.trim(\"{\", \"}\")\n      if trimmed.len() == 0 { return \"\" }\n      let parts = trimmed.split(\",\")\n      return parts.join(\"\\n\")\n    }\n    // Handle long strings with no spaces\n    if content.len() &gt; 10 and content.match(regex(\"\\s\")) == none {\n      let chars = content.clusters()\n      let broken = \"\"\n      for (i, c) in chars.enumerate() {\n        broken += c\n        if i &gt; 0 and calc.rem(i, 10) == 0 { broken += sym.zws }\n      }\n      return broken\n    }\n    return content\n  } else if type(content) == content {\n    if content.has(\"text\") {\n      return wrap-long-content(content.text)\n    }\n  }\n  // Fallback for non-string/non-text content\n  return content\n}\n\n// General cell styling with wrapping\n#show table.cell: it =&gt; block(\n  width: 100%,\n  breakable: true,\n  inset: 2pt\n)[\n  #set text(hyphenate: true)\n  #box(width: 100%, wrap-long-content(it))\n]\n\n// Specific header row styling with forced breaking on underscores\n#show table.cell.where(y: 0): it =&gt; block(\n  width: 100%,\n  breakable: true,\n  inset: 2pt\n)[\n  #set text(hyphenate: true, size: 7pt, weight: \"bold\")\n  #let header-text = if type(it.body) == str { it.body } else if it.body.has(\"text\") { it.body.text } else { repr(it.body).trim(\"[]\") }\n  #box(width: 100%, header-text.replace(\"_\", \"_\\n\"))\n]\n\n#table(\n  columns: table-columns,\n  table.header(\n    ..filtered-headers.map(h =&gt; [#h]),  // Convert headers to content\n    repeat: true  // Ensure the header repeats on every page\n  ),\n  ..filtered-data.flatten()  // Flatten the filtered data rows\n)\n</code></pre>\n<p>example.csv</p>\n<pre data-code-wrap=\"csv\"><code class=\"lang-csv\">id,volume,asset_group,asset_id,date,source_type,gain_loss,gain_loss_within_1_year,gain_loss_ge_1_year,consumed_volumes,years_passed_list,consumed_ledger_ids,gain_loss_list,source_reference\n530285709,121.0587935,abc,3ddGwdKkUuUzcxwbMTXXooHMBMDKUieSmb69sRiZzdsVez7xfr2aJhopWk5fV3UvebuZ7vwhheCwzFB2Yx24S7hi,2013-12-31 01:00:00+01,2,,0,0,{NULL},{NULL},{NULL},{NULL},3ddGwdKkUuUzcxwbMTXXooHMBMDKUieSmb69sRiZzdsVez7xfr2aJhopWk5fV3UvebuZ7vwhheCwzFB2Yx24S7hi\n</code></pre>\n<p>Renders to</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://forum.typst.app/uploads/default/original/2X/7/755d3806e5efd7b151f3a157f5997c2c3a24f802.png\" data-download-href=\"https://forum.typst.app/uploads/default/755d3806e5efd7b151f3a157f5997c2c3a24f802\" title=\"image\"><img src=\"https://forum.typst.app/uploads/default/optimized/2X/7/755d3806e5efd7b151f3a157f5997c2c3a24f802_2_690x71.png\" alt=\"image\" data-base62-sha1=\"gKfAeTcBMVvNtgyvz5t4h95pski\" width=\"690\" height=\"71\" srcset=\"https://forum.typst.app/uploads/default/optimized/2X/7/755d3806e5efd7b151f3a157f5997c2c3a24f802_2_690x71.png, https://forum.typst.app/uploads/default/optimized/2X/7/755d3806e5efd7b151f3a157f5997c2c3a24f802_2_1035x106.png 1.5x, https://forum.typst.app/uploads/default/optimized/2X/7/755d3806e5efd7b151f3a157f5997c2c3a24f802_2_1380x142.png 2x\" data-dominant-color=\"EDEDED\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">image</span><span class=\"informations\">3028×314 77.5 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>",
      "raw": "Thanks for your replies. My template code reflects multiple iterations with the Groke AI because I thought that would be the easiest to get quick results. For instance I would prefer to let the header rows auto-break on underscore but only got it working with the custom code for that. While I can live with that the cell overlapping is a real issue.\n\nI simplied the \"#set page\" part as suggested and adapted my filename placeholder so you can more easily reproduce.\n\n[quote=\"Andrew, post:3, topic:3389\"]\nI suspect that you just need to use these:\n\n* [`table.inset` ] or [`table.cell.inset`]\n* [`par.justify` ]\n* [`text.hyphenate` ]\n* [`text.size`]\n* [`text.costs` ]\n[/quote]\n\nI am afraid this only works well for natural words but not for identifiers like 3ddGwdKkUuUzcxwbMTXXooHMBMDKUieSmb69sRiZzdsVez7xfr2aJhopWk5fV3UvebuZ7vwhheCwzFB2Yx24S7hi.\n\n```typ\n#set page(flipped: true, margin: 1cm)\n\n#set text(size: 6pt)\n\n#let results = csv(\"example.csv\")\n\n// Filter to match the exact 14 columns\n#let expected-headers = (\n  \"id\", \"volume\", \"asset_group\", \"asset_id\", \"date\", \"source_type\", \n  \"gain_loss\", \"gain_loss_within_1_year\", \"gain_loss_ge_1_year\", \n  \"consumed_volumes\", \"years_passed_list\", \"consumed_ledger_ids\", \n  \"gain_loss_list\", \"source_reference\"\n)\n#let headers = results.at(0)  // Extract the first row as headers\n#let header-indices = headers.enumerate().filter(((i, h)) => expected-headers.contains(h)).map(((i, _)) => i)\n#let filtered-headers = expected-headers  // Use exact headers\n#let data = results.slice(1)  // Remaining rows as data\n#let filtered-data = data.map(row => header-indices.map(i => row.at(i)))\n\n// Adjusted table-columns for 14 columns, summing to ~277mm (297mm - 20mm margins)\n#let table-columns = (\n  15mm,  // id\n  20mm,  // volume\n  20mm,  // asset_group\n  20mm,  // asset_id\n  25mm,  // date\n  18mm,  // source_type\n  18mm,  // gain_loss\n  23mm,  // gain_loss_within_1_year\n  23mm,  // gain_loss_ge_1_year\n  20mm,  // consumed_volumes\n  20mm,  // years_passed_list\n  20mm,  // consumed_ledger_ids\n  20mm,  // gain_loss_list\n  15mm   // source_reference\n)  // Total: 277mm\n\n#let wrap-long-content(content) = {\n  if type(content) == str {\n    // Handle timestamp-like strings\n    if content.match(regex(\"\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\+\\d{2}\")) != none {\n      let parts = content.split(\" \")\n      if parts.len() == 2 {\n        return parts.at(0) + \"\\n\" + parts.at(1)\n      }\n    }\n    // Handle empty or NULL arrays\n    if content == \"{}\" or content == \"{NULL}\" {\n      return \"\"\n    }\n    // Handle arrays (split on commas)\n    if content.starts-with(\"{\") and content.ends-with(\"}\") {\n      let trimmed = content.trim(\"{\", \"}\")\n      if trimmed.len() == 0 { return \"\" }\n      let parts = trimmed.split(\",\")\n      return parts.join(\"\\n\")\n    }\n    // Handle long strings with no spaces\n    if content.len() > 10 and content.match(regex(\"\\s\")) == none {\n      let chars = content.clusters()\n      let broken = \"\"\n      for (i, c) in chars.enumerate() {\n        broken += c\n        if i > 0 and calc.rem(i, 10) == 0 { broken += sym.zws }\n      }\n      return broken\n    }\n    return content\n  } else if type(content) == content {\n    if content.has(\"text\") {\n      return wrap-long-content(content.text)\n    }\n  }\n  // Fallback for non-string/non-text content\n  return content\n}\n\n// General cell styling with wrapping\n#show table.cell: it => block(\n  width: 100%,\n  breakable: true,\n  inset: 2pt\n)[\n  #set text(hyphenate: true)\n  #box(width: 100%, wrap-long-content(it))\n]\n\n// Specific header row styling with forced breaking on underscores\n#show table.cell.where(y: 0): it => block(\n  width: 100%,\n  breakable: true,\n  inset: 2pt\n)[\n  #set text(hyphenate: true, size: 7pt, weight: \"bold\")\n  #let header-text = if type(it.body) == str { it.body } else if it.body.has(\"text\") { it.body.text } else { repr(it.body).trim(\"[]\") }\n  #box(width: 100%, header-text.replace(\"_\", \"_\\n\"))\n]\n\n#table(\n  columns: table-columns,\n  table.header(\n    ..filtered-headers.map(h => [#h]),  // Convert headers to content\n    repeat: true  // Ensure the header repeats on every page\n  ),\n  ..filtered-data.flatten()  // Flatten the filtered data rows\n)\n```\n\nexample.csv\n\n```csv\nid,volume,asset_group,asset_id,date,source_type,gain_loss,gain_loss_within_1_year,gain_loss_ge_1_year,consumed_volumes,years_passed_list,consumed_ledger_ids,gain_loss_list,source_reference\n530285709,121.0587935,abc,3ddGwdKkUuUzcxwbMTXXooHMBMDKUieSmb69sRiZzdsVez7xfr2aJhopWk5fV3UvebuZ7vwhheCwzFB2Yx24S7hi,2013-12-31 01:00:00+01,2,,0,0,{NULL},{NULL},{NULL},{NULL},3ddGwdKkUuUzcxwbMTXXooHMBMDKUieSmb69sRiZzdsVez7xfr2aJhopWk5fV3UvebuZ7vwhheCwzFB2Yx24S7hi\n```\n\nRenders to\n\n![image|690x71](upload://gKfAeTcBMVvNtgyvz5t4h95pski.png)",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 1,
      "like_count": 0,
      "reads": 24,
      "score": 14.8,
      "accepted_answer": false,
      "trust_level": 0,
      "user_id": 1384
    },
    {
      "id": 10212,
      "post_number": 5,
      "username": "quachpas",
      "name": "Pascal Quach",
      "created_at": "2025-03-25T07:40:01.429Z",
      "updated_at": "2025-03-25T07:41:27.618Z",
      "cooked": "<p>You can follow the answer at <a href=\"https://forum.typst.app/t/how-to-wrap-long-unbreakable-text-in-a-table-cell/1224/2\" class=\"inline-onebox\">How to wrap long \"unbreakable\" text in a table cell? - #2 by Eric</a> and use a regex to split the ID.</p>\n<hr>\n<p>P.S.: I have renamed your topic to “How to tex wrap inside a table cell?”, see</p>\n<aside class=\"quote no-group\" data-username=\"reknih\" data-post=\"1\" data-topic=\"11\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/user_avatar/forum.typst.app/reknih/48/3_2.png\" class=\"avatar\"><a href=\"https://forum.typst.app/t/how-to-post-in-the-questions-category/11/1\">How to post in the Questions category</a></div>\n<blockquote>\n<p><strong>Good titles are questions you would ask your friend about Typst.</strong></p>\n</blockquote>\n</aside>",
      "raw": "You can follow the answer at https://forum.typst.app/t/how-to-wrap-long-unbreakable-text-in-a-table-cell/1224/2?u=quachpas and use a regex to split the ID.\n\n----------------------------------\nP.S.: I have renamed your topic to \"How to tex wrap inside a table cell?\", see\n[quote=\"reknih, post:1, topic:11\"]\n**Good titles are questions you would ask your friend about Typst.**\n[/quote]",
      "reply_to_post_number": 4,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 0,
      "reads": 22,
      "score": 29.4,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 258
    },
    {
      "id": 10213,
      "post_number": 6,
      "username": "Marius",
      "name": "Marius",
      "created_at": "2025-03-25T07:45:12.601Z",
      "updated_at": "2025-03-25T07:45:12.601Z",
      "cooked": "<p>I am already giving long strings are special treatment</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let wrap-long-content(content) = {\n  if type(content) == str {\n    // Handle timestamp-like strings\n    if content.match(regex(\"\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\+\\d{2}\")) != none {\n      let parts = content.split(\" \")\n      if parts.len() == 2 {\n        return parts.at(0) + \"\\n\" + parts.at(1)\n      }\n    }\n    // Handle empty or NULL arrays\n    if content == \"{}\" or content == \"{NULL}\" {\n      return \"\"\n    }\n    // Handle arrays (split on commas)\n    if content.starts-with(\"{\") and content.ends-with(\"}\") {\n      let trimmed = content.trim(\"{\", \"}\")\n      if trimmed.len() == 0 { return \"\" }\n      let parts = trimmed.split(\",\")\n      return parts.join(\"\\n\")\n    }\n    // Handle long strings with no spaces\n    if content.len() &gt; 10 and content.match(regex(\"\\s\")) == none {\n      let chars = content.clusters()\n      let broken = \"\"\n      for (i, c) in chars.enumerate() {\n        broken += c\n        if i &gt; 0 and calc.rem(i, 10) == 0 { broken += sym.zws }\n      }\n      return broken\n    }\n    return content\n  } else if type(content) == content {\n    if content.has(\"text\") {\n      return wrap-long-content(content.text)\n    }\n  }\n  // Fallback for non-string/non-text content\n  return content\n}\n\n// General cell styling with wrapping\n#show table.cell: it =&gt; block(\n  width: 100%,\n  breakable: true,\n  inset: 2pt\n)[\n  #set text(hyphenate: true)\n  #box(width: 100%, wrap-long-content(it))\n]\n</code></pre>",
      "raw": "I am already giving long strings are special treatment\n\n```typ\n#let wrap-long-content(content) = {\n  if type(content) == str {\n    // Handle timestamp-like strings\n    if content.match(regex(\"\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\+\\d{2}\")) != none {\n      let parts = content.split(\" \")\n      if parts.len() == 2 {\n        return parts.at(0) + \"\\n\" + parts.at(1)\n      }\n    }\n    // Handle empty or NULL arrays\n    if content == \"{}\" or content == \"{NULL}\" {\n      return \"\"\n    }\n    // Handle arrays (split on commas)\n    if content.starts-with(\"{\") and content.ends-with(\"}\") {\n      let trimmed = content.trim(\"{\", \"}\")\n      if trimmed.len() == 0 { return \"\" }\n      let parts = trimmed.split(\",\")\n      return parts.join(\"\\n\")\n    }\n    // Handle long strings with no spaces\n    if content.len() > 10 and content.match(regex(\"\\s\")) == none {\n      let chars = content.clusters()\n      let broken = \"\"\n      for (i, c) in chars.enumerate() {\n        broken += c\n        if i > 0 and calc.rem(i, 10) == 0 { broken += sym.zws }\n      }\n      return broken\n    }\n    return content\n  } else if type(content) == content {\n    if content.has(\"text\") {\n      return wrap-long-content(content.text)\n    }\n  }\n  // Fallback for non-string/non-text content\n  return content\n}\n\n// General cell styling with wrapping\n#show table.cell: it => block(\n  width: 100%,\n  breakable: true,\n  inset: 2pt\n)[\n  #set text(hyphenate: true)\n  #box(width: 100%, wrap-long-content(it))\n]\n```",
      "reply_to_post_number": 5,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 22,
      "score": 4.4,
      "accepted_answer": false,
      "trust_level": 0,
      "user_id": 1384
    },
    {
      "id": 10214,
      "post_number": 7,
      "username": "Marius",
      "name": "Marius",
      "created_at": "2025-03-25T07:54:01.458Z",
      "updated_at": "2025-03-25T07:54:01.458Z",
      "cooked": "<p>this regex works good for me</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#show regex(\"[A-Za-z0-9]+\"): it =&gt; {\n  it.text.codepoints().join(sym.zws)\n}\n</code></pre>",
      "raw": "this regex works good for me\n\n```typ\n#show regex(\"[A-Za-z0-9]+\"): it => {\n  it.text.codepoints().join(sym.zws)\n}\n```",
      "reply_to_post_number": null,
      "reply_count": 2,
      "quote_count": 0,
      "like_count": 1,
      "reads": 20,
      "score": 64.0,
      "accepted_answer": true,
      "trust_level": 0,
      "user_id": 1384
    },
    {
      "id": 10215,
      "post_number": 8,
      "username": "quachpas",
      "name": "Pascal Quach",
      "created_at": "2025-03-25T07:55:27.562Z",
      "updated_at": "2025-03-25T07:55:27.562Z",
      "cooked": "<p>Don’t forget to tick the answer checkbox if you found an answer satisfying ;). This marks the topic as solved.</p>",
      "raw": "Don't forget to tick the answer checkbox if you found an answer satisfying ;). This marks the topic as solved.",
      "reply_to_post_number": 7,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 19,
      "score": 8.8,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 258
    },
    {
      "id": 10216,
      "post_number": 9,
      "username": "Marius",
      "name": "Marius",
      "created_at": "2025-03-25T08:09:38.651Z",
      "updated_at": "2025-03-25T08:09:45.883Z",
      "cooked": "<p>Allow me a follow-up question. When inserting sym.zws after each character selecting the whole string via double click does not work anymore which is different to behavior we are used to see on websites. Is there a workaround for that?</p>",
      "raw": "Allow me a follow-up question. When inserting sym.zws after each character selecting the whole string via double click does not work anymore which is different to behavior we are used to see on websites. Is there a workaround for that?",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 0,
      "reads": 18,
      "score": 8.6,
      "accepted_answer": false,
      "trust_level": 0,
      "user_id": 1384
    },
    {
      "id": 10220,
      "post_number": 10,
      "username": "Andrew",
      "name": "",
      "created_at": "2025-03-25T09:41:32.208Z",
      "updated_at": "2025-03-25T09:41:32.208Z",
      "cooked": "<p>A simpler regex would be <code>\\w+</code>, but it also matches letters/numbers from any script.</p>",
      "raw": "A simpler regex would be `\\w+`, but it also matches letters/numbers from any script.",
      "reply_to_post_number": 7,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 15,
      "score": 3.0,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 51
    },
    {
      "id": 10221,
      "post_number": 11,
      "username": "Andrew",
      "name": "",
      "created_at": "2025-03-25T09:47:41.012Z",
      "updated_at": "2025-03-25T09:48:13.693Z",
      "cooked": "<p>In Okular v24.12.3 selecting a whole line at a time works just fine.</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#show regex(\"\\w+\"): it =&gt; it.text.clusters().intersperse(sym.zws).join()\nsthciesatsctihascthiesathcsietahcstiehasctiheastchienastchiensatchiensatchieasnctiheasnctiheasntchieasntciheasnticheascitea\n</code></pre>\n<p>Oh, and also for some situations there is a difference between code points and code point clusters, so generally speaking <code>.clusters()</code> is superior, unless you specifically need to cut by code points.</p>",
      "raw": "In Okular v24.12.3 selecting a whole line at a time works just fine.\n\n```typ\n#show regex(\"\\w+\"): it => it.text.clusters().intersperse(sym.zws).join()\nsthciesatsctihascthiesathcsietahcstiehasctiheastchienastchiensatchiensatchieasnctiheasnctiheasntchieasntciheasnticheascitea\n```\n\nOh, and also for some situations there is a difference between code points and code point clusters, so generally speaking `.clusters()` is superior, unless you specifically need to cut by code points.",
      "reply_to_post_number": 9,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 15,
      "score": 3.0,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 51
    }
  ],
  "scraped_at": "2025-06-10T09:50:04.641657"
}