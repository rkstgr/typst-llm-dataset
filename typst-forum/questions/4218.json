{
  "topic_metadata": {
    "id": 4218,
    "title": "Why is my random shuffle always producing the same result when using Suiji?",
    "slug": "why-is-my-random-shuffle-always-producing-the-same-result-when-using-suiji",
    "posts_count": 10,
    "created_at": "2025-05-22T06:55:57.049Z",
    "last_posted_at": "2025-05-23T05:24:05.389Z",
    "views": 113,
    "like_count": 10,
    "reply_count": 7,
    "has_accepted_answer": true,
    "accepted_answer_post_number": 6,
    "accepted_answer_username": "SillyFreak",
    "tags": [
      "scripting",
      "suiji"
    ],
    "category_id": 5,
    "participant_count": 4,
    "word_count": 1481
  },
  "posts": [
    {
      "id": 12922,
      "post_number": 1,
      "username": "Daniel",
      "name": "Daniel Cook",
      "created_at": "2025-05-22T06:55:57.191Z",
      "updated_at": "2025-05-22T20:20:33.028Z",
      "cooked": "<p>I’m really stuck with this. I’d like to have a function that will randomize some options, but no matter how I go about it the randomization from suiji doesn’t seem to work quite randomly. To be more specific, all of the calls to the function result in the same randomization. What is expected is that each call to the function will have a different result.</p>\n<p>How can I have a different random list each call to the function?</p>\n<pre data-code-wrap=\"typst\"><code class=\"lang-typst\">#import \"@preview/suiji:0.4.0\": *\n\n#let rng = gen-rng(1)\n\n#let randomize(options) = {\n  (_ , options) = shuffle(rng, options)\n  options.join(\", \")\n}\n\n#let options = (\"A\", \"B\", \"C\", \"D\")\n  \n#randomize(options)\n\n#randomize(options)\n\n#randomize(options)\n\n#randomize(options)\n\n#randomize(options)\n\n</code></pre>\n<p>Results in</p>\n<p>D, B, C, A (repeated five times)</p>",
      "raw": "I'm really stuck with this. I'd like to have a function that will randomize some options, but no matter how I go about it the randomization from suiji doesn't seem to work quite randomly. To be more specific, all of the calls to the function result in the same randomization. What is expected is that each call to the function will have a different result.\n\nHow can I have a different random list each call to the function?\n\n```typst\n#import \"@preview/suiji:0.4.0\": *\n\n#let rng = gen-rng(1)\n\n#let randomize(options) = {\n  (_ , options) = shuffle(rng, options)\n  options.join(\", \")\n}\n\n#let options = (\"A\", \"B\", \"C\", \"D\")\n  \n#randomize(options)\n\n#randomize(options)\n\n#randomize(options)\n\n#randomize(options)\n\n#randomize(options)\n\n```\n\nResults in \n\nD, B, C, A (repeated five times)",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 40,
      "score": 83.0,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 94
    },
    {
      "id": 12925,
      "post_number": 2,
      "username": "gezepi",
      "name": "",
      "created_at": "2025-05-22T07:56:03.138Z",
      "updated_at": "2025-05-22T07:56:03.138Z",
      "cooked": "<p>Because each function in Typst is purely functional, there can’t be any state internal to the function (it can’t remember anything).  This means we need to give different arguments if we want different outputs (in this case different orderings).<br>\nEach time Suiji generates a random number it takes the <code>rng</code> value and also returns a new value that needs to be stored.  Then that new value is passed into the next function to use randomness.</p>\n<p>You code becomes:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#import \"@preview/suiji:0.4.0\": *\n\n#let rng = gen-rng(1)\n\n#let randomize(options-arg, rng-arg) = {\n  let (rng-local , options-local) = shuffle(rng-arg, options-arg)\n  (rng-local, options-local.join(\", \"))\n}\n\n#let options = (\"A\", \"B\", \"C\", \"D\")\n\n#let (rng, output) = randomize(options, rng)\n#output\n\n#let (rng, output) = randomize(options, rng)\n#output\n\n#let (rng, output) = randomize(options, rng)\n#output\n\n#let (rng, output) = randomize(options, rng)\n#output\n\n#let (rng, output) = randomize(options, rng)\n#output\n</code></pre>\n<p>Results in:</p>\n<pre><code class=\"lang-plaintext\">D, B, C, A\nC, B, D, A\nC, D, B, A\nB, C, A, D\nD, A, C, B\n</code></pre>",
      "raw": "Because each function in Typst is purely functional, there can't be any state internal to the function (it can't remember anything).  This means we need to give different arguments if we want different outputs (in this case different orderings).\nEach time Suiji generates a random number it takes the `rng` value and also returns a new value that needs to be stored.  Then that new value is passed into the next function to use randomness.\n\nYou code becomes:\n```\n#import \"@preview/suiji:0.4.0\": *\n\n#let rng = gen-rng(1)\n\n#let randomize(options-arg, rng-arg) = {\n  let (rng-local , options-local) = shuffle(rng-arg, options-arg)\n  (rng-local, options-local.join(\", \"))\n}\n\n#let options = (\"A\", \"B\", \"C\", \"D\")\n\n#let (rng, output) = randomize(options, rng)\n#output\n\n#let (rng, output) = randomize(options, rng)\n#output\n\n#let (rng, output) = randomize(options, rng)\n#output\n\n#let (rng, output) = randomize(options, rng)\n#output\n\n#let (rng, output) = randomize(options, rng)\n#output\n```\nResults in:\n```text\nD, B, C, A\nC, B, D, A\nC, D, B, A\nB, C, A, D\nD, A, C, B\n```",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 3,
      "reads": 40,
      "score": 103.0,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 326
    },
    {
      "id": 12927,
      "post_number": 3,
      "username": "Daniel",
      "name": "Daniel Cook",
      "created_at": "2025-05-22T08:29:43.367Z",
      "updated_at": "2025-05-22T08:29:43.367Z",
      "cooked": "<p>This is a good explanation, thank you!</p>\n<p>My use case for this is for a package, and a user wouldn’t be able to manage handling <code>rng</code> constantly. I’ve tried to deal with this using <code>state</code> but if there are a number of calls to the function then it doesn’t resolve after a while (resulting in repeats).</p>\n<p>Do you happen to know if there is some way to update state?</p>\n<p>Here is what I tried (I realize the nested expression isn’t necessary, but you get the idea):</p>\n<pre data-code-wrap=\"typst\"><code class=\"lang-typst\">#import \"@preview/suiji:0.4.0\": *\n\n#let rng = state(\"rng\", gen-rng(1))\n\n#let randomize(options) = {\n  context {\n    let _rng = none\n    let _options = none\n    (_rng, _options) = shuffle(rng.get(), options)\n    rng.update(_rng)\n    _options.join(\",\")\n  }\n}\n\n#let options = (\"A\", \"B\", \"C\", \"D\")\n  \n#randomize(options)\n\n#randomize(options)\n\n#randomize(options)\n\n#randomize(options)\n\n#randomize(options)\n\n#randomize(options)\n\n#randomize(options)\n</code></pre>",
      "raw": "This is a good explanation, thank you! \n\nMy use case for this is for a package, and a user wouldn't be able to manage handling `rng` constantly. I've tried to deal with this using `state` but if there are a number of calls to the function then it doesn't resolve after a while (resulting in repeats). \n\nDo you happen to know if there is some way to update state? \n\nHere is what I tried (I realize the nested expression isn't necessary, but you get the idea):\n\n```typst\n#import \"@preview/suiji:0.4.0\": *\n\n#let rng = state(\"rng\", gen-rng(1))\n\n#let randomize(options) = {\n  context {\n    let _rng = none\n    let _options = none\n    (_rng, _options) = shuffle(rng.get(), options)\n    rng.update(_rng)\n    _options.join(\",\")\n  }\n}\n\n#let options = (\"A\", \"B\", \"C\", \"D\")\n  \n#randomize(options)\n\n#randomize(options)\n\n#randomize(options)\n\n#randomize(options)\n\n#randomize(options)\n\n#randomize(options)\n\n#randomize(options)\n```",
      "reply_to_post_number": 2,
      "reply_count": 3,
      "quote_count": 0,
      "like_count": 0,
      "reads": 39,
      "score": 22.8,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 94
    },
    {
      "id": 12930,
      "post_number": 4,
      "username": "gezepi",
      "name": "",
      "created_at": "2025-05-22T09:28:02.698Z",
      "updated_at": "2025-05-22T09:28:02.698Z",
      "cooked": "<p>I remember reading recently in an answer on the forum that using both <code>get()</code> and <code>update()</code> on a state in one context is not ideal.  I tried searching for the post that I am vaguely remembering but didn’t find it.</p>\n<p>I see in the <a href=\"https://typst.app/docs/reference/introspection/state/\">state page</a> of the documents that <code>update()</code> can be given a function that:</p>\n<blockquote>\n<p>receives the previous state and has to return the new state.</p>\n</blockquote>\n<p>After some trial-and-error I ended up with the following.  It stores the most recent ordering of <code>options</code> in the state with <code>rng</code> (as an array).</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#import \"@preview/suiji:0.4.0\": *\n\n#let options = (\"A\", \"B\", \"C\", \"D\")\n#let rng-and-options = state(\"rng\", (gen-rng(1), options))\n\n#let randomize(rng-and-options-local) = context {\n  rng-and-options-local.update((current) =&gt; {\n    let (rng-cur, options-cur) = current\n    let (rng-new, options-new) = shuffle(rng-cur, options-cur)\n  \n    let new-state = (rng-new, options-new)\n    return new-state\n  })\n  rng-and-options-local.get().at(1).join(\", \")\n}\n\n#for _ in range(10) [\n  #randomize(rng-and-options)\n  #linebreak()\n]\n</code></pre>\n<p>Because the state is a parameter of the function, you can create a second set of options (and state):</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let options2 = (\"A\", \"B\", \"C\", \"D\", \"E\")\n#let rng-and-options2 = state(\"rng\", (gen-rng(1), options2))\n</code></pre>\n<p>And call the <code>randomize()</code> function with either of the states.</p>",
      "raw": "I remember reading recently in an answer on the forum that using both `get()` and `update()` on a state in one context is not ideal.  I tried searching for the post that I am vaguely remembering but didn't find it.\n\nI see in the [state page](https://typst.app/docs/reference/introspection/state/) of the documents that `update()` can be given a function that:\n> receives the previous state and has to return the new state.\n\nAfter some trial-and-error I ended up with the following.  It stores the most recent ordering of `options` in the state with `rng` (as an array).\n```\n#import \"@preview/suiji:0.4.0\": *\n\n#let options = (\"A\", \"B\", \"C\", \"D\")\n#let rng-and-options = state(\"rng\", (gen-rng(1), options))\n\n#let randomize(rng-and-options-local) = context {\n  rng-and-options-local.update((current) => {\n    let (rng-cur, options-cur) = current\n    let (rng-new, options-new) = shuffle(rng-cur, options-cur)\n  \n    let new-state = (rng-new, options-new)\n    return new-state\n  })\n  rng-and-options-local.get().at(1).join(\", \")\n}\n\n#for _ in range(10) [\n  #randomize(rng-and-options)\n  #linebreak()\n]\n```\nBecause the state is a parameter of the function, you can create a second set of options (and state):\n```\n#let options2 = (\"A\", \"B\", \"C\", \"D\", \"E\")\n#let rng-and-options2 = state(\"rng\", (gen-rng(1), options2))\n```\nAnd call the `randomize()` function with either of the states.",
      "reply_to_post_number": 3,
      "reply_count": 2,
      "quote_count": 0,
      "like_count": 1,
      "reads": 39,
      "score": 32.8,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 326
    },
    {
      "id": 12932,
      "post_number": 5,
      "username": "SillyFreak",
      "name": "SillyFreak",
      "created_at": "2025-05-22T09:40:51.199Z",
      "updated_at": "2025-05-22T09:40:51.199Z",
      "cooked": "<p>I think what <a class=\"mention\" href=\"/u/gezepi\">@gezepi</a> recommended is fundamentally the only way to do it usefully.</p>\n<p>The problem you have with state is layout convergence, see this post for details: <a href=\"https://forum.typst.app/t/why-is-state-final-not-final/1483\" class=\"inline-onebox\">Why is State Final not \"final\"?</a> In that thread I suggest a solution that, applied to your situation, would look roughly like this:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let rng = state(\"rng\", (gen-rng(1), none))\n\n#let randomize(options) = {\n  rng.update(((rng, _)) =&gt; shuffle(rng, options))\n  context rng.get().last()\n}\n</code></pre>\n<p>The <code>rng</code> state now contains the actual rng and the most recent result. The update is not done through a get…update cascade, so that’s good!</p>\n<p><em>However</em>, this function doesn’t give you an array; it gives you content: <a href=\"https://forum.typst.app/t/why-is-the-value-i-receive-from-context-always-content/164/2\" class=\"inline-onebox\">Why is the value I receive from context always content? - #2 by laurmaedje</a> The typical way around this is to pull the <code>context</code> keyword out:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let rng = state(\"rng\", (gen-rng(1), none))\n\n#let randomize(options) = {\n  rng.update(((rng, _)) =&gt; shuffle(rng, options))\n  rng.get().last()\n}\n\n...\n\n#context randomize(options)\n</code></pre>\n<p>But in this case that also doesn’t work: <code>randomize()</code> uses <code>update()</code>, and an update itself <em>is</em> content. So unless you really only need to output the randomized array (in which case content is fine), that’s also not a full solution. If that’s all you need, <a class=\"mention\" href=\"/u/gezepi\">@gezepi</a>’s second post (or my first snippet) gives you an answer.</p>\n<p>Assuming you want to use the randomized array further down, you’ll need to separate the update from the result, e.g. like this:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let randomize(options) = {\n  rng.update(((rng, _)) =&gt; shuffle(rng, options))\n}\n#let get-randomized() = {\n  rng.get().last()\n}\n\n...\n\n#randomize(options)\n#context get-randomized()\n</code></pre>\n<p>… but imo then you’re basically in the same situation as at the start, where you had to handle the rng variable (instead of the state update) separately on each call.</p>",
      "raw": "I think what @gezepi recommended is fundamentally the only way to do it usefully.\n\nThe problem you have with state is layout convergence, see this post for details: https://forum.typst.app/t/why-is-state-final-not-final/1483?u=sillyfreak In that thread I suggest a solution that, applied to your situation, would look roughly like this:\n\n```\n#let rng = state(\"rng\", (gen-rng(1), none))\n\n#let randomize(options) = {\n  rng.update(((rng, _)) => shuffle(rng, options))\n  context rng.get().last()\n}\n```\nThe `rng` state now contains the actual rng and the most recent result. The update is not done through a get...update cascade, so that's good!\n\n_However_, this function doesn't give you an array; it gives you content: https://forum.typst.app/t/why-is-the-value-i-receive-from-context-always-content/164/2?u=sillyfreak The typical way around this is to pull the `context` keyword out:\n\n```\n#let rng = state(\"rng\", (gen-rng(1), none))\n\n#let randomize(options) = {\n  rng.update(((rng, _)) => shuffle(rng, options))\n  rng.get().last()\n}\n\n...\n\n#context randomize(options)\n```\n\nBut in this case that also doesn't work: `randomize()` uses `update()`, and an update itself _is_ content. So unless you really only need to output the randomized array (in which case content is fine), that's also not a full solution. If that's all you need, @gezepi's second post (or my first snippet) gives you an answer.\n\nAssuming you want to use the randomized array further down, you'll need to separate the update from the result, e.g. like this:\n\n```\n#let randomize(options) = {\n  rng.update(((rng, _)) => shuffle(rng, options))\n}\n#let get-randomized() = {\n  rng.get().last()\n}\n\n...\n\n#randomize(options)\n#context get-randomized()\n```\n\n... but imo then you're basically in the same situation as at the start, where you had to handle the rng variable (instead of the state update) separately on each call.",
      "reply_to_post_number": 3,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 1,
      "reads": 36,
      "score": 27.2,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 32
    },
    {
      "id": 12933,
      "post_number": 6,
      "username": "SillyFreak",
      "name": "SillyFreak",
      "created_at": "2025-05-22T09:43:53.871Z",
      "updated_at": "2025-05-22T09:43:53.871Z",
      "cooked": "<p>Actually I just had one more idea that I’ll put separately; using callbacks:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let rng = state(\"rng\", (gen-rng(1), none))\n\n#let randomize(options, callback) = {\n  rng.update(((rng, _)) =&gt; shuffle(rng, options))\n  context callback(rng.get().last())\n}\n\n#let options = (\"A\", \"B\", \"C\", \"D\")\n\n#randomize(options, shuffled =&gt; [#shuffled])\n\n#randomize(options, shuffled =&gt; [#shuffled])\n</code></pre>\n<p>This lets you make a single <code>randomize</code> call and hides the random handling, but it requires you to put everything that depends on the random result in a callback. This probably becomes annoying when you need multiple random things at the same time (meaning you have nested callbacks).</p>",
      "raw": "Actually I just had one more idea that I'll put separately; using callbacks:\n\n```\n#let rng = state(\"rng\", (gen-rng(1), none))\n\n#let randomize(options, callback) = {\n  rng.update(((rng, _)) => shuffle(rng, options))\n  context callback(rng.get().last())\n}\n\n#let options = (\"A\", \"B\", \"C\", \"D\")\n\n#randomize(options, shuffled => [#shuffled])\n\n#randomize(options, shuffled => [#shuffled])\n```\n\nThis lets you make a single `randomize` call and hides the random handling, but it requires you to put everything that depends on the random result in a callback. This probably becomes annoying when you need multiple random things at the same time (meaning you have nested callbacks).",
      "reply_to_post_number": 3,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 2,
      "reads": 32,
      "score": 41.4,
      "accepted_answer": true,
      "trust_level": 3,
      "user_id": 32
    },
    {
      "id": 12934,
      "post_number": 7,
      "username": "Daniel",
      "name": "Daniel Cook",
      "created_at": "2025-05-22T09:47:52.862Z",
      "updated_at": "2025-05-22T09:47:52.862Z",
      "cooked": "<p>Wow. There’s a lot here, and I know its a complicated problem because of the limitations of state.<br>\nI’ll take a look and try to flesh out some of your suggestions to see if they’ll work with what I have in mind.</p>\n<p>I can’t say thank you enough!</p>",
      "raw": "Wow. There's a lot here, and I know its a complicated problem because of the limitations of state.\nI'll take a look and try to flesh out some of your suggestions to see if they'll work with what I have in mind. \n\nI can't say thank you enough!",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 1,
      "reads": 31,
      "score": 51.2,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 94
    },
    {
      "id": 12935,
      "post_number": 8,
      "username": "SillyFreak",
      "name": "SillyFreak",
      "created_at": "2025-05-22T09:49:38.149Z",
      "updated_at": "2025-05-22T09:49:38.149Z",
      "cooked": "<aside class=\"quote no-group quote-modified\" data-username=\"gezepi\" data-post=\"4\" data-topic=\"4218\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/letter_avatar_proxy/v4/letter/g/C34CE0/48.png\" class=\"avatar\"> gezepi:</div>\n<blockquote>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let randomize(rng-and-options-local) = context {\n  rng-and-options-local.update(...)\n  rng-and-options-local.get().at(1).join(\", \")\n}\n</code></pre>\n</blockquote>\n</aside>\n<p>Note that there’s a slight difference between our suggestions, <a class=\"mention\" href=\"/u/gezepi\">@gezepi</a>. You have a <code>context</code> around the whole function, while I only wrap <code>get()</code>. That makes a difference! Context is frozen when a <code>context</code> expression starts, so your <code>get()</code> will actually retrieve the value <em>before</em> randomizing. Note how the first line you print contains “A, B, C, D” and not something random.</p>",
      "raw": "[quote=\"gezepi, post:4, topic:4218\"]\n```\n#let randomize(rng-and-options-local) = context {\n  rng-and-options-local.update(...)\n  rng-and-options-local.get().at(1).join(\", \")\n}\n```\n[/quote]\n\nNote that there's a slight difference between our suggestions, @gezepi. You have a `context` around the whole function, while I only wrap `get()`. That makes a difference! Context is frozen when a `context` expression starts, so your `get()` will actually retrieve the value _before_ randomizing. Note how the first line you print contains \"A, B, C, D\" and not something random.",
      "reply_to_post_number": 4,
      "reply_count": 0,
      "quote_count": 1,
      "like_count": 1,
      "reads": 32,
      "score": 21.4,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 32
    },
    {
      "id": 12955,
      "post_number": 9,
      "username": "Andrew",
      "name": "",
      "created_at": "2025-05-22T15:43:37.470Z",
      "updated_at": "2025-05-22T15:43:37.470Z",
      "cooked": "<aside class=\"quote no-group\" data-username=\"gezepi\" data-post=\"4\" data-topic=\"4218\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/letter_avatar_proxy/v4/letter/g/C34CE0/48.png\" class=\"avatar\"> gezepi:</div>\n<blockquote>\n<p>I remember reading recently in an answer on the forum that using both <code>get()</code> and <code>update()</code> on a state in one context is not ideal. I tried searching for the post that I am vaguely remembering but didn’t find it.</p>\n</blockquote>\n</aside>\n<p>Here you go: <a href=\"https://forum.typst.app/t/how-to-keep-exercise-and-solution-together-in-source-but-render-them-separately/3999/3\" class=\"inline-onebox\">How to keep exercise and solution together in source, but render them separately? - #3 by Andrew</a>.</p>",
      "raw": "[quote=\"gezepi, post:4, topic:4218\"]\nI remember reading recently in an answer on the forum that using both `get()` and `update()` on a state in one context is not ideal. I tried searching for the post that I am vaguely remembering but didn’t find it.\n[/quote]\n\nHere you go: https://forum.typst.app/t/how-to-keep-exercise-and-solution-together-in-source-but-render-them-separately/3999/3?u=andrew.",
      "reply_to_post_number": 4,
      "reply_count": 0,
      "quote_count": 1,
      "like_count": 1,
      "reads": 30,
      "score": 21.0,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 51
    },
    {
      "id": 12998,
      "post_number": 10,
      "username": "Daniel",
      "name": "Daniel Cook",
      "created_at": "2025-05-23T05:24:05.389Z",
      "updated_at": "2025-05-23T05:24:05.389Z",
      "cooked": "<p>After hashing this out a bit with my use case, I’m going to mark this as a solution.</p>\n<p>There are a few other caveats:</p>\n<ol>\n<li>Nesting these will result in non-convergence.</li>\n<li>If there are multiple steps or multiple arrays that need to be shuffled/etc, it is possible. It seems the best way is to have a nested function that does all of the randomization necessary step by step. I have one use case that takes two arrays of options, both arrays have to go through suiji <span class=\"hashtag-raw\">#choice</span>, then combined together for a shuffle. Doing those steps all together and keeping the intermittent arrays stored in state works. An alternative is to store a dictionary as the state and reference the keys later post callback.</li>\n</ol>\n<p>So, it seems to work. I have yet to modify my project but it looks like it will work out. This does make for a different structure/approach for code (i.e. you basically have to make the randomization the last thing and so everything else should be done first).</p>",
      "raw": "After hashing this out a bit with my use case, I'm going to mark this as a solution.\n\nThere are a few other caveats:\n\n1. Nesting these will result in non-convergence.\n2. If there are multiple steps or multiple arrays that need to be shuffled/etc, it is possible. It seems the best way is to have a nested function that does all of the randomization necessary step by step. I have one use case that takes two arrays of options, both arrays have to go through suiji #choice, then combined together for a shuffle. Doing those steps all together and keeping the intermittent arrays stored in state works. An alternative is to store a dictionary as the state and reference the keys later post callback.\n\nSo, it seems to work. I have yet to modify my project but it looks like it will work out. This does make for a different structure/approach for code (i.e. you basically have to make the randomization the last thing and so everything else should be done first).",
      "reply_to_post_number": 6,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 26,
      "score": 5.2,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 94
    }
  ],
  "scraped_at": "2025-06-10T09:47:27.545136"
}