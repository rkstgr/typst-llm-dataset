{
  "topic_metadata": {
    "id": 3296,
    "title": "How do I count elements on a page so the result isn't always zero in the header?",
    "slug": "how-do-i-count-elements-on-a-page-so-the-result-isnt-always-zero-in-the-header",
    "posts_count": 7,
    "created_at": "2025-03-17T10:58:32.875Z",
    "last_posted_at": "2025-03-18T08:46:52.203Z",
    "views": 65,
    "like_count": 5,
    "reply_count": 2,
    "has_accepted_answer": true,
    "accepted_answer_post_number": 4,
    "accepted_answer_username": "bluss",
    "tags": [
      "scripting",
      "layout"
    ],
    "category_id": 5,
    "participant_count": 4,
    "word_count": 977
  },
  "posts": [
    {
      "id": 9907,
      "post_number": 1,
      "username": "a_w",
      "name": "Alex",
      "created_at": "2025-03-17T10:58:33.273Z",
      "updated_at": "2025-03-17T13:00:25.423Z",
      "cooked": "<p>Hello <img src=\"https://forum.typst.app/images/emoji/apple/smiling_face.png?v=12\" title=\":smiling_face:\" class=\"emoji\" alt=\":smiling_face:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>\n<p>I‚Äôm trying to count elements on a page to give an overview of which of those can be found on a given page, next to the page number in the header.</p>\n<p>This is my current approach:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#set page(width:50mm, height: 50mm)\n#let v = counter(\"verse\")\n\n#show strong: it =&gt; {\n  v.step()\n  it\n}\n\n#set page(\n  header: {\n    v.update(0)\n    context v.display()\n  },\n  footer: context v.display(),\n)\n\n*1.* Strophe \\\n*2.* Strophe \\\n*3.* Strophe \\\n*4.* Strophe\n#pagebreak()\n*1.* Strophe \\\n*2.* Strophe \\\n*3.* Strophe\n</code></pre>\n<p>The result in the header is, somewhat expected, always zero, because it apparently gets drawn before the page content and context are updated. Is there a trick to ‚Äúdelay‚Äù the rendering of the header, re-render it or use location context (<code>.at()</code> in some way‚Ä¶ unfortunately I couldn‚Äôt get it to work with a label at the end of each page as these would be duplicates) so the correct amount of occurrences on the current page is shown? Or am I maybe tackling the problem not in the best possible way altogether?</p>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://forum.typst.app/uploads/default/original/2X/8/8e6781b10ccf281bcc531666b9676ee32e476d3b.png\" data-download-href=\"https://forum.typst.app/uploads/default/8e6781b10ccf281bcc531666b9676ee32e476d3b\" title=\"problem\"><img src=\"https://forum.typst.app/uploads/default/optimized/2X/8/8e6781b10ccf281bcc531666b9676ee32e476d3b_2_252x500.png\" alt=\"problem\" data-base62-sha1=\"kjLySYmQ6myjtYJTspuPnYVACef\" width=\"252\" height=\"500\" srcset=\"https://forum.typst.app/uploads/default/optimized/2X/8/8e6781b10ccf281bcc531666b9676ee32e476d3b_2_252x500.png, https://forum.typst.app/uploads/default/optimized/2X/8/8e6781b10ccf281bcc531666b9676ee32e476d3b_2_378x750.png 1.5x, https://forum.typst.app/uploads/default/original/2X/8/8e6781b10ccf281bcc531666b9676ee32e476d3b.png 2x\" data-dominant-color=\"F5F3F4\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">problem</span><span class=\"informations\">498√ó988 62.1 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div><br>\n(Comments in red)</p>",
      "raw": "Hello ‚ò∫Ô∏è\n\nI'm trying to count elements on a page to give an overview of which of those can be found on a given page, next to the page number in the header.\n\nThis is my current approach:\n```typ\n#set page(width:50mm, height: 50mm)\n#let v = counter(\"verse\")\n\n#show strong: it => {\n  v.step()\n  it\n}\n\n#set page(\n  header: {\n    v.update(0)\n    context v.display()\n  },\n  footer: context v.display(),\n)\n\n*1.* Strophe \\\n*2.* Strophe \\\n*3.* Strophe \\\n*4.* Strophe\n#pagebreak()\n*1.* Strophe \\\n*2.* Strophe \\\n*3.* Strophe\n```\n\nThe result in the header is, somewhat expected, always zero, because it apparently gets drawn before the page content and context are updated. Is there a trick to \"delay\" the rendering of the header, re-render it or use location context (`.at()` in some way‚Ä¶ unfortunately I couldn't get it to work with a label at the end of each page as these would be duplicates) so the correct amount of occurrences on the current page is shown? Or am I maybe tackling the problem not in the best possible way altogether?\n\n![problem|252x500](upload://kjLySYmQ6myjtYJTspuPnYVACef.png)\n(Comments in red)",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 28,
      "score": 100.6,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 566
    },
    {
      "id": 9921,
      "post_number": 2,
      "username": "janekfleper",
      "name": "Janek Fleper",
      "created_at": "2025-03-17T13:17:18.710Z",
      "updated_at": "2025-03-17T13:18:32.745Z",
      "cooked": "<p>If you are willing to change your general approach a bit, I have a solution for you.</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#set page(width:50mm, height: 50mm)\n#set heading(numbering: \"1.\")\n\n#let count-headings(level: 1) = {\n  let locations = query(heading.where(level: level)).map(h =&gt; h.location())\n  locations.filter(loc =&gt; loc.page() == here().page()).len()\n}\n\n#set page(\n  header: context count-headings(level: 1),\n  footer: context count-headings(level: 1),\n)\n\n= Strophe\n= Strophe\n= Strophe\n= Strophe\n\n#pagebreak()\n#counter(heading).update(0)\n= Strophe\n= Strophe\n= Strophe\n</code></pre>\n<p>Using headings as the ‚ÄúStrophen‚Äù allows you to <a href=\"https://typst.app/docs/reference/introspection/query/\"><code>query()</code></a> them. You can then just check if they are located on the current page to count them. I just used level 1 headings as an example here. There might be something that is more suitable for your case, this really depends on the rest of the document and also your preference. According to <a href=\"https://typst.app/docs/reference/introspection/location/#locatable\">location</a>, <code>*strong*</code> elements would also locatable but only if they have a label associated with them.</p>",
      "raw": "If you are willing to change your general approach a bit, I have a solution for you.\n\n```typ\n#set page(width:50mm, height: 50mm)\n#set heading(numbering: \"1.\")\n\n#let count-headings(level: 1) = {\n  let locations = query(heading.where(level: level)).map(h => h.location())\n  locations.filter(loc => loc.page() == here().page()).len()\n}\n\n#set page(\n  header: context count-headings(level: 1),\n  footer: context count-headings(level: 1),\n)\n\n= Strophe\n= Strophe\n= Strophe\n= Strophe\n\n#pagebreak()\n#counter(heading).update(0)\n= Strophe\n= Strophe\n= Strophe\n```\n\nUsing headings as the \"Strophen\" allows you to [`query()`](https://typst.app/docs/reference/introspection/query/) them. You can then just check if they are located on the current page to count them. I just used level 1 headings as an example here. There might be something that is more suitable for your case, this really depends on the rest of the document and also your preference. According to [location](https://typst.app/docs/reference/introspection/location/#locatable), `*strong*` elements would also locatable but only if they have a label associated with them.",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 1,
      "reads": 25,
      "score": 30.0,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 69
    },
    {
      "id": 9927,
      "post_number": 3,
      "username": "a_w",
      "name": "Alex",
      "created_at": "2025-03-17T14:59:49.072Z",
      "updated_at": "2025-03-17T14:59:49.072Z",
      "cooked": "<p>Thanks, Janek! I‚Äôm glad the solution isn‚Äôt as obvious as I feared it could be <img src=\"https://forum.typst.app/images/emoji/apple/smile.png?v=12\" title=\":smile:\" class=\"emoji\" alt=\":smile:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>\n<p>Do you think a custom function like <span class=\"hashtag-raw\">#verse</span><span class=\"chcklst-box fa fa-square-o fa-fw\"></span> could also be made locateable?</p>\n<p>This way all the headlines wouldn‚Äôt ‚Äúmess up‚Äù the source when actual strongs or emphasis is used in the text. And, more important, in my case: I wouldn‚Äôt have block level elements because in reality I actually have:</p>\n<pre data-code-wrap=\"txt\"><code class=\"lang-txt\">1. Strophe Text 2. Strophe Text\n</code></pre>\n<p>instead of</p>\n<pre data-code-wrap=\"txt\"><code class=\"lang-txt\">1. Strophe Text\n2. Strophe Text\n</code></pre>\n<p>and in terms of syntax highlighting it would also make more sense</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">= 1. Strophe with *strong* and _emphasis_\nvs.\n#verse[1. Strophe with *strong* and _emphasis_]\n</code></pre>\n<p>I just tried using labels, but since they need to be unique I couldn‚Äôt get it to work.</p>",
      "raw": "Thanks, Janek! I'm glad the solution isn't as obvious as I feared it could be üòÑ\n\nDo you think a custom function like #verse[] could also be made locateable?\n\nThis way all the headlines wouldn't \"mess up\" the source when actual strongs or emphasis is used in the text. And, more important, in my case: I wouldn't have block level elements because in reality I actually have: \n\n```txt\n1. Strophe Text 2. Strophe Text\n```\ninstead of\n```txt\n1. Strophe Text\n2. Strophe Text\n```\nand in terms of syntax highlighting it would also make more sense\n```typ\n= 1. Strophe with *strong* and _emphasis_\nvs.\n#verse[1. Strophe with *strong* and _emphasis_]\n```\n\nI just tried using labels, but since they need to be unique I couldn't get it to work.",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 0,
      "reads": 22,
      "score": 9.4,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 566
    },
    {
      "id": 9929,
      "post_number": 4,
      "username": "bluss",
      "name": "Ulrik",
      "created_at": "2025-03-17T15:15:56.171Z",
      "updated_at": "2025-03-17T15:52:09.223Z",
      "cooked": "<p>If I‚Äôm just playing with it, it seems to work in sandbox to use page end labels, just giving each a unique name using <code>here().page()</code> (‚Äúphysical‚Äù page number). This experiment is missing the nice display of the counter, but the count is correct‚Ä¶</p>\n<pre data-code-wrap=\"typst\"><code class=\"lang-typst\">#set page(width:50mm, height: 50mm)\n#let v = counter(\"verse\")\n\n#show strong: it =&gt; {\n  v.step()\n  it\n}\n\n#set page(\n  header: {\n    v.update(0)\n    context v.at(label(\"page_end\" + str(here().page())))\n  },\n  footer: context {\n    [#v.at(here())]\n    [[]#label(\"page_end\" + str(here().page()))]\n  }\n)\n\n*1.* Strophe \\\n*2.* Strophe \\\n*3.* Strophe \\\n*4.* Strophe\n#pagebreak()\n*1.* Strophe \\\n*2.* Strophe \\\n*3.* Strophe\n\n</code></pre>",
      "raw": "If I'm just playing with it, it seems to work in sandbox to use page end labels, just giving each a unique name using `here().page()` (\"physical\" page number). This experiment is missing the nice display of the counter, but the count is correct..\n\n```typst\n#set page(width:50mm, height: 50mm)\n#let v = counter(\"verse\")\n\n#show strong: it => {\n  v.step()\n  it\n}\n\n#set page(\n  header: {\n    v.update(0)\n    context v.at(label(\"page_end\" + str(here().page())))\n  },\n  footer: context {\n    [#v.at(here())]\n    [[]#label(\"page_end\" + str(here().page()))]\n  }\n)\n\n*1.* Strophe \\\n*2.* Strophe \\\n*3.* Strophe \\\n*4.* Strophe\n#pagebreak()\n*1.* Strophe \\\n*2.* Strophe \\\n*3.* Strophe\n\n```",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 1,
      "reads": 22,
      "score": 29.4,
      "accepted_answer": true,
      "trust_level": 3,
      "user_id": 1272
    },
    {
      "id": 9930,
      "post_number": 5,
      "username": "gezepi",
      "name": "",
      "created_at": "2025-03-17T15:44:52.983Z",
      "updated_at": "2025-03-17T15:44:52.983Z",
      "cooked": "<p>The value returned by <code>v.at(...)</code> is an array of one <code>int</code>.  Adding <a href=\"https://typst.app/docs/reference/foundations/array/#definitions-first\"><code>.first()</code></a> makes the formatting a bit nicer:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">//...\n  header: {\n    v.update(0)\n    context v.at(label(\"page_end\" + str(here().page()))).first()\n  },\n//...\n</code></pre>\n<p>The footer also needs the change.</p>",
      "raw": "The value returned by `v.at(...)` is an array of one `int`.  Adding [`.first()`](https://typst.app/docs/reference/foundations/array/#definitions-first) makes the formatting a bit nicer:\n```typ\n//...\n  header: {\n    v.update(0)\n    context v.at(label(\"page_end\" + str(here().page()))).first()\n  },\n//...\n```\nThe footer also needs the change.",
      "reply_to_post_number": 4,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 21,
      "score": 4.2,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 326
    },
    {
      "id": 9931,
      "post_number": 6,
      "username": "a_w",
      "name": "Alex",
      "created_at": "2025-03-17T16:45:07.250Z",
      "updated_at": "2025-03-17T16:51:28.640Z",
      "cooked": "<p>Nice! The <code>label(\"page_end\" + str(here().page()))</code> is precisely what I couldn‚Äôt get to work, cause I always ended up with duplicate labels without including the page number.</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#set page(width:50mm, height: 50mm)\n#let v = counter(\"verse\")\n\n#show strong: it =&gt; {\n  v.step()\n  it\n}\n\n#set page(\n  header: {\n    v.update(0)\n    context v.at(label(\"page_end\" + str(here().page()))).first()\n  },\n  footer: context {\n    [#v.at(here()).first()]\n    [#hide([])#label(\"page_end\" + str(here().page()).first())]\n  }\n)\n\n*1.* Strophe \\\n*2.* Strophe \\\n*3.* Strophe \\\n*4.* Strophe\n#pagebreak()\n*1.* Strophe \\\n*2.* Strophe \\\n*3.* Strophe\n</code></pre>\n<p>The <code>#hide([])</code> is of course super hacky‚Ä¶ but‚Ä¶ it seems to work! <img src=\"https://forum.typst.app/images/emoji/apple/face_holding_back_tears.png?v=12\" title=\":face_holding_back_tears:\" class=\"emoji\" alt=\":face_holding_back_tears:\" loading=\"lazy\" width=\"20\" height=\"20\"></p>",
      "raw": "Nice! The `label(\"page_end\" + str(here().page()))` is precisely what I couldn't get to work, cause I always ended up with duplicate labels without including the page number.\n\n```typ\n#set page(width:50mm, height: 50mm)\n#let v = counter(\"verse\")\n\n#show strong: it => {\n  v.step()\n  it\n}\n\n#set page(\n  header: {\n    v.update(0)\n    context v.at(label(\"page_end\" + str(here().page()))).first()\n  },\n  footer: context {\n    [#v.at(here()).first()]\n    [#hide([])#label(\"page_end\" + str(here().page()).first())]\n  }\n)\n\n*1.* Strophe \\\n*2.* Strophe \\\n*3.* Strophe \\\n*4.* Strophe\n#pagebreak()\n*1.* Strophe \\\n*2.* Strophe \\\n*3.* Strophe\n```\n\nThe `#hide([])` is of course super hacky‚Ä¶ but‚Ä¶ it seems to work! ü•π",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 1,
      "reads": 19,
      "score": 18.8,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 566
    },
    {
      "id": 9942,
      "post_number": 7,
      "username": "janekfleper",
      "name": "Janek Fleper",
      "created_at": "2025-03-18T08:46:52.203Z",
      "updated_at": "2025-03-18T08:46:52.203Z",
      "cooked": "<p>The closest thing you can get to a custom function that returns a locateable element would be a figure with a custom <code>kind</code>. This will also automatically create a corresponding counter, you can use show rules to target the elements and you could even create an outline only for the verses.</p>\n<p>I decided to use an empty figure body here. All the actual content is put inside the caption. You don‚Äôt have to do it like this, but this makes it easier to get the correct formatting for the custom counter and the custom supplement in the show rule for <code>figure.caption</code>.</p>\n<p>While the function <code>verse()</code> itself looks quite verbose, there is no ‚Äúhacky‚Äù solution in there. If you know your way around show rules and set rules, this should be easy to understand and modify to your needs.</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let verse(body, label: none) = [\n  #show figure: set align(left)\n  #set figure(numbering: \"1.\")\n  #show figure.caption: it =&gt; context { \n    strong(it.counter.display()) + [ ]\n    it.supplement + [: ]\n    linebreak()\n    it.body\n  }\n  #figure(kind: \"verse\", supplement: \"Strophe\", [], caption: body)\n  #label\n]\n\n#let count-verses() = {\n  let locations = query(figure.where(kind: \"verse\")).map(h =&gt; h.location())\n  locations.filter(loc =&gt; loc.page() == here().page()).len()\n}\n\n#set page(\n  header: context count-verses(),\n  footer: context count-verses(),\n)\n\n#verse(lorem(2))\n#verse(lorem(2))\n#verse(lorem(2))\n#verse(lorem(2))\n\n#pagebreak()\n#counter(figure.where(kind: \"verse\")).update(0)\n#verse(lorem(2))\n#verse(lorem(2))\n#verse(lorem(2))\n</code></pre>",
      "raw": "The closest thing you can get to a custom function that returns a locateable element would be a figure with a custom `kind`. This will also automatically create a corresponding counter, you can use show rules to target the elements and you could even create an outline only for the verses.\n\nI decided to use an empty figure body here. All the actual content is put inside the caption. You don't have to do it like this, but this makes it easier to get the correct formatting for the custom counter and the custom supplement in the show rule for `figure.caption`.\n\nWhile the function `verse()` itself looks quite verbose, there is no \"hacky\" solution in there. If you know your way around show rules and set rules, this should be easy to understand and modify to your needs.\n```typ\n#let verse(body, label: none) = [\n  #show figure: set align(left)\n  #set figure(numbering: \"1.\")\n  #show figure.caption: it => context { \n    strong(it.counter.display()) + [ ]\n    it.supplement + [: ]\n    linebreak()\n    it.body\n  }\n  #figure(kind: \"verse\", supplement: \"Strophe\", [], caption: body)\n  #label\n]\n\n#let count-verses() = {\n  let locations = query(figure.where(kind: \"verse\")).map(h => h.location())\n  locations.filter(loc => loc.page() == here().page()).len()\n}\n\n#set page(\n  header: context count-verses(),\n  footer: context count-verses(),\n)\n\n#verse(lorem(2))\n#verse(lorem(2))\n#verse(lorem(2))\n#verse(lorem(2))\n\n#pagebreak()\n#counter(figure.where(kind: \"verse\")).update(0)\n#verse(lorem(2))\n#verse(lorem(2))\n#verse(lorem(2))\n```",
      "reply_to_post_number": 3,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 2,
      "reads": 18,
      "score": 33.6,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 69
    }
  ],
  "scraped_at": "2025-06-10T09:50:17.947412"
}