{
  "topic_metadata": {
    "id": 3591,
    "title": "How do I customize outline entries (`it.inner()` / `it.body()`)?",
    "slug": "how-do-i-customize-outline-entries-it-inner-it-body",
    "posts_count": 9,
    "created_at": "2025-04-09T21:35:55.519Z",
    "last_posted_at": "2025-04-16T21:45:01.870Z",
    "views": 191,
    "like_count": 0,
    "reply_count": 3,
    "has_accepted_answer": true,
    "accepted_answer_post_number": 4,
    "accepted_answer_username": "Chris",
    "tags": [
      "outline",
      "styling"
    ],
    "category_id": 5,
    "participant_count": 4,
    "word_count": 1425
  },
  "posts": [
    {
      "id": 10863,
      "post_number": 1,
      "username": "Chris",
      "name": "Christopher T. Kenny",
      "created_at": "2025-04-09T21:35:55.646Z",
      "updated_at": "2025-04-18T19:28:17.987Z",
      "cooked": "<p>Is there a simple way to edit or parse the <code>inner()</code> part of an outline entry?</p>\n<p>From the docs, the default rule is:</p>\n<pre data-code-wrap=\"typst\"><code class=\"lang-typst\">#show outline.entry: it =&gt; link(\n  it.element.location(),\n  it.indented(it.prefix(), it.inner()),\n)\n</code></pre>\n<p>and I can access the body with <code>it.body()</code> , but it seems like it gives a complicated sequence object.</p>\n<p>In particular, I want to split the body to only get up to the first period. (e.g. <code>This is figure 1. It does something.</code> =&gt; <code>This is figure 1.</code>)</p>\n<p>I suppose I could do something with <code>it.body()</code>, but it is not clear to me how to convert a sequence to a <code>str</code> or other editable object.</p>",
      "raw": "Is there a simple way to edit or parse the `inner()` part of an outline entry?\n\nFrom the docs, the default rule is:\n\n```typst\n#show outline.entry: it => link(\n  it.element.location(),\n  it.indented(it.prefix(), it.inner()),\n)\n```\n\nand I can access the body with `it.body()` , but it seems like it gives a complicated sequence object.\n\nIn particular, I want to split the body to only get up to the first period. (e.g. `This is figure 1. It does something.` => `This is figure 1.`)\n\nI suppose I could do something with `it.body()`, but it is not clear to me how to convert a sequence to a `str` or other editable object.",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 32,
      "score": 391.4,
      "accepted_answer": false,
      "trust_level": 1,
      "user_id": 105
    },
    {
      "id": 10864,
      "post_number": 2,
      "username": "aarnent",
      "name": "",
      "created_at": "2025-04-09T21:51:41.613Z",
      "updated_at": "2025-04-09T21:51:41.613Z",
      "cooked": "<p>You can access the entry’s text with <code>it.element.body.text</code>. In your case, if you want to ignore everything after the first period, you can do</p>\n<pre data-code-wrap=\"typst\"><code class=\"lang-typst\">#show outline.entry: it =&gt; link(\n  it.element.location(),\n  it.indented(it.prefix(), [\n    #it.element.body.text.split(\".\").first()\n    #box(width: 1fr, repeat(\".\", gap: 0.15em))  // styling\n    #it.page()  // styling\n  ]),\n)\n</code></pre>",
      "raw": "You can access the entry's text with `it.element.body.text`. In your case, if you want to ignore everything after the first period, you can do\n```typst\n#show outline.entry: it => link(\n  it.element.location(),\n  it.indented(it.prefix(), [\n    #it.element.body.text.split(\".\").first()\n    #box(width: 1fr, repeat(\".\", gap: 0.15em))  // styling\n    #it.page()  // styling\n  ]),\n)\n```",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 31,
      "score": 6.2,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 501
    },
    {
      "id": 10866,
      "post_number": 3,
      "username": "janekfleper",
      "name": "Janek Fleper",
      "created_at": "2025-04-09T23:08:03.085Z",
      "updated_at": "2025-04-09T23:11:06.391Z",
      "cooked": "<p>I wrote a function that splits the figure caption into a “title” and the “rest” of the caption for my thesis template. Since the caption body can be more complicated than a string, you cannot always directly split the body (text) at the first period. There are probably some cases that are not covered by the function yet, but it should already handle styling with <code>text()</code>, simple functions such as <code>emph()</code>, equations and general content sequences.</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">// Split a figure caption into a title and the rest\n//\n// The caption of a figure is usually just a block of content.\n// In the context of a thesis the caption can get quite long\n// and it would be great if the actual \"title\" of the figure\n// could be inferred from the caption. The title can then be\n// highlighted by using a bold font. And the title can also be\n// used in the table of figures where using the entire caption\n// would just take an insane amount of space.\n//\n// The approach with this function is to infer the title from\n// the caption body based on a specific separator. The easiest\n// choice here is to use the full stop/period. A colon could\n// also be useful in some cases.\n// The separator is not included with either the title or the\n// rest since the outline should not show the separator. In\n// the regular figure caption, the separator is just appended\n// to the title.\n//\n// An alternative approach is to define a short caption and a\n// long caption. The short caption will then be used for the\n// outline, and the long caption is used for the figure. This\n// is suggested in the Typst Examples Book:\n// https://sitandr.github.io/typst-examples-book/book/snippets/chapters/outlines.html#long-and-short-captions-for-the-outline\n//\n// - body (content): The caption\n// - separator (str): The separator to infer the title\n// -&gt; (dictionary):\n//    - title (content)\n//    - rest (content)\n#let split-figure-caption(body, separator) = {\n  if \"text\" in body.fields() {\n    // the actual separation is done here\n    let position = body.text.position(separator)\n    return (\n      title: if position == none { text(body.text) } else { text(body.text.slice(0, position)) },\n      rest: if position == none { none } else { text(body.text.slice(position + 1)) },\n    )\n  } else if \"child\" in body.fields() {\n    // this takes care of `styled()` functions such as `text(red)`\n    let func = body.func()\n    let args = body.styles\n    let (title, rest) = split-figure-caption(body.child, separator)\n    return (title: func(title, args), rest: if rest == none { none } else { func(rest, args) })\n  } else if \"body\" in body.fields() {\n    // this takes care of simple functions such as `emph()`\n    let func = body.func()\n    let (title, rest) = split-figure-caption(body.body, separator)\n    return (title: func(title), rest: if rest == none { none } else { func(rest) })\n  } else if \"children\" in body.fields() {\n    // this takes care of content sequences\n    let titles = ()\n    for i in range(body.children.len()) {\n      let (title, rest) = split-figure-caption(body.children.at(i), separator)\n      titles.push(title)\n      if rest != none {\n        return (\n          title: titles.join([]),\n          rest: ((rest,) + body.children.slice(i + 1)).join([]),\n        )\n      }\n    }\n  }\n\n  return (title: body, rest: none)\n}\n</code></pre>",
      "raw": "I wrote a function that splits the figure caption into a \"title\" and the \"rest\" of the caption for my thesis template. Since the caption body can be more complicated than a string, you cannot always directly split the body (text) at the first period. There are probably some cases that are not covered by the function yet, but it should already handle styling with `text()`, simple functions such as `emph()`, equations and general content sequences.\n\n```typ\n// Split a figure caption into a title and the rest\n//\n// The caption of a figure is usually just a block of content.\n// In the context of a thesis the caption can get quite long\n// and it would be great if the actual \"title\" of the figure\n// could be inferred from the caption. The title can then be\n// highlighted by using a bold font. And the title can also be\n// used in the table of figures where using the entire caption\n// would just take an insane amount of space.\n//\n// The approach with this function is to infer the title from\n// the caption body based on a specific separator. The easiest\n// choice here is to use the full stop/period. A colon could\n// also be useful in some cases.\n// The separator is not included with either the title or the\n// rest since the outline should not show the separator. In\n// the regular figure caption, the separator is just appended\n// to the title.\n//\n// An alternative approach is to define a short caption and a\n// long caption. The short caption will then be used for the\n// outline, and the long caption is used for the figure. This\n// is suggested in the Typst Examples Book:\n// https://sitandr.github.io/typst-examples-book/book/snippets/chapters/outlines.html#long-and-short-captions-for-the-outline\n//\n// - body (content): The caption\n// - separator (str): The separator to infer the title\n// -> (dictionary):\n//    - title (content)\n//    - rest (content)\n#let split-figure-caption(body, separator) = {\n  if \"text\" in body.fields() {\n    // the actual separation is done here\n    let position = body.text.position(separator)\n    return (\n      title: if position == none { text(body.text) } else { text(body.text.slice(0, position)) },\n      rest: if position == none { none } else { text(body.text.slice(position + 1)) },\n    )\n  } else if \"child\" in body.fields() {\n    // this takes care of `styled()` functions such as `text(red)`\n    let func = body.func()\n    let args = body.styles\n    let (title, rest) = split-figure-caption(body.child, separator)\n    return (title: func(title, args), rest: if rest == none { none } else { func(rest, args) })\n  } else if \"body\" in body.fields() {\n    // this takes care of simple functions such as `emph()`\n    let func = body.func()\n    let (title, rest) = split-figure-caption(body.body, separator)\n    return (title: func(title), rest: if rest == none { none } else { func(rest) })\n  } else if \"children\" in body.fields() {\n    // this takes care of content sequences\n    let titles = ()\n    for i in range(body.children.len()) {\n      let (title, rest) = split-figure-caption(body.children.at(i), separator)\n      titles.push(title)\n      if rest != none {\n        return (\n          title: titles.join([]),\n          rest: ((rest,) + body.children.slice(i + 1)).join([]),\n        )\n      }\n    }\n  }\n\n  return (title: body, rest: none)\n}\n```",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 31,
      "score": 6.2,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 69
    },
    {
      "id": 10943,
      "post_number": 4,
      "username": "Chris",
      "name": "Christopher T. Kenny",
      "created_at": "2025-04-11T16:56:23.875Z",
      "updated_at": "2025-04-11T16:56:23.875Z",
      "cooked": "<p>Thank you both for the replies. This gave me enough to figure out how to extract the right pieces. Looks like the following works:</p>\n<pre data-code-wrap=\"typst\"><code class=\"lang-typst\">show outline.entry: it =&gt; link(\n  it.element.location(),\n  it.indented(it.prefix(), [\n    #to-string(it.element.caption.body.children.flatten().join()).split(\".\").first()\n    #box(width: 1fr, repeat(\".\", gap: 0.15em))\n    #it.page()\n  ])\n)\n</code></pre>\n<p>where</p>\n<pre data-code-wrap=\"typst\"><code class=\"lang-typst\">let to-string(content) = {\n  if content.has(\"text\") {\n    content.text\n  } else if content.has(\"children\") {\n    content.children.map(to-string).join(\"\")\n  } else if content.has(\"body\") {\n    to-string(content.body)\n  } else if content == [ ] {\n    \" \"\n  }\n}\n</code></pre>",
      "raw": "Thank you both for the replies. This gave me enough to figure out how to extract the right pieces. Looks like the following works:\n\n```typst\nshow outline.entry: it => link(\n  it.element.location(),\n  it.indented(it.prefix(), [\n    #to-string(it.element.caption.body.children.flatten().join()).split(\".\").first()\n    #box(width: 1fr, repeat(\".\", gap: 0.15em))\n    #it.page()\n  ])\n)\n```\n\nwhere\n\n```typst\nlet to-string(content) = {\n  if content.has(\"text\") {\n    content.text\n  } else if content.has(\"children\") {\n    content.children.map(to-string).join(\"\")\n  } else if content.has(\"body\") {\n    to-string(content.body)\n  } else if content == [ ] {\n    \" \"\n  }\n}\n```",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 0,
      "reads": 22,
      "score": 9.4,
      "accepted_answer": true,
      "trust_level": 1,
      "user_id": 105
    },
    {
      "id": 11112,
      "post_number": 5,
      "username": "Andrew",
      "name": "",
      "created_at": "2025-04-15T13:40:26.126Z",
      "updated_at": "2025-04-15T13:50:52.354Z",
      "cooked": "<p>Can you explain why you can’t just change the heading name, or what is the practical purpose of this?</p>\n<p>You can simply apply a text show rule to this:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#show outline.entry: it =&gt; {\n  let heading-name = {\n    show regex(\"\\..*\"): \".\"\n    it.body()\n  }\n  let body = [#heading-name #box(width: 1fr, it.fill) #it.page()]\n  link(it.element.location(), it.indented(it.prefix(), body))\n}\n\n#outline()\n\n= This is figure 1. It does something\n</code></pre>\n<p><img src=\"https://forum.typst.app/uploads/default/original/2X/9/98e36f75c35f42e564ce61185a4555afb7fb071b.png\" alt=\"image\" data-base62-sha1=\"lOvQVbjJiq8yiPPSsRjLYBMEfOz\" width=\"572\" height=\"97\"></p>\n<p>This is not how you’re supposed to work in Typst, this should only be used if other more common solutions don’t work. Because regexing text is not the most robust solution.</p>",
      "raw": "Can you explain why you can't just change the heading name, or what is the practical purpose of this?\n\nYou can simply apply a text show rule to this:\n\n```typ\n#show outline.entry: it => {\n  let heading-name = {\n    show regex(\"\\..*\"): \".\"\n    it.body()\n  }\n  let body = [#heading-name #box(width: 1fr, it.fill) #it.page()]\n  link(it.element.location(), it.indented(it.prefix(), body))\n}\n\n#outline()\n\n= This is figure 1. It does something\n```\n\n![image|572x97](upload://lOvQVbjJiq8yiPPSsRjLYBMEfOz.png)\n\nThis is not how you're supposed to work in Typst, this should only be used if other more common solutions don't work. Because regexing text is not the most robust solution.",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 18,
      "score": 3.6,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 51
    },
    {
      "id": 11132,
      "post_number": 6,
      "username": "Chris",
      "name": "Christopher T. Kenny",
      "created_at": "2025-04-15T19:58:05.812Z",
      "updated_at": "2025-04-15T19:58:05.812Z",
      "cooked": "<p>That might work here with a bit of modification to get the figure captions. The practical purpose is for a thesis in a field where the norm is captions like:</p>\n<pre><code class=\"lang-auto\">A short title for the figure. Specific details in a few sentences that explain the figure in a lot more text. A bunch more words.\n</code></pre>\n<p>These get printed like:</p>\n<pre><code class=\"lang-auto\">Figure #. A short title for the figure. Specific details in a few sentences that explain the figure in a lot more text. A bunch more words.\n</code></pre>\n<p>The problem is that then printing to the outline, you get a very long description.</p>",
      "raw": "That might work here with a bit of modification to get the figure captions. The practical purpose is for a thesis in a field where the norm is captions like:\n\n```\nA short title for the figure. Specific details in a few sentences that explain the figure in a lot more text. A bunch more words.\n```\n\nThese get printed like:\n\n```\nFigure #. A short title for the figure. Specific details in a few sentences that explain the figure in a lot more text. A bunch more words.\n```\n\nThe problem is that then printing to the outline, you get a very long description.",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 0,
      "reads": 19,
      "score": 8.8,
      "accepted_answer": false,
      "trust_level": 1,
      "user_id": 105
    },
    {
      "id": 11182,
      "post_number": 7,
      "username": "Andrew",
      "name": "",
      "created_at": "2025-04-16T19:35:03.833Z",
      "updated_at": "2025-04-16T21:45:21.094Z",
      "cooked": "<p>Here you go:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let in-outline() = {\n  let after-start = query(selector(&lt;outline-start&gt;).before(here())).len() == 1\n  let before-end = query(selector(&lt;outline-end&gt;).after(here())).len() == 1\n  after-start and before-end\n}\n\n#let caption(short, details) = context {\n  if in-outline() { short } else { [#short #details] }\n}\n\n#show outline: it =&gt; {\n  [#metadata(none)&lt;outline-start&gt;#it#metadata(none)&lt;outline-end&gt;]\n}\n\n#show figure.where(kind: image): set figure(\n  numbering: (..n) =&gt; context {\n    if in-outline() { numbering(\"1.\", ..n) } else { numbering(\"1\", ..n) }\n  },\n)\n\n#outline(target: figure.where(kind: image), title: [Table of figures])\n\n#figure(\n  rect(),\n  caption: caption[A short title for the figure.][Specific details in a few sentences that explain the figure in a lot more text. A bunch more words.],\n)\n\n#figure(rect(), caption: caption[A short title for the figure.][#lorem(10)])\n</code></pre>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://forum.typst.app/uploads/default/original/2X/8/85f13259d3ee250a589817dc60c91bcbfb7ee325.png\" data-download-href=\"https://forum.typst.app/uploads/default/85f13259d3ee250a589817dc60c91bcbfb7ee325\" title=\"image\"><img src=\"https://forum.typst.app/uploads/default/optimized/2X/8/85f13259d3ee250a589817dc60c91bcbfb7ee325_2_690x277.png\" alt=\"image\" data-base62-sha1=\"j6UgqY0ZyXXNmMtNIG6cLEZBy0R\" width=\"690\" height=\"277\" srcset=\"https://forum.typst.app/uploads/default/optimized/2X/8/85f13259d3ee250a589817dc60c91bcbfb7ee325_2_690x277.png, https://forum.typst.app/uploads/default/original/2X/8/85f13259d3ee250a589817dc60c91bcbfb7ee325.png 1.5x, https://forum.typst.app/uploads/default/original/2X/8/85f13259d3ee250a589817dc60c91bcbfb7ee325.png 2x\" data-dominant-color=\"161616\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">image</span><span class=\"informations\">782×315 36.2 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>",
      "raw": "Here you go:\n\n```typ\n#let in-outline() = {\n  let after-start = query(selector(<outline-start>).before(here())).len() == 1\n  let before-end = query(selector(<outline-end>).after(here())).len() == 1\n  after-start and before-end\n}\n\n#let caption(short, details) = context {\n  if in-outline() { short } else { [#short #details] }\n}\n\n#show outline: it => {\n  [#metadata(none)<outline-start>#it#metadata(none)<outline-end>]\n}\n\n#show figure.where(kind: image): set figure(\n  numbering: (..n) => context {\n    if in-outline() { numbering(\"1.\", ..n) } else { numbering(\"1\", ..n) }\n  },\n)\n\n#outline(target: figure.where(kind: image), title: [Table of figures])\n\n#figure(\n  rect(),\n  caption: caption[A short title for the figure.][Specific details in a few sentences that explain the figure in a lot more text. A bunch more words.],\n)\n\n#figure(rect(), caption: caption[A short title for the figure.][#lorem(10)])\n```\n\n![image|690x277](upload://j6UgqY0ZyXXNmMtNIG6cLEZBy0R.png)",
      "reply_to_post_number": 6,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 0,
      "reads": 16,
      "score": 8.2,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 51
    },
    {
      "id": 11185,
      "post_number": 8,
      "username": "Chris",
      "name": "Christopher T. Kenny",
      "created_at": "2025-04-16T20:14:57.399Z",
      "updated_at": "2025-04-16T20:14:57.399Z",
      "cooked": "<aside class=\"quote no-group\" data-username=\"Chris\" data-post=\"4\" data-topic=\"3591\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img loading=\"lazy\" alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/user_avatar/forum.typst.app/chris/48/2604_2.png\" class=\"avatar\"> Chris:</div>\n<blockquote>\n<pre><code class=\"lang-auto\">show outline.entry: it =&gt; link(\n  it.element.location(),\n  it.indented(it.prefix(), [\n    #to-string(it.element.caption.body.children.flatten().join()).split(\".\").first()\n    #box(width: 1fr, repeat(\".\", gap: 0.15em))\n    #it.page()\n  ])\n)\n</code></pre>\n</blockquote>\n</aside>\n<p>Thanks, but the above solution does work and is much simpler.</p>",
      "raw": "[quote=\"Chris, post:4, topic:3591\"]\n```\nshow outline.entry: it => link(\n  it.element.location(),\n  it.indented(it.prefix(), [\n    #to-string(it.element.caption.body.children.flatten().join()).split(\".\").first()\n    #box(width: 1fr, repeat(\".\", gap: 0.15em))\n    #it.page()\n  ])\n)\n```\n[/quote]\n\nThanks, but the above solution does work and is much simpler.",
      "reply_to_post_number": 7,
      "reply_count": 1,
      "quote_count": 1,
      "like_count": 0,
      "reads": 16,
      "score": 8.2,
      "accepted_answer": false,
      "trust_level": 1,
      "user_id": 105
    },
    {
      "id": 11194,
      "post_number": 9,
      "username": "Andrew",
      "name": "",
      "created_at": "2025-04-16T21:45:01.870Z",
      "updated_at": "2025-04-16T21:45:01.870Z",
      "cooked": "<p>This solution is brittle and takes more lines (19 vs. 16):</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let to-string(content) = {\n  if content.has(\"text\") {\n    content.text\n  } else if content.has(\"children\") {\n    content.children.map(to-string).join(\"\")\n  } else if content.has(\"body\") {\n    to-string(content.body)\n  } else if content == [ ] {\n    \" \"\n  }\n}\n#show outline.entry: it =&gt; link(\n  it.element.location(),\n  it.indented(it.prefix(), [\n    #to-string(it.element.caption.body.children.flatten().join()).split(\".\").first()\n    #box(width: 1fr, repeat(\".\", gap: 0.15em))\n    #it.page()\n  ])\n)\n</code></pre>\n<br>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let in-outline() = {\n  let after-start = query(selector(&lt;outline-start&gt;).before(here())).len() == 1\n  let before-end = query(selector(&lt;outline-end&gt;).after(here())).len() == 1\n  after-start and before-end\n}\n#let caption(short, details) = context {\n  if in-outline() { short } else { [#short #details] }\n}\n#show outline: it =&gt; {\n  [#metadata(none)&lt;outline-start&gt;#it#metadata(none)&lt;outline-end&gt;]\n}\n#show figure.where(kind: image): set figure(\n  numbering: (..n) =&gt; context {\n    if in-outline() { numbering(\"1.\", ..n) } else { numbering(\"1\", ..n) }\n  },\n)\n</code></pre>\n<p>It doesn’t work with the caption example you provided:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#outline(target: figure.where(kind: image), title: [Table of figures])\n\n#figure(\n  rect(),\n  caption: [A short title for the figure. Specific details in a few sentences that explain the figure in a lot more text. A bunch more words.],\n)\n</code></pre>\n<p>Because the content is simple text, so it’s the <code>text</code> function and not <code>sequence</code>. If I add <code>---</code>, for example, it starts to work.</p>\n<p>Also from your example, there should be a period after <code>Figure #</code> in the outline, and your solution doesn’t include it. So it’s not really much simpler, but it also does less stuff and not as robust.</p>",
      "raw": "This solution is brittle and takes more lines (19 vs. 16):\n\n```typ\n#let to-string(content) = {\n  if content.has(\"text\") {\n    content.text\n  } else if content.has(\"children\") {\n    content.children.map(to-string).join(\"\")\n  } else if content.has(\"body\") {\n    to-string(content.body)\n  } else if content == [ ] {\n    \" \"\n  }\n}\n#show outline.entry: it => link(\n  it.element.location(),\n  it.indented(it.prefix(), [\n    #to-string(it.element.caption.body.children.flatten().join()).split(\".\").first()\n    #box(width: 1fr, repeat(\".\", gap: 0.15em))\n    #it.page()\n  ])\n)\n```\n\n<br>\n\n```typ\n#let in-outline() = {\n  let after-start = query(selector(<outline-start>).before(here())).len() == 1\n  let before-end = query(selector(<outline-end>).after(here())).len() == 1\n  after-start and before-end\n}\n#let caption(short, details) = context {\n  if in-outline() { short } else { [#short #details] }\n}\n#show outline: it => {\n  [#metadata(none)<outline-start>#it#metadata(none)<outline-end>]\n}\n#show figure.where(kind: image): set figure(\n  numbering: (..n) => context {\n    if in-outline() { numbering(\"1.\", ..n) } else { numbering(\"1\", ..n) }\n  },\n)\n```\n\nIt doesn't work with the caption example you provided:\n\n```typ\n#outline(target: figure.where(kind: image), title: [Table of figures])\n\n#figure(\n  rect(),\n  caption: [A short title for the figure. Specific details in a few sentences that explain the figure in a lot more text. A bunch more words.],\n)\n```\n\nBecause the content is simple text, so it's the `text` function and not `sequence`. If I add `---`, for example, it starts to work.\n\nAlso from your example, there should be a period after `Figure #` in the outline, and your solution doesn't include it. So it's not really much simpler, but it also does less stuff and not as robust.",
      "reply_to_post_number": 8,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 16,
      "score": 3.2,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 51
    }
  ],
  "scraped_at": "2025-06-10T09:49:26.058063"
}