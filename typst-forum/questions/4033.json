{
  "topic_metadata": {
    "id": 4033,
    "title": "How to generate sections and content from csv?",
    "slug": "how-to-generate-sections-and-content-from-csv",
    "posts_count": 4,
    "created_at": "2025-05-11T18:14:43.745Z",
    "last_posted_at": "2025-05-13T18:58:43.745Z",
    "views": 64,
    "like_count": 0,
    "reply_count": 0,
    "has_accepted_answer": true,
    "accepted_answer_post_number": 3,
    "accepted_answer_username": "Andrew",
    "tags": [
      "scripting"
    ],
    "category_id": 5,
    "participant_count": 4,
    "word_count": 738
  },
  "posts": [
    {
      "id": 12282,
      "post_number": 1,
      "username": "Michael",
      "name": "",
      "created_at": "2025-05-11T18:14:43.915Z",
      "updated_at": "2025-05-13T18:57:13.990Z",
      "cooked": "<p>For an event schedule I’d like to take date from a csv table and generate sections by location and within those sections list all events ordered by date.</p>\n<p>Suppose I have the following .csv:</p>\n<pre data-code-wrap=\"csv\"><code class=\"lang-csv\">title,date,city\nEvent1,2025-10-11T19:00,\"Amsterdam\"\nEvent2,2025-10-01T15:00,\"Amsterdam\"\nEvent3,2025-10-17T19:00,\"New York\"\nEvent4,2025-10-01T19:30,\"New York\"\n...\n</code></pre>\n<p>I’d like to get a document like this</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">= Amsterdam\n== 01/10/2025\n- Event2\n- ...\n- \n== 11/10/2025\n- Event 1\n- ...\n\n= New York\n...\n</code></pre>\n<p>I’ve already imported the csv and parsed the times into datetime objects so I have an array of dicts like this:</p>\n<pre data-code-wrap=\"typc\"><code class=\"lang-typc\">events\n\n(\n  (\n    title: \"Event2\",\n    date: datetime(\n      year: 2025,\n      month: 10,\n      day: 1,\n      hour: 15,\n      minute: 0,\n      second: 0,\n    ),\n    city: \"Amsterdam\",\n  ),\n  (\n  title: \"Event4\",\n...\n)\n</code></pre>\n<p>From this also was able to generate an array of unique cities</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let cities = ()\n#for event in events{\n  cities.push(event.at(\"city\"))\n}\n#let unique_cities = cities.dedup().sorted()\n</code></pre>\n<p>and use it to generate the city sections</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#for unique_city in unique_cities{\n\n  set page(...\n  )\n\n  // Section Heading for each city\n  align(center, text(heading(unique_city), size: 1.5em))\n\n// Get events for unique city and show them using the event template\n\nfor (title, date, city) in events {\n  if city == unique_city{\n  show: event.with(title: title, date: date, city: city)}\n}\n\n}\n</code></pre>\n<p>Now I am stuck at filtering events by city and then generating subsections for unique dates within a city. Also I suspect I’m doing this all in a very roundabout way. If someone could point me in the right direction I’d be grateful.</p>",
      "raw": "For an event schedule I'd like to take date from a csv table and generate sections by location and within those sections list all events ordered by date.\n\nSuppose I have the following .csv:\n\n````csv \ntitle,date,city\nEvent1,2025-10-11T19:00,\"Amsterdam\"\nEvent2,2025-10-01T15:00,\"Amsterdam\"\nEvent3,2025-10-17T19:00,\"New York\"\nEvent4,2025-10-01T19:30,\"New York\"\n...\n````\n\nI'd like to get a document like this\n\n\n```typ\n= Amsterdam\n== 01/10/2025\n- Event2\n- ...\n- \n== 11/10/2025\n- Event 1\n- ...\n\n= New York\n...\n```\n\nI've already imported the csv and parsed the times into datetime objects so I have an array of dicts like this:\n\n\n\n```typc\nevents\n\n(\n  (\n    title: \"Event2\",\n    date: datetime(\n      year: 2025,\n      month: 10,\n      day: 1,\n      hour: 15,\n      minute: 0,\n      second: 0,\n    ),\n    city: \"Amsterdam\",\n  ),\n  (\n  title: \"Event4\",\n...\n)\n```\n\nFrom this also was able to generate an array of unique cities \n\n```typ\n#let cities = ()\n#for event in events{\n  cities.push(event.at(\"city\"))\n}\n#let unique_cities = cities.dedup().sorted()\n```\nand use it to generate the city sections\n\n```typ\n#for unique_city in unique_cities{\n\n  set page(...\n  )\n\n  // Section Heading for each city\n  align(center, text(heading(unique_city), size: 1.5em))\n\n// Get events for unique city and show them using the event template\n\nfor (title, date, city) in events {\n  if city == unique_city{\n  show: event.with(title: title, date: date, city: city)}\n}\n\n}\n```\n\nNow I am stuck at filtering events by city and then generating subsections for unique dates within a city. Also I suspect I'm doing this all in a very roundabout way. If someone could point me in the right direction I'd be grateful.",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 23,
      "score": 29.6,
      "accepted_answer": false,
      "trust_level": 0,
      "user_id": 1569
    },
    {
      "id": 12285,
      "post_number": 2,
      "username": "aarnent",
      "name": "",
      "created_at": "2025-05-11T18:45:42.957Z",
      "updated_at": "2025-05-11T18:55:46.203Z",
      "cooked": "<p>I would create a nested dictionary where the first key is each city and it’s value is another dict with key the date and value an array of cities:</p>\n<pre data-code-wrap=\"typst\"><code class=\"lang-typst\">#let cities-and-events = (:)\n\n#for (event, date, city) in csv(\"data.csv\").slice(1) {\n  let city-map = cities-and-events.at(city, default: (:))\n  let date-events = city-map.at(date, default: ())\n  city-map.insert(date, date-events + (event,))\n  cities-and-events.insert(city, city-map)\n}\n</code></pre>\n<details>\n<summary>\nSummary</summary>\n<pre><code class=\"lang-auto\">(\n  Amsterdam: (\n    \"2025-10-11T19:00\": (\"Event1\",),\n    \"2025-10-01T15:00\": (\"Event2\",),\n  ),\n  \"New York\": (\n    \"2025-10-17T19:00\": (\"Event3\",),\n    \"2025-10-01T19:30\": (\"Event4\",),\n  ),\n)\n</code></pre>\n<p>The output would look like this</p>\n</details>\n<p>Then you can iterate through the dictionaries and style/format them as you wish:</p>\n<pre data-code-wrap=\"typst\"><code class=\"lang-typst\">#for (city, event-dict) in cities-and-events.pairs() [\n  #heading(level: 1, city)  // or `= #city`\n  \n  #for (date, event) in event-dict.pairs() [\n    #heading(level: 2, date)\n    #list(..event)\n  ]\n  \n]\n</code></pre>\n<details>\n<summary>\nSummary</summary>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://forum.typst.app/uploads/default/original/2X/6/6ecde1d8d1194c018c4ce8408eab353b5f9a9f53.png\" data-download-href=\"https://forum.typst.app/uploads/default/6ecde1d8d1194c018c4ce8408eab353b5f9a9f53\" title=\"image\"><img src=\"https://forum.typst.app/uploads/default/optimized/2X/6/6ecde1d8d1194c018c4ce8408eab353b5f9a9f53_2_308x499.png\" alt=\"image\" data-base62-sha1=\"fOdCAlMvEFxkRuttkJFXrstDqYb\" width=\"308\" height=\"499\" srcset=\"https://forum.typst.app/uploads/default/optimized/2X/6/6ecde1d8d1194c018c4ce8408eab353b5f9a9f53_2_308x499.png, https://forum.typst.app/uploads/default/original/2X/6/6ecde1d8d1194c018c4ce8408eab353b5f9a9f53.png 1.5x, https://forum.typst.app/uploads/default/original/2X/6/6ecde1d8d1194c018c4ce8408eab353b5f9a9f53.png 2x\" data-dominant-color=\"ECECEC\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">image</span><span class=\"informations\">328×531 42.8 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div><br>\nOutput</p>\n</details>\n<p>I’ll leave the parsing of the dates up to you since it seems you already managed to do that. Note that my solution <a href=\"https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics)\">does not sort the inputs</a></p>",
      "raw": "I would create a nested dictionary where the first key is each city and it's value is another dict with key the date and value an array of cities:\n\n```typst\n#let cities-and-events = (:)\n\n#for (event, date, city) in csv(\"data.csv\").slice(1) {\n  let city-map = cities-and-events.at(city, default: (:))\n  let date-events = city-map.at(date, default: ())\n  city-map.insert(date, date-events + (event,))\n  cities-and-events.insert(city, city-map)\n}\n```\n\n[details=\"Summary\"]\n```\n(\n  Amsterdam: (\n    \"2025-10-11T19:00\": (\"Event1\",),\n    \"2025-10-01T15:00\": (\"Event2\",),\n  ),\n  \"New York\": (\n    \"2025-10-17T19:00\": (\"Event3\",),\n    \"2025-10-01T19:30\": (\"Event4\",),\n  ),\n)\n```\nThe output would look like this\n[/details]\n\nThen you can iterate through the dictionaries and style/format them as you wish:\n```typst\n#for (city, event-dict) in cities-and-events.pairs() [\n  #heading(level: 1, city)  // or `= #city`\n  \n  #for (date, event) in event-dict.pairs() [\n    #heading(level: 2, date)\n    #list(..event)\n  ]\n  \n]\n```\n\n[details=\"Summary\"]\n![image|308x499](upload://fOdCAlMvEFxkRuttkJFXrstDqYb.png)\nOutput\n[/details]\n\nI'll leave the parsing of the dates up to you since it seems you already managed to do that. Note that my solution [does not sort the inputs](https://en.wikipedia.org/wiki/FIFO_(computing_and_electronics))",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 23,
      "score": 4.6,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 501
    },
    {
      "id": 12287,
      "post_number": 3,
      "username": "Andrew",
      "name": "",
      "created_at": "2025-05-11T18:54:22.111Z",
      "updated_at": "2025-05-14T21:51:09.102Z",
      "cooked": "<p>Hello. This is an interesting problem. The only problem is sorting, though here it’s not that hard, since you can use default lexicographic sort for any data. But if you have sorted rows, then you can omit it. The only missing part is <code>group-by()</code>, which isn’t that hard to implement:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let group-by(data, key) = {\n  let grouped-data = (:)\n  for row in data {\n    let value = row.at(key)\n    _ = row.remove(key)\n    grouped-data += ((value): grouped-data.at(value, default: ()) + (row,))\n  }\n  grouped-data\n}\n\n\n#let file = ```csv\ntitle,date,city\nEvent1,2025-10-11T19:00,\"Amsterdam\"\nEvent2,2025-10-01T15:00,\"Amsterdam\"\nEvent3,2025-10-17T19:00,\"New York\"\nEvent4,2025-10-01T19:30,\"New York\"\nEvent5,2025-10-01T19:30,\"New York\"\n```.text\n\n#let data = csv(bytes(file), row-type: dictionary)\n#let per-city-data = group-by(data.sorted(key: it =&gt; it.city), \"city\")\n#let per-city-per-date-data = for (city, data) in per-city-data {\n  ((city): group-by(data.sorted(key: it =&gt; (it.date, it.title)), \"date\"))\n}\n\n#for (city, per-date-events) in per-city-per-date-data {\n  heading(city)\n  for (date, events) in per-date-events [\n    == #date\n    #list(..events.map(x =&gt; x.values()).flatten())\n  ]\n}\n</code></pre>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://forum.typst.app/uploads/default/original/2X/b/b5abdecd88ee797d78ae71ae3e410aa911f32b1b.png\" data-download-href=\"https://forum.typst.app/uploads/default/b5abdecd88ee797d78ae71ae3e410aa911f32b1b\" title=\"image\"><img src=\"https://forum.typst.app/uploads/default/optimized/2X/b/b5abdecd88ee797d78ae71ae3e410aa911f32b1b_2_132x250.png\" alt=\"image\" data-base62-sha1=\"pV8EsFZESda1C749AFuakwn7R4n\" width=\"132\" height=\"250\" srcset=\"https://forum.typst.app/uploads/default/optimized/2X/b/b5abdecd88ee797d78ae71ae3e410aa911f32b1b_2_132x250.png, https://forum.typst.app/uploads/default/optimized/2X/b/b5abdecd88ee797d78ae71ae3e410aa911f32b1b_2_198x375.png 1.5x, https://forum.typst.app/uploads/default/optimized/2X/b/b5abdecd88ee797d78ae71ae3e410aa911f32b1b_2_264x500.png 2x\" data-dominant-color=\"1F1F1F\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">image</span><span class=\"informations\">333×627 37.2 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>At <code>== #date</code> you can format the date however you want. See <a href=\"https://github.com/typst/typst/issues/4107\" class=\"inline-onebox\">Add support for parsing datetimes from strings · Issue #4107 · typst/typst · GitHub</a>.</p>",
      "raw": "Hello. This is an interesting problem. The only problem is sorting, though here it's not that hard, since you can use default lexicographic sort for any data. But if you have sorted rows, then you can omit it. The only missing part is `group-by()`, which isn't that hard to implement:\n\n```typ\n#let group-by(data, key) = {\n  let grouped-data = (:)\n  for row in data {\n    let value = row.at(key)\n    _ = row.remove(key)\n    grouped-data += ((value): grouped-data.at(value, default: ()) + (row,))\n  }\n  grouped-data\n}\n\n\n#let file = ```csv\ntitle,date,city\nEvent1,2025-10-11T19:00,\"Amsterdam\"\nEvent2,2025-10-01T15:00,\"Amsterdam\"\nEvent3,2025-10-17T19:00,\"New York\"\nEvent4,2025-10-01T19:30,\"New York\"\nEvent5,2025-10-01T19:30,\"New York\"\n```.text\n\n#let data = csv(bytes(file), row-type: dictionary)\n#let per-city-data = group-by(data.sorted(key: it => it.city), \"city\")\n#let per-city-per-date-data = for (city, data) in per-city-data {\n  ((city): group-by(data.sorted(key: it => (it.date, it.title)), \"date\"))\n}\n\n#for (city, per-date-events) in per-city-per-date-data {\n  heading(city)\n  for (date, events) in per-date-events [\n    == #date\n    #list(..events.map(x => x.values()).flatten())\n  ]\n}\n```\n\n![image|265x500, 50%](upload://pV8EsFZESda1C749AFuakwn7R4n.png)\n\nAt `== #date` you can format the date however you want. See https://github.com/typst/typst/issues/4107.",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 22,
      "score": 104.4,
      "accepted_answer": true,
      "trust_level": 3,
      "user_id": 51
    },
    {
      "id": 12402,
      "post_number": 4,
      "username": "SillyFreak",
      "name": "SillyFreak",
      "created_at": "2025-05-13T18:58:43.745Z",
      "updated_at": "2025-05-13T18:58:43.745Z",
      "cooked": "<p>Hi <a class=\"mention\" href=\"/u/michael\">@Michael</a>, don’t forget to tick <img src=\"https://forum.typst.app/images/emoji/apple/ballot_box_with_check.png?v=12\" title=\":ballot_box_with_check:\" class=\"emoji\" alt=\":ballot_box_with_check:\" loading=\"lazy\" width=\"20\" height=\"20\"> one of the responses if you got a satisfying answer. The answer you choose should usually be the response that you found most correct/helpful/comprehensive for the question you asked. If something is missing, please let us know what so we can resolve your issue. Thanks!</p>",
      "raw": "Hi @Michael, don’t forget to tick :ballot_box_with_check: one of the responses if you got a satisfying answer. The answer you choose should usually be the response that you found most correct/helpful/comprehensive for the question you asked. If something is missing, please let us know what so we can resolve your issue. Thanks!",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 17,
      "score": 3.4,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 32
    }
  ],
  "scraped_at": "2025-06-10T09:48:00.185422"
}