{
  "topic_metadata": {
    "id": 4393,
    "title": "How to produce two glossaries from one dictionary or source file?",
    "slug": "how-to-produce-two-glossaries-from-one-dictionary-or-source-file",
    "posts_count": 15,
    "created_at": "2025-05-31T12:44:20.803Z",
    "last_posted_at": "2025-06-08T18:21:44.772Z",
    "views": 109,
    "like_count": 4,
    "reply_count": 11,
    "has_accepted_answer": true,
    "accepted_answer_post_number": 6,
    "accepted_answer_username": "quachpas",
    "tags": [
      "glossarium"
    ],
    "category_id": 5,
    "participant_count": 3,
    "word_count": 2394
  },
  "posts": [
    {
      "id": 13483,
      "post_number": 1,
      "username": "fungai2000",
      "name": "",
      "created_at": "2025-05-31T12:44:20.862Z",
      "updated_at": "2025-06-05T12:41:55.190Z",
      "cooked": "<p>I am looking for some advice. I would like to create a file that serves as a dictionary, where each entry has these three fields</p>\n<p>(a) English term<br>\n(b) transliterated foreign term<br>\n(c) comment</p>\n<p>Then, I wish to produce two separate glossaries:</p>\n<ul>\n<li>one organised by (a) the English term, and in which the “definition” of the entry is (b) the transliterated foreign term and (c) the comment</li>\n<li>one organised by (b) the transliterated foreign term, and in which the “definition” of the entry is (a) the English term and (c) the comment</li>\n</ul>\n<p>I do not need the terms to be indexed against their occurrence in an article or book.</p>\n<p>I am aware of both the glossy and glossarium packages, but this might exceed their abilities. I would be grateful for any advice on whether one of the existing packages can handle this, and/or any best practices on executing this. TIA.</p>",
      "raw": "I am looking for some advice. I would like to create a file that serves as a dictionary, where each entry has these three fields\n\n(a) English term\n(b) transliterated foreign term\n(c) comment\n\nThen, I wish to produce two separate glossaries: \n- one organised by (a) the English term, and in which the \"definition\" of the entry is (b) the transliterated foreign term and (c) the comment\n- one organised by (b) the transliterated foreign term, and in which the \"definition\" of the entry is (a) the English term and (c) the comment\n\nI do not need the terms to be indexed against their occurrence in an article or book.\n\nI am aware of both the glossy and glossarium packages, but this might exceed their abilities. I would be grateful for any advice on whether one of the existing packages can handle this, and/or any best practices on executing this. TIA.",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 28,
      "score": 25.6,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 1518
    },
    {
      "id": 13528,
      "post_number": 2,
      "username": "quachpas",
      "name": "Pascal Quach",
      "created_at": "2025-06-01T13:37:40.389Z",
      "updated_at": "2025-06-01T13:43:29.348Z",
      "cooked": "<p>Hello <a class=\"mention\" href=\"/u/fungai2000\">@fungai2000</a>! Are you looking to simply print the glossary? Do you also want to preserve the ability to “reference” a term?</p>\n<p>In which case, I don’t see why you wouldn’t be able to use either glossy or glossarium.</p>\n<p>A quick example without further formatting is like</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#import \"@preview/glossarium:0.5.6\": *\n\n#let list-a = (\n  (\n    key: \"Foo\",\n    long: \"Lorem\",\n    description: [Comment A]\n  ),\n  (\n    key: \"Bar\",\n    long: \"Ipsum\",\n    description: [Comment B]\n  ),\n)\n#let list-b = list-a.map(\n  x =&gt; (\n    key: x.long,\n    long: x.key,\n    description: x.description\n  )\n)\n#show: make-glossary\n#register-glossary(list-a)\n#register-glossary(list-b)\n\n= English to Latin\n#print-glossary(list-a, show-all: true)\n\n= Latin to English\n#print-glossary(list-b, show-all: true)\n</code></pre>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://forum.typst.app/uploads/default/original/2X/f/f57ed456b52c41e97f5bdc9634ea10627dd71a58.png\" data-download-href=\"https://forum.typst.app/uploads/default/f57ed456b52c41e97f5bdc9634ea10627dd71a58\" title=\"image\"><img src=\"https://forum.typst.app/uploads/default/original/2X/f/f57ed456b52c41e97f5bdc9634ea10627dd71a58.png\" alt=\"image\" data-base62-sha1=\"z1KI5sRGaKFCJ11pGgl7JOvDk7u\" width=\"452\" height=\"422\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">image</span><span class=\"informations\">452×422 61.7 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>",
      "raw": "Hello @fungai2000! Are you looking to simply print the glossary? Do you also want to preserve the ability to \"reference\" a term?\n\nIn which case, I don't see why you wouldn't be able to use either glossy or glossarium.\n\nA quick example without further formatting is like\n\n```typ\n#import \"@preview/glossarium:0.5.6\": *\n\n#let list-a = (\n  (\n    key: \"Foo\",\n    long: \"Lorem\",\n    description: [Comment A]\n  ),\n  (\n    key: \"Bar\",\n    long: \"Ipsum\",\n    description: [Comment B]\n  ),\n)\n#let list-b = list-a.map(\n  x => (\n    key: x.long,\n    long: x.key,\n    description: x.description\n  )\n)\n#show: make-glossary\n#register-glossary(list-a)\n#register-glossary(list-b)\n\n= English to Latin\n#print-glossary(list-a, show-all: true)\n\n= Latin to English\n#print-glossary(list-b, show-all: true)\n```\n![image|452x422](upload://z1KI5sRGaKFCJ11pGgl7JOvDk7u.png)",
      "reply_to_post_number": null,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 24,
      "score": 4.8,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 258
    },
    {
      "id": 13562,
      "post_number": 3,
      "username": "fungai2000",
      "name": "",
      "created_at": "2025-06-02T08:33:36.870Z",
      "updated_at": "2025-06-02T08:36:06.099Z",
      "cooked": "<p>Many thanks for this. That indeed solves for the question of drawing on one list for two printed glossaries.</p>\n<p>However, I have a follow-up question, if I may.</p>\n<p>In my “dictionary”, I have a need to map a single Latin term to multiple English equivalents.</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let list-a = (\n    (   key: \"Foo\",\n        long: \"Bar\", \"Lorem\", \"Ipsum\", \n        description: [Some description].\n    ),\n)\n</code></pre>\n<p>Is there a way, using the solutions you pointed out, to have the printed glossaries automatically render a one-to-many relationship for the Latin term to the multiple English terms, but then for each English term a new entry in the glossary? Such that the printed result would be something like:</p>\n<h2><a name=\"p-13562-latin-to-english-1\" class=\"anchor\" href=\"#p-13562-latin-to-english-1\"></a>Latin to English</h2>\n<p><em>Foo</em> – Bar, Lorem, Ipsum</p>\n<h2><a name=\"p-13562-english-to-latin-2\" class=\"anchor\" href=\"#p-13562-english-to-latin-2\"></a>English to Latin</h2>\n<p><em>Bar</em> – Foo<br>\n<em>Lorem</em> – Foo<br>\n<em>Ipsum</em> – Foo</p>",
      "raw": "Many thanks for this. That indeed solves for the question of drawing on one list for two printed glossaries.\n\nHowever, I have a follow-up question, if I may.\n\nIn my \"dictionary\", I have a need to map a single Latin term to multiple English equivalents.\n\n```\n#let list-a = (\n    (   key: \"Foo\",\n        long: \"Bar\", \"Lorem\", \"Ipsum\", \n        description: [Some description].\n    ),\n)\n```\nIs there a way, using the solutions you pointed out, to have the printed glossaries automatically render a one-to-many relationship for the Latin term to the multiple English terms, but then for each English term a new entry in the glossary? Such that the printed result would be something like:\n\n## Latin to English\n*Foo* – Bar, Lorem, Ipsum\n\n## English to Latin\n*Bar* – Foo\n*Lorem* – Foo\n*Ipsum* – Foo",
      "reply_to_post_number": null,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 0,
      "reads": 23,
      "score": 9.6,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 1518
    },
    {
      "id": 13563,
      "post_number": 4,
      "username": "quachpas",
      "name": "Pascal Quach",
      "created_at": "2025-06-02T08:52:18.541Z",
      "updated_at": "2025-06-02T08:52:18.541Z",
      "cooked": "<p>Sure! That’s not too complicated. You can simply have a list of terms in <code>long</code> and iterate over them to create the second list. Then make sure you actually pass a content in <code>long</code> to glossarium.</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#import \"@preview/glossarium:0.5.6\": *\n\n#let list-a = (\n  (\n    key: \"Foo\",\n    long: (\"Lorem\", \"Ipsum\"),\n    description: [Comment A]\n  ),\n  (\n    key: \"Bar\",\n    long: (\"Dolor\",),\n    description: [Comment B]\n  ),\n)\n#let list-b = list-a.map(\n  x =&gt; for y in x.long {((\n    key: y,\n    long: x.key,\n    description: x.description\n  ),)}\n).flatten()\n#list-b\n#let list-a = list-a.map(\n  x =&gt; (\n    key: x.key,\n    long: x.long.join(\", \"),\n    description: x.description\n  )\n)\n#show: make-glossary\n#register-glossary(list-a)\n#register-glossary(list-b)\n\n= English to Latin\n#print-glossary(list-a, show-all: true)\n\n= Latin to English\n#print-glossary(list-b, show-all: true)\n</code></pre>",
      "raw": "Sure! That's not too complicated. You can simply have a list of terms in `long` and iterate over them to create the second list. Then make sure you actually pass a content in `long` to glossarium.\n\n```typ\n#import \"@preview/glossarium:0.5.6\": *\n\n#let list-a = (\n  (\n    key: \"Foo\",\n    long: (\"Lorem\", \"Ipsum\"),\n    description: [Comment A]\n  ),\n  (\n    key: \"Bar\",\n    long: (\"Dolor\",),\n    description: [Comment B]\n  ),\n)\n#let list-b = list-a.map(\n  x => for y in x.long {((\n    key: y,\n    long: x.key,\n    description: x.description\n  ),)}\n).flatten()\n#list-b\n#let list-a = list-a.map(\n  x => (\n    key: x.key,\n    long: x.long.join(\", \"),\n    description: x.description\n  )\n)\n#show: make-glossary\n#register-glossary(list-a)\n#register-glossary(list-b)\n\n= English to Latin\n#print-glossary(list-a, show-all: true)\n\n= Latin to English\n#print-glossary(list-b, show-all: true)\n```",
      "reply_to_post_number": 3,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 1,
      "reads": 20,
      "score": 24.0,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 258
    },
    {
      "id": 13567,
      "post_number": 5,
      "username": "fungai2000",
      "name": "",
      "created_at": "2025-06-02T09:35:40.328Z",
      "updated_at": "2025-06-05T06:41:39.915Z",
      "cooked": "<p>This is really great, thank you! (I think there might be a mistake in the line <code>#list-b</code>; the above only worked when I removed that).</p>\n<p>One further step: is there a way in which to have one <code>key</code> term take multiple <code>long</code> values, where each of those <code>long</code> values is mapped to its own description? Such that the printed glossary would output something like:</p>\n<h2><a name=\"p-13567-latin-to-english-1\" class=\"anchor\" href=\"#p-13567-latin-to-english-1\"></a>Latin to English</h2>\n<p><strong>Foo</strong> – <em>Lorem</em>: Comment A. <em>Ipsum</em>: Comment B.</p>\n<h2><a name=\"p-13567-english-to-latin-2\" class=\"anchor\" href=\"#p-13567-english-to-latin-2\"></a>English to Latin</h2>\n<p><strong>Lorem</strong> – <em>Foo</em>: Comment A.<br>\n<strong>Ipsum</strong> – <em>Foo</em>: Comment B.</p>",
      "raw": "This is really great, thank you! (I think there might be a mistake in the line `#list-b`; the above only worked when I removed that).\n\nOne further step: is there a way in which to have one `key` term take multiple `long` values, where each of those `long` values is mapped to its own description? Such that the printed glossary would output something like:\n\n## Latin to English\n**Foo** – *Lorem*: Comment A. *Ipsum*: Comment B.\n\n## English to Latin \n**Lorem** – *Foo*: Comment A.\n**Ipsum** – *Foo*: Comment B.",
      "reply_to_post_number": 4,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 1,
      "reads": 19,
      "score": 23.8,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 1518
    },
    {
      "id": 13580,
      "post_number": 6,
      "username": "quachpas",
      "name": "Pascal Quach",
      "created_at": "2025-06-02T12:26:23.744Z",
      "updated_at": "2025-06-02T12:26:23.744Z",
      "cooked": "<p>I printed <code>list-b</code> for debug and forgot to remove it. For the descriptions, without testing I think it’s possible as long as you have a list of description (same length), and then iterate over all items in the lists. Something like this essentially.</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let list-a = list-a.map(\n  x =&gt; (\n    key: x.key,\n    long: x.long.first(),\n    description: x.description.slice(1).zip(x.long.slice(1)).fold(x.description.at(0), (desc, d) =&gt; {\n      desc + \". \" + d.at(1) + \": \" + d.at(0)\n    }) \n  )\n)\n</code></pre>\n<p>Make sure the <code>list-b</code> is updated to match the new structure, then</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let list-a = (\n  (\n    key: \"Foo\",\n    long: (\"Lorem\", \"Ipsum\"),\n    description: ([Comment A1], [Comment A2])\n  ),\n  (\n    key: \"Bar\",\n    long: (\"Dolor\",),\n    description: ([Comment B],)\n  ),\n)\n#let list-b = list-a.map(\n  x =&gt; for (i, y) in x.long.enumerate() {((\n    key: y,\n    long: x.key,\n    description: x.description.at(i)\n  ),)}\n).flatten()\n</code></pre>",
      "raw": "I printed `list-b` for debug and forgot to remove it. For the descriptions, without testing I think it's possible as long as you have a list of description (same length), and then iterate over all items in the lists. Something like this essentially.\n\n```typ\n#let list-a = list-a.map(\n  x => (\n    key: x.key,\n    long: x.long.first(),\n    description: x.description.slice(1).zip(x.long.slice(1)).fold(x.description.at(0), (desc, d) => {\n      desc + \". \" + d.at(1) + \": \" + d.at(0)\n    }) \n  )\n)\n```\n\nMake sure the `list-b` is updated to match the new structure, then\n\n```typ\n#let list-a = (\n  (\n    key: \"Foo\",\n    long: (\"Lorem\", \"Ipsum\"),\n    description: ([Comment A1], [Comment A2])\n  ),\n  (\n    key: \"Bar\",\n    long: (\"Dolor\",),\n    description: ([Comment B],)\n  ),\n)\n#let list-b = list-a.map(\n  x => for (i, y) in x.long.enumerate() {((\n    key: y,\n    long: x.key,\n    description: x.description.at(i)\n  ),)}\n).flatten()\n```",
      "reply_to_post_number": 5,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 1,
      "reads": 19,
      "score": 18.8,
      "accepted_answer": true,
      "trust_level": 3,
      "user_id": 258
    },
    {
      "id": 13590,
      "post_number": 7,
      "username": "fungai2000",
      "name": "",
      "created_at": "2025-06-02T14:15:59.655Z",
      "updated_at": "2025-06-03T07:02:02.447Z",
      "cooked": "<p>Thank you ever so much! The code you provided was the key I needed to get to my final resolution. I used VS Code with the integrated Claude assistant API to help me make a few small changes and formatting/styling modifications, until it produced the following desired result:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#import \"@preview/glossarium:0.5.6\": *\n\n#let my-custom-print-glossary(\n  entry-list,\n  show-all: true,\n  disable-back-references: false,\n  enable-group-pagebreak: false,\n  user-group-break: linebreak()\n) = {\n  // Your custom logic here\n  for entry in entry-list {\n    // Custom styling for each part with hanging indent\n    par(\n      first-line-indent: 0pt,\n      hanging-indent: 0em,\n      spacing: 12pt\n    )[\n      // Short form - apply your styling\n      #text(weight: \"bold\")[#entry.key#h(.3em)] \n      // Long form - apply italic styling\n      #if \"long\" in entry {\n        // Check if this is from list-a (already formatted) or list-b (needs formatting)\n        if type(entry.long) == content {\n          // This is from list-a, already formatted\n          entry.long\n        } else {\n          // This is from list-b, needs formatting\n          if \"description\" in entry and entry.description != [] {\n            emph(entry.long) + [: ] + entry.description\n          } else {\n            emph(entry.long) + [.]\n          }\n        }\n      }\n    ]\n  }\n}\n\n#let list-original = (\n  (\n    key: \"Foo\",\n    long: (\"Lorem\", \"Ipsum\"),\n    description: ([Comment A1], [Comment A2])\n  ),\n  (\n    key: \"Bar\",\n    long: (\"Dolor\",),\n    description: ([Comment B],)\n  ),\n)\n\n#let list-a = list-original.map(\n  x =&gt; for (i, y) in x.long.enumerate() {((\n    key: y,\n    long: x.key,\n    description: if x.description.at(i) != [] { x.description.at(i) + [.] } else { [] }\n  ),)}\n).flatten().sorted(key: entry =&gt; entry.key)\n\n#let list-b = list-original.map(\n  x =&gt; (\n    key: {x.key},\n    long: {\n      let pairs = x.long.zip(x.description).map(pair =&gt; {\n        let term = pair.at(0)\n        let desc = pair.at(1)\n        if desc != [] {\n          emph(term) + [: ] + desc\n        } else {\n          emph(term)\n        }\n      })\n      if x.long.len() == 1 {\n        pairs.join([]) + [.]\n      } else {\n        pairs.join([; ]) + [.]\n      }\n    },\n    description: []\n  )\n).sorted(key: entry =&gt; entry.key)\n\n#show: make-glossary\n#register-glossary(list-a)\n#register-glossary(list-b)\n\n=== English to Latin\n#my-custom-print-glossary(list-a, show-all: true)\n\n=== Latin to English\n#my-custom-print-glossary(list-b, show-all: true)\n</code></pre>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://forum.typst.app/uploads/default/original/2X/7/73b05532a5a03e663a535ad940c8316f24261ac5.png\" data-download-href=\"https://forum.typst.app/uploads/default/73b05532a5a03e663a535ad940c8316f24261ac5\" title=\"Screenshot 2025-06-03 at 10.01.36\"><img src=\"https://forum.typst.app/uploads/default/optimized/2X/7/73b05532a5a03e663a535ad940c8316f24261ac5_2_681x500.png\" alt=\"Screenshot 2025-06-03 at 10.01.36\" data-base62-sha1=\"gvqHqj1lDlMOOHKuhxdHnu4Rn1j\" width=\"681\" height=\"500\" srcset=\"https://forum.typst.app/uploads/default/optimized/2X/7/73b05532a5a03e663a535ad940c8316f24261ac5_2_681x500.png, https://forum.typst.app/uploads/default/optimized/2X/7/73b05532a5a03e663a535ad940c8316f24261ac5_2_1021x750.png 1.5x, https://forum.typst.app/uploads/default/original/2X/7/73b05532a5a03e663a535ad940c8316f24261ac5.png 2x\" data-dominant-color=\"F9F8F8\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">Screenshot 2025-06-03 at 10.01.36</span><span class=\"informations\">1030×756 48.8 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>Many thanks again, <a class=\"mention\" href=\"/u/quachpas\">@quachpas</a>, both the package and for your help in customising it above!</p>",
      "raw": "Thank you ever so much! The code you provided was the key I needed to get to my final resolution. I used VS Code with the integrated Claude assistant API to help me make a few small changes and formatting/styling modifications, until it produced the following desired result:\n\n```\n#import \"@preview/glossarium:0.5.6\": *\n\n#let my-custom-print-glossary(\n  entry-list,\n  show-all: true,\n  disable-back-references: false,\n  enable-group-pagebreak: false,\n  user-group-break: linebreak()\n) = {\n  // Your custom logic here\n  for entry in entry-list {\n    // Custom styling for each part with hanging indent\n    par(\n      first-line-indent: 0pt,\n      hanging-indent: 0em,\n      spacing: 12pt\n    )[\n      // Short form - apply your styling\n      #text(weight: \"bold\")[#entry.key#h(.3em)] \n      // Long form - apply italic styling\n      #if \"long\" in entry {\n        // Check if this is from list-a (already formatted) or list-b (needs formatting)\n        if type(entry.long) == content {\n          // This is from list-a, already formatted\n          entry.long\n        } else {\n          // This is from list-b, needs formatting\n          if \"description\" in entry and entry.description != [] {\n            emph(entry.long) + [: ] + entry.description\n          } else {\n            emph(entry.long) + [.]\n          }\n        }\n      }\n    ]\n  }\n}\n\n#let list-original = (\n  (\n    key: \"Foo\",\n    long: (\"Lorem\", \"Ipsum\"),\n    description: ([Comment A1], [Comment A2])\n  ),\n  (\n    key: \"Bar\",\n    long: (\"Dolor\",),\n    description: ([Comment B],)\n  ),\n)\n\n#let list-a = list-original.map(\n  x => for (i, y) in x.long.enumerate() {((\n    key: y,\n    long: x.key,\n    description: if x.description.at(i) != [] { x.description.at(i) + [.] } else { [] }\n  ),)}\n).flatten().sorted(key: entry => entry.key)\n\n#let list-b = list-original.map(\n  x => (\n    key: {x.key},\n    long: {\n      let pairs = x.long.zip(x.description).map(pair => {\n        let term = pair.at(0)\n        let desc = pair.at(1)\n        if desc != [] {\n          emph(term) + [: ] + desc\n        } else {\n          emph(term)\n        }\n      })\n      if x.long.len() == 1 {\n        pairs.join([]) + [.]\n      } else {\n        pairs.join([; ]) + [.]\n      }\n    },\n    description: []\n  )\n).sorted(key: entry => entry.key)\n\n#show: make-glossary\n#register-glossary(list-a)\n#register-glossary(list-b)\n\n=== English to Latin\n#my-custom-print-glossary(list-a, show-all: true)\n\n=== Latin to English\n#my-custom-print-glossary(list-b, show-all: true)\n```\n\n![Screenshot 2025-06-03 at 10.01.36|681x500](upload://gvqHqj1lDlMOOHKuhxdHnu4Rn1j.png)\n\nMany thanks again, @quachpas, both the package and for your help in customising it above!",
      "reply_to_post_number": null,
      "reply_count": 2,
      "quote_count": 0,
      "like_count": 0,
      "reads": 19,
      "score": 13.8,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 1518
    },
    {
      "id": 13610,
      "post_number": 8,
      "username": "quachpas",
      "name": "Pascal Quach",
      "created_at": "2025-06-03T06:26:32.371Z",
      "updated_at": "2025-06-03T06:26:32.371Z",
      "cooked": "<p>Good job on making it work! You probably don’t need to load glossarium, since you dropped the print-glossary for a custom one.</p>",
      "raw": "Good job on making it work! You probably don't need to load glossarium, since you dropped the print-glossary for a custom one.",
      "reply_to_post_number": 7,
      "reply_count": 0,
      "quote_count": 0,
      "like_count": 0,
      "reads": 17,
      "score": 3.4,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 258
    },
    {
      "id": 13710,
      "post_number": 9,
      "username": "Andrew",
      "name": "",
      "created_at": "2025-06-04T22:05:04.088Z",
      "updated_at": "2025-06-04T22:07:31.710Z",
      "cooked": "<p>It generated some stuff that is not used, and obviously a lot of verbose stuff (cause LLM). Here is a smaller version:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let my-custom-print-glossary(\n  entry-list,\n  // show-all: true,\n  // disable-back-references: false,\n  // enable-group-pagebreak: false,\n  // user-group-break: linebreak(),\n) = for entry in entry-list {\n  if \"long\" not in entry { continue }\n  let body = {\n    strong[#entry.key]\n    h(.3em)\n    if type(entry.long) == content { entry.long } else {\n      if \"description\" in entry and entry.description != [] {\n        [#emph(entry.long): #entry.description]\n      } else [#emph(entry.long).]\n    }\n  }\n  par(first-line-indent: 0pt, hanging-indent: 0em, spacing: 12pt, body)\n}\n\n\n#let list-original = (\n  (\n    key: \"Foo\",\n    long: (\"Lorem\", \"Ipsum\"),\n    description: ([Comment A1], [Comment A2]),\n  ),\n  (\n    key: \"Bar\",\n    long: (\"Dolor\",),\n    description: ([Comment B],),\n  ),\n)\n\n#let list-a = {\n  let mapper(x) = ((i, y)) =&gt; (\n    (\n      key: y,\n      long: x.key,\n      description: if x.description.at(i) != [] [#x.description.at(i).] else [],\n    ),\n  )\n  list-original\n    .map(x =&gt; x.long.enumerate().map(mapper(x)))\n    .flatten()\n    .sorted(key: entry =&gt; entry.key)\n}\n\n#let list-b = {\n  let long(x) = {\n    let pairs = x\n      .long\n      .zip(x.description)\n      .map(pair =&gt; {\n        let term = pair.first()\n        let desc = pair.last()\n        if desc != [] [#emph(term): #desc] else { emph(term) }\n      })\n    if x.long.len() == 1 [#pairs.join().] else [#pairs.join(\"; \").]\n  }\n  list-original\n    .map(x =&gt; (key: x.key, long: long(x), description: []))\n    .sorted(key: entry =&gt; entry.key)\n}\n\n=== English to Latin\n#my-custom-print-glossary(list-a)\n\n=== Latin to English\n#my-custom-print-glossary(list-b)\n</code></pre>\n<p>It’s basically the same, but it doesn’t create unaccounted spaces because of content block, comments, etc.</p>\n<p>It still looks overengineered, without diving deep into the topic. Also list-a/b probably could be functions, so that you have dictionary(-ies) and then convert them with a single function call. The functions then can go into a separate file.</p>\n<p>What I don’t understand is that for some reason key gets swapped with long, and then list sorted by key, i.e., long. But I didn’t read the thread.</p>",
      "raw": "It generated some stuff that is not used, and obviously a lot of verbose stuff (cause LLM). Here is a smaller version:\n\n```typ\n#let my-custom-print-glossary(\n  entry-list,\n  // show-all: true,\n  // disable-back-references: false,\n  // enable-group-pagebreak: false,\n  // user-group-break: linebreak(),\n) = for entry in entry-list {\n  if \"long\" not in entry { continue }\n  let body = {\n    strong[#entry.key]\n    h(.3em)\n    if type(entry.long) == content { entry.long } else {\n      if \"description\" in entry and entry.description != [] {\n        [#emph(entry.long): #entry.description]\n      } else [#emph(entry.long).]\n    }\n  }\n  par(first-line-indent: 0pt, hanging-indent: 0em, spacing: 12pt, body)\n}\n\n\n#let list-original = (\n  (\n    key: \"Foo\",\n    long: (\"Lorem\", \"Ipsum\"),\n    description: ([Comment A1], [Comment A2]),\n  ),\n  (\n    key: \"Bar\",\n    long: (\"Dolor\",),\n    description: ([Comment B],),\n  ),\n)\n\n#let list-a = {\n  let mapper(x) = ((i, y)) => (\n    (\n      key: y,\n      long: x.key,\n      description: if x.description.at(i) != [] [#x.description.at(i).] else [],\n    ),\n  )\n  list-original\n    .map(x => x.long.enumerate().map(mapper(x)))\n    .flatten()\n    .sorted(key: entry => entry.key)\n}\n\n#let list-b = {\n  let long(x) = {\n    let pairs = x\n      .long\n      .zip(x.description)\n      .map(pair => {\n        let term = pair.first()\n        let desc = pair.last()\n        if desc != [] [#emph(term): #desc] else { emph(term) }\n      })\n    if x.long.len() == 1 [#pairs.join().] else [#pairs.join(\"; \").]\n  }\n  list-original\n    .map(x => (key: x.key, long: long(x), description: []))\n    .sorted(key: entry => entry.key)\n}\n\n=== English to Latin\n#my-custom-print-glossary(list-a)\n\n=== Latin to English\n#my-custom-print-glossary(list-b)\n```\n\nIt's basically the same, but it doesn't create unaccounted spaces because of content block, comments, etc.\n\nIt still looks overengineered, without diving deep into the topic. Also list-a/b probably could be functions, so that you have dictionary(-ies) and then convert them with a single function call. The functions then can go into a separate file.\n\nWhat I don't understand is that for some reason key gets swapped with long, and then list sorted by key, i.e., long. But I didn't read the thread.",
      "reply_to_post_number": 7,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 0,
      "reads": 15,
      "score": 8.0,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 51
    },
    {
      "id": 13736,
      "post_number": 10,
      "username": "fungai2000",
      "name": "",
      "created_at": "2025-06-05T06:46:45.432Z",
      "updated_at": "2025-06-05T06:46:45.432Z",
      "cooked": "<p>Many thanks, <a class=\"mention\" href=\"/u/andrew\">@Andrew</a>, for helping improve upon the LLM-generated aspects of the code.</p>\n<p>As to your question: <code>Key</code> is the English term, and <code>Long</code> is the Latin term. From this we make two glossaries: one English-to-Latin, the other Latin-to-English. Within each list, I wanted the entries sorted.</p>\n<p>I’d be very happy to learn how to restructure this based on a dictionary and functions as you suggest. This solution grew out of glossarium, though by the end it was self-contained enough to not require the package any further.</p>",
      "raw": "Many thanks, @Andrew, for helping improve upon the LLM-generated aspects of the code.\n\nAs to your question: `Key` is the English term, and `Long` is the Latin term. From this we make two glossaries: one English-to-Latin, the other Latin-to-English. Within each list, I wanted the entries sorted.\n\nI'd be very happy to learn how to restructure this based on a dictionary and functions as you suggest. This solution grew out of glossarium, though by the end it was self-contained enough to not require the package any further.",
      "reply_to_post_number": 9,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 0,
      "reads": 13,
      "score": 7.6,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 1518
    },
    {
      "id": 13790,
      "post_number": 11,
      "username": "Andrew",
      "name": "",
      "created_at": "2025-06-05T19:17:55.657Z",
      "updated_at": "2025-06-05T19:21:10.030Z",
      "cooked": "<p>Now I feel more confident it what needs to be changed. The only thing I don’t like is “key” and “long”. I would use something like maybe “first”/“second” or “from”/“to”.</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let print-glossary(entry-list) = for entry in entry-list {\n  show: block.with(spacing: 1em)\n  strong(entry.key)\n  h(.3em)\n  emph(entry.long)\n  if entry.description != none [: #entry.description]\n  \".\"\n}\n\n/// Swaps key/long (English/Latin) values. Sorts by Latin.\n#let glossary-english-to-latin(glossary-data) = {\n  glossary-data\n    .map(entry =&gt; array\n      .zip(entry.long, entry.description)\n      .map(((long, description)) =&gt; (\n        (\n          key: long,\n          long: entry.key,\n          description: if description != [] [#description],\n        ),\n      )))\n    .flatten()\n    .sorted(key: entry =&gt; entry.key)\n}\n\n/// Doesn't swap key/long (English/Latin) values. Sorts by English.\n#let glossary-latin-to-english(glossary-data) = {\n  glossary-data\n    .map(entry =&gt; array\n      .zip(entry.long, entry.description)\n      .map(((long, description)) =&gt; (\n        (\n          key: entry.key,\n          long: long,\n          description: if description != [] [#description],\n        ),\n      )))\n    .flatten()\n    .sorted(key: entry =&gt; entry.key)\n}\n\n\n#let glossary-data = (\n  (\n    key: \"Foo\",\n    long: (\"Lorem\", \"Ipsum\"),\n    description: ([Comment A1], [Comment A2]),\n  ),\n  (\n    key: \"Bar\",\n    long: (\"Dolor\",),\n    description: ([Comment B],),\n  ),\n)\n\n#let english-to-latin-glossary = glossary-english-to-latin(glossary-data)\n#let latin-to-english-glossary = glossary-latin-to-english(glossary-data)\n\n=== English to Latin\n#print-glossary(english-to-latin-glossary)\n\n=== Latin to English\n#print-glossary(latin-to-english-glossary)\n</code></pre>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://forum.typst.app/uploads/default/original/2X/6/62121388a4eeffad5808d853b4abbcaca8107688.png\" data-download-href=\"https://forum.typst.app/uploads/default/62121388a4eeffad5808d853b4abbcaca8107688\" title=\"image\"><img src=\"https://forum.typst.app/uploads/default/original/2X/6/62121388a4eeffad5808d853b4abbcaca8107688.png\" alt=\"image\" data-base62-sha1=\"dZzwgrnnphNaPYAHM1tpTuCqMUE\" width=\"175\" height=\"214\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">image</span><span class=\"informations\">293×358 33.9 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>So, basically, we have the same input data, but then it’s passed through a processing function that spits out ready-to-print data. If you don’t need to access it, then just do</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">=== English to Latin\n#print-glossary(glossary-english-to-latin(glossary-data))\n\n=== Latin to English\n#print-glossary(glossary-latin-to-english(glossary-data))\n</code></pre>\n<p>Inside, a lot of <a href=\"https://typst.app/docs/reference/foundations/array/\"><code>array</code></a> methods were used in chains. For each entry, we go through a pair of long + description and make a new dictionary. Then sort by key and print.</p>",
      "raw": "Now I feel more confident it what needs to be changed. The only thing I don't like is \"key\" and \"long\". I would use something like maybe \"first\"/\"second\" or \"from\"/\"to\".\n\n```typ\n#let print-glossary(entry-list) = for entry in entry-list {\n  show: block.with(spacing: 1em)\n  strong(entry.key)\n  h(.3em)\n  emph(entry.long)\n  if entry.description != none [: #entry.description]\n  \".\"\n}\n\n/// Swaps key/long (English/Latin) values. Sorts by Latin.\n#let glossary-english-to-latin(glossary-data) = {\n  glossary-data\n    .map(entry => array\n      .zip(entry.long, entry.description)\n      .map(((long, description)) => (\n        (\n          key: long,\n          long: entry.key,\n          description: if description != [] [#description],\n        ),\n      )))\n    .flatten()\n    .sorted(key: entry => entry.key)\n}\n\n/// Doesn't swap key/long (English/Latin) values. Sorts by English.\n#let glossary-latin-to-english(glossary-data) = {\n  glossary-data\n    .map(entry => array\n      .zip(entry.long, entry.description)\n      .map(((long, description)) => (\n        (\n          key: entry.key,\n          long: long,\n          description: if description != [] [#description],\n        ),\n      )))\n    .flatten()\n    .sorted(key: entry => entry.key)\n}\n\n\n#let glossary-data = (\n  (\n    key: \"Foo\",\n    long: (\"Lorem\", \"Ipsum\"),\n    description: ([Comment A1], [Comment A2]),\n  ),\n  (\n    key: \"Bar\",\n    long: (\"Dolor\",),\n    description: ([Comment B],),\n  ),\n)\n\n#let english-to-latin-glossary = glossary-english-to-latin(glossary-data)\n#let latin-to-english-glossary = glossary-latin-to-english(glossary-data)\n\n=== English to Latin\n#print-glossary(english-to-latin-glossary)\n\n=== Latin to English\n#print-glossary(latin-to-english-glossary)\n```\n\n![image|293x358, 60%](upload://dZzwgrnnphNaPYAHM1tpTuCqMUE.png)\n\nSo, basically, we have the same input data, but then it's passed through a processing function that spits out ready-to-print data. If you don't need to access it, then just do\n\n```typ\n=== English to Latin\n#print-glossary(glossary-english-to-latin(glossary-data))\n\n=== Latin to English\n#print-glossary(glossary-latin-to-english(glossary-data))\n```\n\nInside, a lot of [`array`](https://typst.app/docs/reference/foundations/array/) methods were used in chains. For each entry, we go through a pair of long + description and make a new dictionary. Then sort by key and print.",
      "reply_to_post_number": 10,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 0,
      "reads": 13,
      "score": 7.6,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 51
    },
    {
      "id": 13835,
      "post_number": 12,
      "username": "fungai2000",
      "name": "",
      "created_at": "2025-06-07T08:13:15.764Z",
      "updated_at": "2025-06-07T08:13:15.764Z",
      "cooked": "<p>Many thanks for this, <a class=\"mention\" href=\"/u/andrew\">@Andrew</a>. I look forward to studying this to understand better the rationale behind the discrete changes.</p>\n<p>One thing has been lost, however, is a single term listing multiple meanings within the same entry rather than as separate entries.</p>",
      "raw": "Many thanks for this, @Andrew. I look forward to studying this to understand better the rationale behind the discrete changes.\n\nOne thing has been lost, however, is a single term listing multiple meanings within the same entry rather than as separate entries.",
      "reply_to_post_number": 11,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 0,
      "reads": 13,
      "score": 7.4,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 1518
    },
    {
      "id": 13849,
      "post_number": 13,
      "username": "Andrew",
      "name": "",
      "created_at": "2025-06-07T15:57:00.833Z",
      "updated_at": "2025-06-07T15:57:00.833Z",
      "cooked": "<p>I looked at the <a href=\"https://forum.typst.app/t/how-to-produce-two-glossaries-from-one-dictionary-or-source-file/4393\">spec</a>, and didn’t find anything about listings, so it works as was required in the OP, is the way I see it.</p>",
      "raw": "I looked at the [spec](https://forum.typst.app/t/how-to-produce-two-glossaries-from-one-dictionary-or-source-file/4393?u=andrew), and didn't find anything about listings, so it works as was required in the OP, is the way I see it.",
      "reply_to_post_number": 12,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 0,
      "reads": 13,
      "score": 7.4,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 51
    },
    {
      "id": 13872,
      "post_number": 14,
      "username": "fungai2000",
      "name": "",
      "created_at": "2025-06-08T17:15:01.389Z",
      "updated_at": "2025-06-08T17:16:25.039Z",
      "cooked": "<p>This is true, the original spec didn’t mention it, so you make a fair point. (I am the OP.) It developed over the course of the conversation.</p>\n<p>For posterity, and anyone interested, here is a modified version of Andrew’s helpful code above (using VS Code’s integrated Claude LLM assistant), to achieve the goal of (a) two glossaries drawn from one dictionary, (b) where one key term may have multiple target terms, (c) where each target term may have its own description, and (d) each key term finally prints out all the associated target terms coupled with their respective descriptions:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let print-glossary(entry-list) = for entry in entry-list {\n  show: block.with(spacing: 1em)\n  strong(entry.key)\n  h(.75em)\n  entry.long\n  if entry.description != none [: #entry.description]\n  \".\"\n}\n\n#let transform-glossary(data, swap: false) = {\n  if swap {\n    data\n      .map(entry =&gt; array\n        .zip(entry.long, entry.description)\n        .map(((long, description)) =&gt; (\n          key: long,\n          long: emph(entry.key),\n          description: if description != [] [#description]\n        )))\n      .flatten()\n  } else {\n    data\n      .map(entry =&gt; {\n        let parts = array\n          .zip(entry.long, entry.description)\n          .map(((long, description)) =&gt; {\n            if description != [] {\n              emph(long) + [: ] + description\n            } else {\n              emph(long)\n            }\n          })\n        (\n          key: entry.key,\n          long: parts.join([; ]),\n          description: none\n        )\n      })\n  }\n    .sorted(key: entry =&gt; entry.key)\n}\n\n#let glossary-data = (\n  (\n    key: \"Foo\",\n    long: (\"Lorem\", \"Ipsum\"),\n    description: ([Comment A1], [Comment A2]),\n  ),\n  (\n    key: \"Bar\",\n    long: (\"Dolor\",),\n    description: ([Comment B],),\n  ),\n)\n\n#let english-to-latin = transform-glossary(glossary-data, swap: true)\n#let latin-to-english = transform-glossary(glossary-data, swap: false)\n\n=== English to Latin\n#print-glossary(english-to-latin)\n\n=== Latin to English\n#print-glossary(latin-to-english)\n</code></pre>\n<p><div class=\"lightbox-wrapper\"><a class=\"lightbox\" href=\"https://forum.typst.app/uploads/default/original/2X/5/57abce24817b8c4a4b5d73194d886ec21ec1e263.png\" data-download-href=\"https://forum.typst.app/uploads/default/57abce24817b8c4a4b5d73194d886ec21ec1e263\" title=\"Screenshot 2025-06-08 at 20.11.48\"><img src=\"https://forum.typst.app/uploads/default/optimized/2X/5/57abce24817b8c4a4b5d73194d886ec21ec1e263_2_690x453.png\" alt=\"Screenshot 2025-06-08 at 20.11.48\" data-base62-sha1=\"cvzD7rjawjuyRQ6lxhcYnDVld1F\" width=\"690\" height=\"453\" srcset=\"https://forum.typst.app/uploads/default/optimized/2X/5/57abce24817b8c4a4b5d73194d886ec21ec1e263_2_690x453.png, https://forum.typst.app/uploads/default/original/2X/5/57abce24817b8c4a4b5d73194d886ec21ec1e263.png 1.5x, https://forum.typst.app/uploads/default/original/2X/5/57abce24817b8c4a4b5d73194d886ec21ec1e263.png 2x\" data-dominant-color=\"F6F6F6\"><div class=\"meta\"><svg class=\"fa d-icon d-icon-far-image svg-icon\" aria-hidden=\"true\"><use href=\"#far-image\"></use></svg><span class=\"filename\">Screenshot 2025-06-08 at 20.11.48</span><span class=\"informations\">858×564 37.9 KB</span><svg class=\"fa d-icon d-icon-discourse-expand svg-icon\" aria-hidden=\"true\"><use href=\"#discourse-expand\"></use></svg></div></a></div></p>\n<p>Again, it might be a bit verbose (again, due to the LLM bits). In any case, many thanks to both <a class=\"mention\" href=\"/u/quachpas\">@quachpas</a> and <a class=\"mention\" href=\"/u/andrew\">@Andrew</a> for their help!</p>",
      "raw": "This is true, the original spec didn't mention it, so you make a fair point. (I am the OP.) It developed over the course of the conversation.\n\nFor posterity, and anyone interested, here is a modified version of Andrew's helpful code above (using VS Code's integrated Claude LLM assistant), to achieve the goal of (a) two glossaries drawn from one dictionary, (b) where one key term may have multiple target terms, (c) where each target term may have its own description, and (d) each key term finally prints out all the associated target terms coupled with their respective descriptions:\n\n```\n#let print-glossary(entry-list) = for entry in entry-list {\n  show: block.with(spacing: 1em)\n  strong(entry.key)\n  h(.75em)\n  entry.long\n  if entry.description != none [: #entry.description]\n  \".\"\n}\n\n#let transform-glossary(data, swap: false) = {\n  if swap {\n    data\n      .map(entry => array\n        .zip(entry.long, entry.description)\n        .map(((long, description)) => (\n          key: long,\n          long: emph(entry.key),\n          description: if description != [] [#description]\n        )))\n      .flatten()\n  } else {\n    data\n      .map(entry => {\n        let parts = array\n          .zip(entry.long, entry.description)\n          .map(((long, description)) => {\n            if description != [] {\n              emph(long) + [: ] + description\n            } else {\n              emph(long)\n            }\n          })\n        (\n          key: entry.key,\n          long: parts.join([; ]),\n          description: none\n        )\n      })\n  }\n    .sorted(key: entry => entry.key)\n}\n\n#let glossary-data = (\n  (\n    key: \"Foo\",\n    long: (\"Lorem\", \"Ipsum\"),\n    description: ([Comment A1], [Comment A2]),\n  ),\n  (\n    key: \"Bar\",\n    long: (\"Dolor\",),\n    description: ([Comment B],),\n  ),\n)\n\n#let english-to-latin = transform-glossary(glossary-data, swap: true)\n#let latin-to-english = transform-glossary(glossary-data, swap: false)\n\n=== English to Latin\n#print-glossary(english-to-latin)\n\n=== Latin to English\n#print-glossary(latin-to-english)\n```\n\n![Screenshot 2025-06-08 at 20.11.48|690x453](upload://cvzD7rjawjuyRQ6lxhcYnDVld1F.png)\n\nAgain, it might be a bit verbose (again, due to the LLM bits). In any case, many thanks to both @quachpas and @Andrew for their help!",
      "reply_to_post_number": 13,
      "reply_count": 1,
      "quote_count": 0,
      "like_count": 0,
      "reads": 10,
      "score": 6.6,
      "accepted_answer": false,
      "trust_level": 2,
      "user_id": 1518
    },
    {
      "id": 13878,
      "post_number": 15,
      "username": "Andrew",
      "name": "",
      "created_at": "2025-06-08T18:21:44.772Z",
      "updated_at": "2025-06-08T18:21:44.772Z",
      "cooked": "<aside class=\"quote no-group\" data-username=\"fungai2000\" data-post=\"14\" data-topic=\"4393\">\n<div class=\"title\">\n<div class=\"quote-controls\"></div>\n<img alt=\"\" width=\"24\" height=\"24\" src=\"https://forum.typst.app/letter_avatar_proxy/v4/letter/f/A561FF/48.png\" class=\"avatar\"> fungai2000:</div>\n<blockquote>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let transform-glossary(data, swap: false) = {\n  if swap {\n    data\n      .map(entry =&gt; array\n        .zip(entry.long, entry.description)\n        .map(((long, description)) =&gt; (\n          key: long,\n          long: emph(entry.key),\n          description: if description != [] [#description]\n        )))\n      .flatten()\n  } else {\n    data\n      .map(entry =&gt; {\n        let parts = array\n          .zip(entry.long, entry.description)\n          .map(((long, description)) =&gt; {\n            if description != [] {\n              emph(long) + [: ] + description\n            } else {\n              emph(long)\n            }\n          })\n        (\n          key: entry.key,\n          long: parts.join([; ]),\n          description: none\n        )\n      })\n  }\n    .sorted(key: entry =&gt; entry.key)\n}\n</code></pre>\n</blockquote>\n</aside>\n<p>You can also do something like this:</p>\n<pre data-code-wrap=\"typ\"><code class=\"lang-typ\">#let transform-glossary(data, swap: false) = if swap {\n  data\n    .map(entry =&gt; array\n      .zip(entry.long, entry.description)\n      .map(((long, description)) =&gt; (\n        key: long,\n        long: emph(entry.key),\n        description: if description != [] [#description],\n      )))\n    .flatten()\n} else {\n  data.map(entry =&gt; (\n    key: entry.key,\n    long: array\n      .zip(entry.long, entry.description)\n      .map(((long, description)) =&gt; {\n        emph(long) + if description != [] [: #description]\n      })\n      .join[; ],\n    description: none,\n  ))\n}.sorted(key: entry =&gt; entry.key)\n</code></pre>",
      "raw": "[quote=\"fungai2000, post:14, topic:4393\"]\n```typ\n#let transform-glossary(data, swap: false) = {\n  if swap {\n    data\n      .map(entry => array\n        .zip(entry.long, entry.description)\n        .map(((long, description)) => (\n          key: long,\n          long: emph(entry.key),\n          description: if description != [] [#description]\n        )))\n      .flatten()\n  } else {\n    data\n      .map(entry => {\n        let parts = array\n          .zip(entry.long, entry.description)\n          .map(((long, description)) => {\n            if description != [] {\n              emph(long) + [: ] + description\n            } else {\n              emph(long)\n            }\n          })\n        (\n          key: entry.key,\n          long: parts.join([; ]),\n          description: none\n        )\n      })\n  }\n    .sorted(key: entry => entry.key)\n}\n```\n[/quote]\n\nYou can also do something like this:\n\n```typ\n#let transform-glossary(data, swap: false) = if swap {\n  data\n    .map(entry => array\n      .zip(entry.long, entry.description)\n      .map(((long, description)) => (\n        key: long,\n        long: emph(entry.key),\n        description: if description != [] [#description],\n      )))\n    .flatten()\n} else {\n  data.map(entry => (\n    key: entry.key,\n    long: array\n      .zip(entry.long, entry.description)\n      .map(((long, description)) => {\n        emph(long) + if description != [] [: #description]\n      })\n      .join[; ],\n    description: none,\n  ))\n}.sorted(key: entry => entry.key)\n```",
      "reply_to_post_number": 14,
      "reply_count": 0,
      "quote_count": 1,
      "like_count": 1,
      "reads": 10,
      "score": 16.8,
      "accepted_answer": false,
      "trust_level": 3,
      "user_id": 51
    }
  ],
  "scraped_at": "2025-06-10T09:46:59.926291"
}